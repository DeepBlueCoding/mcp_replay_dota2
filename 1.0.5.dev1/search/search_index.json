{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MCP Dota 2 Match Analysis Server","text":"AI Summary <p>MCP server for Dota 2 match analysis. Tools (LLM calls these): <code>get_match_heroes</code>, <code>get_match_players</code>, <code>get_hero_deaths</code>, <code>get_combat_log</code>, <code>get_fight_combat_log</code>, <code>get_item_purchases</code>, <code>get_objective_kills</code>, <code>get_match_timeline</code>, <code>get_stats_at_minute</code>, <code>get_courier_kills</code>, plus pro scene tools. Game State Tools: <code>list_fights</code>, <code>get_teamfights</code>, <code>get_fight</code>, <code>get_lane_summary</code>, <code>get_cs_at_minute</code>, <code>get_snapshot_at_time</code>, <code>get_farming_pattern</code>. Resources (static context): <code>dota2://heroes/all</code>, <code>dota2://map</code>, <code>dota2://pro/players</code>, <code>dota2://pro/teams</code>. Many tools are parallel-safe for efficient multi-point analysis. Connects to Claude Desktop, Claude Code, LangChain, LangGraph, CrewAI, or direct API integration.</p> <p>A Model Context Protocol (MCP) server that gives LLMs the ability to analyze Dota 2 matches by parsing replay files and querying the OpenDota API.</p>"},{"location":"#coaching-philosophy","title":"Coaching Philosophy","text":"<p>This server includes built-in coaching instructions that guide LLM responses to provide meaningful analysis, not just raw data dumps:</p> <ul> <li>Pattern Recognition: Identify repetitive death patterns (support positioning, smoke ganks, vision-related deaths)</li> <li>Objective Analysis: Link tower kills to hero rotations (mid with rune, supports via portal, defender TPs)</li> <li>Economy Tracking: Explain networth swings in context of teamfights and objectives taken</li> <li>Actionable Advice: Every analysis ends with specific, actionable coaching points</li> </ul> <p>The LLM is instructed to analyze the \"why\" behind the data, connecting statistics to game-changing decisions.</p>"},{"location":"#what-this-does","title":"What This Does","text":"<p>This server exposes tools and resources that an LLM can call to answer questions about Dota 2 matches:</p> <ul> <li>\"Why did we lose the teamfight at 25 minutes?\"</li> <li>\"How did the enemy Anti-Mage get such a fast Battle Fury?\"</li> <li>\"When did Roshan die and who took the Aegis?\"</li> <li>\"Show me what happened when I died at minute 12\"</li> </ul> <p>The LLM reads the replay data and provides analysis based on actual game events, not guesswork.</p>"},{"location":"#how-mcp-works","title":"How MCP Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   LLM Client    \u2502 \u2500\u2500MCP\u2500\u2500 \u2502   This Server   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25b8 \u2502  Replay Parser  \u2502\n\u2502 (Claude, GPT)   \u2502         \u2502                 \u2502         \u2502  OpenDota API   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                           \u2502\n         \u2502   \"Analyze match 123\"     \u2502\n         \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b8\u2502\n         \u2502                           \u2502\n         \u2502                           \u2502\u2500\u2500 calls get_hero_deaths(123)\n         \u2502                           \u2502\u2500\u2500 calls get_combat_log(123, ...)\n         \u2502                           \u2502\u2500\u2500 calls get_objective_kills(123)\n         \u2502                           \u2502\n         \u2502   structured JSON data    \u2502\n         \u2502 \u25c2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n         \u2502                           \u2502\n         \u25bc                           \u25bc\n   LLM synthesizes response: \"The fight was lost because...\"\n</code></pre> <p>Resources = Static data the LLM can reference (hero list, map positions) Tools = Functions the LLM can call with parameters (get deaths, get combat log)</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#option-a-local-install","title":"Option A: Local Install","text":"<pre><code>git clone https://github.com/DeepBlueCoding/mcp-replay-dota2.git\ncd mcp-replay-dota2\nuv sync\nuv run python dota_match_mcp_server.py\n</code></pre>"},{"location":"#option-b-docker","title":"Option B: Docker","text":"<pre><code>docker build -t dota2-mcp-server .\ndocker run -p 8081:8081 dota2-mcp-server --transport sse\n</code></pre> <p>Connect to <code>http://localhost:8081/sse</code>. See Docker Guide for details.</p>"},{"location":"#2-connect-to-your-llm","title":"2. Connect to Your LLM","text":"<p>See Integrations for setup with:</p> <ul> <li>Claude Desktop</li> <li>Claude Code CLI</li> <li>OpenAI + LangChain</li> <li>Custom Python clients</li> </ul>"},{"location":"#3-ask-questions","title":"3. Ask Questions","text":"<p>Once connected, just ask naturally:</p> <p>\"Analyze match 8461956309. Why did Radiant lose?\"</p> <p>The LLM will automatically call the appropriate tools and synthesize an analysis.</p>"},{"location":"#available-tools","title":"Available Tools","text":""},{"location":"#match-analysis","title":"Match Analysis","text":"Tool What It Does <code>download_replay</code> Pre-cache replay file (call first for new matches) <code>get_match_info</code> Match metadata (teams, players, winner) <code>get_match_heroes</code> 10 heroes with KDA, items, stats, counter picks <code>get_match_players</code> 10 players with names and hero assignments <code>get_match_draft</code> Complete draft order (bans/picks) <code>get_match_timeline</code> Net worth, XP, KDA over time <code>get_stats_at_minute</code> Snapshot of all players at a specific minute \u26a1 <code>get_hero_deaths</code> All deaths with killer, victim, ability used <code>get_combat_log</code> Damage events, abilities, modifiers in a time range <code>get_fight_combat_log</code> Auto-detects fight boundaries around a death <code>get_item_purchases</code> When each item was bought <code>get_objective_kills</code> Roshan, towers, barracks timings <code>get_courier_kills</code> Courier snipes with position <code>get_rune_pickups</code> Rune pickups by hero"},{"location":"#game-state-analysis","title":"Game State Analysis","text":"Tool What It Does <code>list_fights</code> All fights with teamfight/skirmish classification <code>get_teamfights</code> Major teamfights (3+ deaths) <code>get_fight</code> Detailed fight info with positions \u26a1 <code>get_camp_stacks</code> Neutral camp stacking events <code>get_jungle_summary</code> Stacking efficiency by hero <code>get_lane_summary</code> Laning phase winners and hero stats <code>get_cs_at_minute</code> CS/gold/level at specific minute \u26a1 <code>get_hero_positions</code> Hero positions at specific minute \u26a1 <code>get_snapshot_at_time</code> High-resolution game state at specific time \u26a1 <code>get_position_timeline</code> Hero movement over time range \u26a1 <code>get_fight_replay</code> High-resolution replay data for fights \u26a1 <code>get_farming_pattern</code> Analyze farming pattern (creeps, camps, movement) <p>\u26a1 = Parallel-safe: Call multiple times with different parameters in parallel for faster analysis.</p>"},{"location":"#pro-scene","title":"Pro Scene","text":"Tool What It Does <code>search_pro_player</code> Fuzzy search for pro players <code>search_team</code> Fuzzy search for teams <code>get_pro_player</code> Get player details by account ID <code>get_team</code> Get team details + roster <code>get_team_matches</code> Team match history with series grouping <code>get_leagues</code> All leagues/tournaments <code>get_pro_matches</code> Recent pro matches with series grouping (supports head-to-head filtering) <code>get_league_matches</code> Matches from a specific league"},{"location":"#available-resources","title":"Available Resources","text":"<p>Static reference data (user attaches to context):</p> URI Data <code>dota2://heroes/all</code> All 124 heroes with attributes <code>dota2://map</code> Tower, camp, rune, landmark positions <code>dota2://pro/players</code> All pro players <code>dota2://pro/teams</code> All pro teams <p>Match-specific data uses tools</p> <p>For match heroes/players and detailed pro player/team info, use the corresponding tools (<code>get_match_heroes</code>, <code>get_match_players</code>, <code>get_pro_player</code>, <code>get_team</code>).</p>"},{"location":"#example-conversations","title":"Example Conversations","text":"<p>See Use Cases for detailed examples:</p> <ul> <li>Analyzing why a teamfight was lost</li> <li>Tracking a carry's item timings</li> <li>Understanding a gank that went wrong</li> <li>Comparing laning phase performance</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/","title":"Dota 2 Replay Parsing Architecture","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#overview","title":"Overview","text":"<p>This document describes the architecture for parsing Dota 2 replay files (.dem) and exposing match analysis via MCP tools. The architecture is split into two distinct layers:</p> <ol> <li>Services Layer: Business logic for replay parsing and match analysis (no MCP dependencies)</li> <li>MCP Layer: Thin wrapper exposing services via MCP tools/resources (no business logic)</li> </ol> <p>This separation allows the services to be reused in other systems (CLI tools, web APIs, etc.) without MCP dependencies.</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Design Principles</li> <li>Two-Layer Architecture</li> <li>Services Layer</li> <li>MCP Layer</li> <li>python-manta v2 Integration</li> <li>Data Models</li> <li>Cache Strategy</li> <li>Directory Structure</li> <li>Data Flow</li> <li>First Parse: Complete Data Extraction</li> </ol>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#core-principles","title":"Core Principles","text":"Principle Description Separation of Concerns Business logic in services, MCP logic in MCP layer Reusable Services Services have zero MCP dependencies, can be used anywhere Parse Once Single <code>Parser.parse()</code> call per replay via python-manta v2 Cache Everything Full <code>ParsedReplayData</code> stored persistently Thin MCP Layer MCP tools are simple wrappers, no business logic Data-Driven Logic Detection algorithms designed around python-manta v2 data"},{"location":"REPLAY_PARSING_ARCHITECTURE/#layer-rules","title":"Layer Rules","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP LAYER (src/mcp/)                                                   \u2502\n\u2502                                                                         \u2502\n\u2502  \u2713 MCP tool/resource definitions                                       \u2502\n\u2502  \u2713 Parameter validation for MCP                                        \u2502\n\u2502  \u2713 Response formatting for MCP                                         \u2502\n\u2502  \u2717 NO business logic                                                   \u2502\n\u2502  \u2717 NO direct python-manta calls                                        \u2502\n\u2502  \u2717 NO direct opendota-sdk calls                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  SERVICES LAYER (src/services/)                                         \u2502\n\u2502                                                                         \u2502\n\u2502  \u2713 All business logic                                                  \u2502\n\u2502  \u2713 python-manta integration                                            \u2502\n\u2502  \u2713 opendota-sdk integration                                            \u2502\n\u2502  \u2713 Caching logic                                                       \u2502\n\u2502  \u2713 Analysis/detection algorithms                                       \u2502\n\u2502  \u2717 NO MCP imports                                                      \u2502\n\u2502  \u2717 NO FastMCP dependencies                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#two-layer-architecture","title":"Two-Layer Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           MCP CLIENTS                                   \u2502\n\u2502                  (Claude, other MCP consumers)                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           MCP LAYER                                     \u2502\n\u2502                        src/mcp/                                         \u2502\n\u2502                                                                         \u2502\n\u2502   tools/                          resources/                            \u2502\n\u2502   \u251c\u2500\u2500 match_tools.py              \u251c\u2500\u2500 heroes_resource.py               \u2502\n\u2502   \u251c\u2500\u2500 combat_tools.py             \u251c\u2500\u2500 map_resource.py                  \u2502\n\u2502   \u251c\u2500\u2500 fight_tools.py              \u2514\u2500\u2500 items_resource.py                \u2502\n\u2502   \u251c\u2500\u2500 lane_tools.py                                                    \u2502\n\u2502   \u251c\u2500\u2500 jungle_tools.py             server.py (FastMCP setup)            \u2502\n\u2502   \u251c\u2500\u2500 objective_tools.py                                               \u2502\n\u2502   \u2514\u2500\u2500 timeline_tools.py                                                \u2502\n\u2502                                                                         \u2502\n\u2502   Only MCP-specific code: tool definitions, parameter validation,       \u2502\n\u2502   response formatting. NO business logic.                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 Calls\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         SERVICES LAYER                                  \u2502\n\u2502                        src/services/                                    \u2502\n\u2502                                                                         \u2502\n\u2502   combat/                         cache/                               \u2502\n\u2502   \u251c\u2500\u2500 combat_service.py           \u2514\u2500\u2500 replay_cache.py  (disk cache)    \u2502\n\u2502   \u2514\u2500\u2500 fight_service.py                                                 \u2502\n\u2502                                   replay/                              \u2502\n\u2502   farming/                        \u2514\u2500\u2500 replay_service.py  (main entry)  \u2502\n\u2502   \u2514\u2500\u2500 farming_service.py                                               \u2502\n\u2502                                                                        \u2502\n\u2502   rotation/                       lane/                                \u2502\n\u2502   \u2514\u2500\u2500 rotation_service.py         \u2514\u2500\u2500 lane_service.py                  \u2502\n\u2502                                                                         \u2502\n\u2502   models/                                                              \u2502\n\u2502   \u2514\u2500\u2500 replay_data.py                                                   \u2502\n\u2502                                                                         \u2502\n\u2502   All business logic. Zero MCP dependencies.                            \u2502\n\u2502   Can be imported and used by CLI, web API, tests, etc.                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 Uses\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      EXTERNAL DEPENDENCIES                              \u2502\n\u2502                                                                         \u2502\n\u2502   python-manta v2                 opendota-sdk                          \u2502\n\u2502   \u251c\u2500\u2500 Parser class                \u251c\u2500\u2500 OpenDotaClient                   \u2502\n\u2502   \u251c\u2500\u2500 parse() / run()             \u251c\u2500\u2500 get_match()                      \u2502\n\u2502   \u251c\u2500\u2500 Callbacks                   \u251c\u2500\u2500 get_player()                     \u2502\n\u2502   \u2514\u2500\u2500 seek() (Phase 3)            \u2514\u2500\u2500 get_heroes()                     \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#services-layer","title":"Services Layer","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#core-services","title":"Core Services","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#replayservice","title":"ReplayService","text":"<p>Main entry point for replay data. Handles caching and orchestrates parsing.</p> <pre><code># src/services/replay/replay_service.py\n\nfrom python_manta import Parser\nfrom src.utils.replay_cache import replay_cache\nfrom ..models.replay_data import ParsedReplayData\nfrom .analyzers import FightDetector, LaneAnalyzer, JungleAnalyzer\n\nclass ReplayService:\n    \"\"\"\n    Main service for replay data access.\n    Handles parsing, caching, and analysis orchestration.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def __init__(self, cache: ReplayCache):\n        self._cache = cache\n\n    def get_parsed_data(self, match_id: int) -&gt; ParsedReplayData:\n        \"\"\"\n        Get complete parsed data for a match.\n        Returns cached data if available, otherwise parses replay.\n        \"\"\"\n        # Check cache\n        cached = self._cache.get(match_id)\n        if cached:\n            return cached\n\n        # Download and parse\n        replay_path = self._download_replay(match_id)\n        data = self._parse_replay(replay_path, match_id)\n\n        # Cache and return\n        self._cache.set(match_id, data)\n        return data\n\n    def _parse_replay(self, path: str, match_id: int) -&gt; ParsedReplayData:\n        \"\"\"Single-pass parse using python-manta v2.\"\"\"\n\n        parser = Parser(path)\n\n        # Single parse, all data\n        result = parser.parse(\n            header=True,\n            game_info=True,\n            combat_log={\n                \"types\": [0, 1, 2, 3, 4, 5, 6, 11, 13],\n                \"max\": 100000,\n            },\n            entities={\n                \"interval\": 900,\n                \"classes\": [\"Hero\", \"Building\", \"Creep\", \"NeutralCreep\", \"Ward\"],\n            },\n            game_events=True,\n            modifiers=True,\n        )\n\n        # Run analyzers on raw data\n        fights, kills = FightDetector().analyze(\n            result.combat_log.entries,\n            result.entities.snapshots\n        )\n\n        lane_states, aggro_events = LaneAnalyzer().analyze(\n            result.entities.snapshots,\n            result.combat_log.entries\n        )\n\n        camp_pulls, camp_stacks = JungleAnalyzer().analyze(\n            result.entities.snapshots,\n            result.game_events.events\n        )\n\n        # Build complete data model\n        return ParsedReplayData(\n            match_id=match_id,\n            header=result.header,\n            game_info=result.game_info,\n            combat_log=result.combat_log.entries,\n            entity_snapshots=result.entities.snapshots,\n            game_events=result.game_events.events,\n            modifiers=result.modifiers.events,\n            fights=fights,\n            kills=kills,\n            lane_states=lane_states,\n            creep_aggro_events=aggro_events,\n            camp_pulls=camp_pulls,\n            camp_stacks=camp_stacks,\n        )\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#combatservice","title":"CombatService","text":"<p>Provides combat-related queries from parsed data.</p> <pre><code># src/services/replay/combat_service.py\n\nfrom typing import List, Optional\nfrom ..models.combat import Kill, CombatLogEntry\nfrom ..models.replay_data import ParsedReplayData\n\nclass CombatService:\n    \"\"\"\n    Service for combat data queries.\n    Operates on ParsedReplayData, no direct parsing.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_kills(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n        team: Optional[str] = None,\n    ) -&gt; List[Kill]:\n        \"\"\"Get kills, optionally filtered by hero or team.\"\"\"\n        kills = data.kills\n\n        if hero:\n            kills = [k for k in kills if k.killer == hero or k.victim == hero]\n\n        if team:\n            team_id = 2 if team == \"radiant\" else 3\n            kills = [k for k in kills if k.killer_team == team_id]\n\n        return kills\n\n    def get_hero_deaths(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[Kill]:\n        \"\"\"Get hero deaths.\"\"\"\n        deaths = data.kills\n\n        if hero:\n            deaths = [k for k in deaths if k.victim == hero]\n\n        return deaths\n\n    def get_damage_breakdown(\n        self,\n        data: ParsedReplayData,\n        kill_id: str,\n    ) -&gt; List[CombatLogEntry]:\n        \"\"\"Get damage events leading to a kill.\"\"\"\n        kill = data.get_kill_by_id(kill_id)\n        if not kill:\n            return []\n\n        # Find damage events in window before death\n        window_start = kill.game_time - 10.0\n        window_end = kill.game_time\n\n        return [\n            e for e in data.combat_log\n            if e.type == 0  # DAMAGE\n            and e.target_name == kill.victim\n            and window_start &lt;= e.game_time &lt;= window_end\n        ]\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#fightservice","title":"FightService","text":"<p>Provides fight-related queries.</p> <pre><code># src/services/replay/fight_service.py\n\nfrom typing import List, Optional\nfrom ..models.fights import Fight, Kill\nfrom ..models.replay_data import ParsedReplayData\n\nclass FightService:\n    \"\"\"\n    Service for fight data queries.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def list_fights(self, data: ParsedReplayData) -&gt; List[Fight]:\n        \"\"\"Get all fights in the match.\"\"\"\n        return data.fights\n\n    def get_fight(self, data: ParsedReplayData, fight_id: str) -&gt; Optional[Fight]:\n        \"\"\"Get a specific fight by ID.\"\"\"\n        return data.get_fight_by_id(fight_id)\n\n    def get_fight_kills(self, data: ParsedReplayData, fight_id: str) -&gt; List[Kill]:\n        \"\"\"Get all kills in a specific fight.\"\"\"\n        return data.get_kills_for_fight(fight_id)\n\n    def get_teamfights(self, data: ParsedReplayData, min_kills: int = 3) -&gt; List[Fight]:\n        \"\"\"Get fights with at least min_kills deaths.\"\"\"\n        return [f for f in data.fights if f.radiant_kills + f.dire_kills &gt;= min_kills]\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#laneservice","title":"LaneService","text":"<p>Provides laning phase queries.</p> <pre><code># src/services/replay/lane_service.py\n\nfrom typing import List, Optional\nfrom ..models.lanes import LaneState, CreepAggroEvent\nfrom ..models.replay_data import ParsedReplayData\n\nclass LaneService:\n    \"\"\"\n    Service for laning phase data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_lane_state(\n        self,\n        data: ParsedReplayData,\n        game_time: float,\n        lane: str,\n    ) -&gt; Optional[LaneState]:\n        \"\"\"Get lane state at specific time.\"\"\"\n        return data.get_lane_state_at_time(game_time, lane)\n\n    def get_lane_equilibrium_timeline(\n        self,\n        data: ParsedReplayData,\n        lane: str,\n        start_time: float = 0,\n        end_time: float = 600,  # First 10 minutes\n    ) -&gt; List[LaneState]:\n        \"\"\"Get lane equilibrium over time.\"\"\"\n        return [\n            s for s in data.lane_states\n            if s.lane == lane\n            and start_time &lt;= s.game_time &lt;= end_time\n        ]\n\n    def get_creep_aggro_events(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[CreepAggroEvent]:\n        \"\"\"Get creep aggro manipulation events.\"\"\"\n        events = data.creep_aggro_events\n\n        if hero:\n            events = [e for e in events if e.hero == hero]\n\n        return events\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#jungleservice","title":"JungleService","text":"<p>Provides jungle-related queries.</p> <pre><code># src/services/replay/jungle_service.py\n\nfrom typing import List, Optional\nfrom ..models.jungle import CampPull, CampStack\nfrom ..models.replay_data import ParsedReplayData\n\nclass JungleService:\n    \"\"\"\n    Service for jungle data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_camp_stacks(\n        self,\n        data: ParsedReplayData,\n        team: Optional[str] = None,\n    ) -&gt; List[CampStack]:\n        \"\"\"Get all camp stacks.\"\"\"\n        stacks = data.camp_stacks\n\n        if team:\n            team_id = 2 if team == \"radiant\" else 3\n            stacks = [s for s in stacks if s.stacker_team == team_id]\n\n        return stacks\n\n    def get_camp_pulls(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[CampPull]:\n        \"\"\"Get all camp pulls.\"\"\"\n        pulls = data.camp_pulls\n\n        if hero:\n            pulls = [p for p in pulls if p.puller_hero == hero]\n\n        return pulls\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#analyzers","title":"Analyzers","text":"<p>Analyzers process raw data to detect complex events. They run once during parsing.</p> <pre><code># src/services/analyzers/fight_detector.py\n\nfrom typing import List, Tuple\nfrom ..models.fights import Fight, Kill\nfrom ..models.combat import CombatLogEntry\nfrom ..models.entities import EntitySnapshot\n\nclass FightDetector:\n    \"\"\"\n    Detects and groups fights from combat data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    FIGHT_WINDOW = 15.0  # seconds\n\n    def analyze(\n        self,\n        combat_log: List[CombatLogEntry],\n        entity_snapshots: List[EntitySnapshot],\n    ) -&gt; Tuple[List[Fight], List[Kill]]:\n        \"\"\"\n        Analyze combat log to detect fights.\n\n        Returns:\n            fights: Deduplicated fight objects\n            kills: All kills with fight_id references\n        \"\"\"\n        # Extract hero deaths\n        deaths = [e for e in combat_log if e.type == 4 and self._is_hero(e.target_name)]\n\n        # Group into fights\n        fights = []\n        kills = []\n        current_fight_deaths = []\n\n        for death in sorted(deaths, key=lambda d: d.game_time):\n            if not current_fight_deaths:\n                current_fight_deaths.append(death)\n            elif death.game_time - current_fight_deaths[-1].game_time &lt;= self.FIGHT_WINDOW:\n                current_fight_deaths.append(death)\n            else:\n                # Finalize previous fight\n                fight, fight_kills = self._create_fight(current_fight_deaths, combat_log)\n                fights.append(fight)\n                kills.extend(fight_kills)\n                current_fight_deaths = [death]\n\n        # Handle last fight\n        if current_fight_deaths:\n            fight, fight_kills = self._create_fight(current_fight_deaths, combat_log)\n            fights.append(fight)\n            kills.extend(fight_kills)\n\n        return fights, kills\n</code></pre> <pre><code># src/services/analyzers/lane_analyzer.py\n\nfrom typing import List, Tuple\nfrom ..models.lanes import LaneState, CreepAggroEvent\nfrom ..models.entities import EntitySnapshot\nfrom ..models.combat import CombatLogEntry\n\nclass LaneAnalyzer:\n    \"\"\"\n    Analyzes lane equilibrium and creep manipulation.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def analyze(\n        self,\n        entity_snapshots: List[EntitySnapshot],\n        combat_log: List[CombatLogEntry],\n    ) -&gt; Tuple[List[LaneState], List[CreepAggroEvent]]:\n        \"\"\"\n        Analyze entity snapshots for lane states.\n\n        Returns:\n            lane_states: Lane equilibrium at each snapshot\n            aggro_events: Detected creep aggro manipulation\n        \"\"\"\n        lane_states = []\n        aggro_events = []\n\n        for snapshot in entity_snapshots:\n            # Only analyze laning phase (first 15 minutes)\n            if snapshot.game_time &gt; 900:\n                continue\n\n            for lane in [\"top\", \"mid\", \"bot\"]:\n                state = self._calculate_lane_state(snapshot, lane)\n                lane_states.append(state)\n\n        # Detect aggro manipulation from creep target changes\n        aggro_events = self._detect_aggro_events(entity_snapshots)\n\n        return lane_states, aggro_events\n</code></pre> <pre><code># src/services/analyzers/jungle_analyzer.py\n\nfrom typing import List, Tuple\nfrom ..models.jungle import CampPull, CampStack\nfrom ..models.entities import EntitySnapshot\nfrom ..models.events import GameEvent\n\nclass JungleAnalyzer:\n    \"\"\"\n    Analyzes jungle activity: pulls, stacks.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def analyze(\n        self,\n        entity_snapshots: List[EntitySnapshot],\n        game_events: List[GameEvent],\n    ) -&gt; Tuple[List[CampPull], List[CampStack]]:\n        \"\"\"\n        Analyze jungle activity.\n\n        Returns:\n            pulls: Detected camp pulls\n            stacks: Detected camp stacks\n        \"\"\"\n        # Detection logic depends on what data python-manta v2 provides\n        # May use game events like \"dota_camp_stacked\" if available\n        # Or detect from entity position/state changes\n\n        pulls = self._detect_pulls(entity_snapshots, game_events)\n        stacks = self._detect_stacks(entity_snapshots, game_events)\n\n        return pulls, stacks\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#mcp-layer","title":"MCP Layer","text":"<p>The MCP layer is a thin wrapper. Each tool: 1. Validates MCP parameters 2. Calls the appropriate service 3. Formats the response for MCP</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#tool-definitions","title":"Tool Definitions","text":"<pre><code># src/mcp/tools/combat_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.combat_service import CombatService\n\ndef register_combat_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register combat-related MCP tools.\"\"\"\n\n    combat_service = CombatService()\n\n    @mcp.tool()\n    async def get_hero_deaths(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get hero deaths in a match.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n\n        Returns:\n            List of hero deaths with killer, position, and context\n        \"\"\"\n        # Get parsed data (cached or fresh parse)\n        data = await replay_service.get_parsed_data(match_id)\n\n        # Call service (business logic)\n        deaths = combat_service.get_hero_deaths(data, hero)\n\n        # Format for MCP response\n        return {\n            \"match_id\": match_id,\n            \"count\": len(deaths),\n            \"deaths\": [_format_kill(d) for d in deaths],\n        }\n\n    @mcp.tool()\n    async def get_kills(\n        match_id: int,\n        killer: str | None = None,\n        team: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get kills in a match.\n\n        Args:\n            match_id: The match ID\n            killer: Optional killer hero name\n            team: Optional team filter (\"radiant\" or \"dire\")\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        kills = combat_service.get_kills(data, killer, team)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(kills),\n            \"kills\": [_format_kill(k) for k in kills],\n        }\n\n\ndef _format_kill(kill) -&gt; dict:\n    \"\"\"Format a Kill object for MCP response.\"\"\"\n    return {\n        \"kill_id\": kill.kill_id,\n        \"fight_id\": kill.fight_id,\n        \"game_time\": kill.game_time,\n        \"game_time_str\": _format_time(kill.game_time),\n        \"victim\": kill.victim,\n        \"killer\": kill.killer,\n        \"assisters\": kill.assisters,\n        \"position\": {\"x\": kill.position.x, \"y\": kill.position.y},\n        \"is_teamfight\": kill.is_teamfight_kill,\n    }\n</code></pre> <pre><code># src/mcp/tools/fight_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.fight_service import FightService\n\ndef register_fight_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register fight-related MCP tools.\"\"\"\n\n    fight_service = FightService()\n\n    @mcp.tool()\n    async def list_fights(match_id: int) -&gt; dict:\n        \"\"\"\n        List all fights in a match.\n\n        Args:\n            match_id: The match ID\n\n        Returns:\n            List of fights with participants, outcome, and kill references\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fights = fight_service.list_fights(data)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(fights),\n            \"fights\": [_format_fight_summary(f) for f in fights],\n        }\n\n    @mcp.tool()\n    async def get_fight(match_id: int, fight_id: str) -&gt; dict:\n        \"\"\"\n        Get details of a specific fight.\n\n        Args:\n            match_id: The match ID\n            fight_id: The fight ID (from list_fights)\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fight = fight_service.get_fight(data, fight_id)\n\n        if not fight:\n            return {\"error\": f\"Fight {fight_id} not found\"}\n\n        kills = fight_service.get_fight_kills(data, fight_id)\n\n        return {\n            \"match_id\": match_id,\n            \"fight\": _format_fight_detail(fight),\n            \"kills\": [_format_kill(k) for k in kills],\n        }\n\n    @mcp.tool()\n    async def get_teamfights(match_id: int, min_kills: int = 3) -&gt; dict:\n        \"\"\"\n        Get major teamfights (3+ kills by default).\n\n        Args:\n            match_id: The match ID\n            min_kills: Minimum kills to qualify as teamfight\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fights = fight_service.get_teamfights(data, min_kills)\n\n        return {\n            \"match_id\": match_id,\n            \"min_kills\": min_kills,\n            \"count\": len(fights),\n            \"teamfights\": [_format_fight_summary(f) for f in fights],\n        }\n</code></pre> <pre><code># src/mcp/tools/lane_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.lane_service import LaneService\n\ndef register_lane_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register laning phase MCP tools.\"\"\"\n\n    lane_service = LaneService()\n\n    @mcp.tool()\n    async def get_lane_equilibrium(\n        match_id: int,\n        lane: str,\n        minute: int,\n    ) -&gt; dict:\n        \"\"\"\n        Get lane equilibrium at a specific minute.\n\n        Args:\n            match_id: The match ID\n            lane: Lane name (\"top\", \"mid\", \"bot\")\n            minute: Game minute\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        state = lane_service.get_lane_state(data, minute * 60.0, lane)\n\n        if not state:\n            return {\"error\": f\"No lane data at minute {minute}\"}\n\n        return {\n            \"match_id\": match_id,\n            \"lane\": lane,\n            \"minute\": minute,\n            \"state\": _format_lane_state(state),\n        }\n\n    @mcp.tool()\n    async def get_creep_aggro_events(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get creep aggro manipulation events.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        events = lane_service.get_creep_aggro_events(data, hero)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(events),\n            \"events\": [_format_aggro_event(e) for e in events],\n        }\n</code></pre> <pre><code># src/mcp/tools/jungle_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.jungle_service import JungleService\n\ndef register_jungle_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register jungle MCP tools.\"\"\"\n\n    jungle_service = JungleService()\n\n    @mcp.tool()\n    async def get_camp_stacks(\n        match_id: int,\n        team: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get camp stacking events.\n\n        Args:\n            match_id: The match ID\n            team: Optional team filter (\"radiant\" or \"dire\")\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        stacks = jungle_service.get_camp_stacks(data, team)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(stacks),\n            \"stacks\": [_format_camp_stack(s) for s in stacks],\n        }\n\n    @mcp.tool()\n    async def get_camp_pulls(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get camp pull events.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        pulls = jungle_service.get_camp_pulls(data, hero)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(pulls),\n            \"pulls\": [_format_camp_pull(p) for p in pulls],\n        }\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#mcp-server-setup","title":"MCP Server Setup","text":"<pre><code># src/mcp/server.py\n\nfrom fastmcp import FastMCP\nfrom ..services.replay.replay_service import ReplayService\nfrom ..services.cache.replay_cache import ReplayCache\nfrom .tools.combat_tools import register_combat_tools\nfrom .tools.fight_tools import register_fight_tools\nfrom .tools.lane_tools import register_lane_tools\nfrom .tools.jungle_tools import register_jungle_tools\nfrom .tools.match_tools import register_match_tools\nfrom .tools.objective_tools import register_objective_tools\nfrom .tools.timeline_tools import register_timeline_tools\nfrom .resources.heroes_resource import register_heroes_resources\nfrom .resources.map_resource import register_map_resources\n\ndef create_mcp_server() -&gt; FastMCP:\n    \"\"\"Create and configure the MCP server.\"\"\"\n\n    mcp = FastMCP(\"Dota 2 Match Analysis\")\n\n    # Initialize services (shared across tools)\n    cache = ReplayCache()\n    replay_service = ReplayService(cache)\n\n    # Register all tools\n    register_match_tools(mcp, replay_service)\n    register_combat_tools(mcp, replay_service)\n    register_fight_tools(mcp, replay_service)\n    register_lane_tools(mcp, replay_service)\n    register_jungle_tools(mcp, replay_service)\n    register_objective_tools(mcp, replay_service)\n    register_timeline_tools(mcp, replay_service)\n\n    # Register resources\n    register_heroes_resources(mcp)\n    register_map_resources(mcp)\n\n    return mcp\n\n# Entry point\nmcp = create_mcp_server()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#python-manta-v2-integration","title":"python-manta v2 Integration","text":"<p>The services layer uses python-manta v2's single-pass API:</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#batch-mode-primary","title":"Batch Mode (Primary)","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(replay_path)\n\n# Single parse, all data types\nresult = parser.parse(\n    header=True,\n    game_info=True,\n    combat_log={\n        \"types\": [0, 1, 2, 3, 4, 5, 6, 11, 13],\n        \"max\": 100000,\n    },\n    entities={\n        \"interval\": 900,  # 30-second snapshots\n        \"classes\": [\"Hero\", \"Building\", \"Creep\", \"NeutralCreep\", \"Ward\"],\n    },\n    game_events=True,\n    modifiers=True,\n)\n\n# All data available from single parse\nresult.header.map_name\nresult.game_info.match_id\nresult.combat_log.entries\nresult.entities.snapshots\nresult.game_events.events\nresult.modifiers.events\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#callback-mode-alternative","title":"Callback Mode (Alternative)","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(replay_path)\n\n# Register callbacks\n@parser.on_combat_log\ndef handle_combat(entry):\n    accumulator.add(entry)\n\n@parser.on_entity(class_filter=[\"Hero\", \"Creep\"])\ndef handle_entity(entity, tick):\n    tracker.update(entity, tick)\n\n# Single parse, callbacks fire\nparser.run()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#dense-seek-phase-3","title":"Dense Seek (Phase 3)","text":"<p>For detailed fight analysis:</p> <pre><code># Build index once\nparser = Parser(replay_path)\nparser.build_index()\n\n# Seek to specific range\nparser.seek(tick=45000)\ndense_result = parser.parse(\n    start_tick=45000,\n    end_tick=46000,\n    entities={\"interval\": 1},  # Every tick\n)\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#data-models","title":"Data Models","text":"<p>All models are Pydantic classes in <code>src/services/models/</code>.</p> <pre><code># src/services/models/replay_data.py\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional, Tuple\n\n@dataclass\nclass ParsedReplayData:\n    \"\"\"Complete extraction from a replay file.\"\"\"\n\n    # Metadata\n    match_id: int\n    parse_timestamp: float\n    parser_version: str\n\n    # From python-manta v2\n    header: HeaderInfo\n    game_info: GameInfo\n    combat_log: List[CombatLogEntry]\n    entity_snapshots: List[EntitySnapshot]\n    game_events: List[GameEvent]\n    modifiers: List[ModifierEvent]\n\n    # Indexed data\n    hero_positions: Dict[int, Dict[str, Position]]\n    tick_time_map: List[Tuple[int, float]]\n\n    # Derived data (from analyzers)\n    fights: List[Fight]\n    kills: List[Kill]\n    lane_states: List[LaneState]\n    creep_aggro_events: List[CreepAggroEvent]\n    camp_pulls: List[CampPull]\n    camp_stacks: List[CampStack]\n    objectives: List[ObjectiveEvent]\n    ward_events: List[WardEvent]\n\n    # Indexes for fast lookup\n    _fight_index: Dict[str, Fight] = None\n    _kill_index: Dict[str, Kill] = None\n\n    def get_fight_by_id(self, fight_id: str) -&gt; Optional[Fight]:\n        if self._fight_index is None:\n            self._fight_index = {f.fight_id: f for f in self.fights}\n        return self._fight_index.get(fight_id)\n\n    def get_kill_by_id(self, kill_id: str) -&gt; Optional[Kill]:\n        if self._kill_index is None:\n            self._kill_index = {k.kill_id: k for k in self.kills}\n        return self._kill_index.get(kill_id)\n\n    def get_kills_for_fight(self, fight_id: str) -&gt; List[Kill]:\n        return [k for k in self.kills if k.fight_id == fight_id]\n\n    def get_lane_state_at_time(self, game_time: float, lane: str) -&gt; Optional[LaneState]:\n        # Find nearest snapshot\n        for state in self.lane_states:\n            if state.lane == lane and abs(state.game_time - game_time) &lt; 30:\n                return state\n        return None\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#cache-strategy","title":"Cache Strategy","text":"<pre><code># src/utils/replay_cache.py\n\nfrom pathlib import Path\nfrom diskcache import Cache\nfrom dataclasses import dataclass\n\nclass ReplayCache:\n    \"\"\"\n    Disk-based cache for parsed replay data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    CACHE_DIR = Path.home() / \".cache/mcp_dota2/parsed_replays\"\n    PRIMARY_TTL = 604800  # 7 days\n    SIZE_LIMIT = 5 * 1024**3  # 5 GB\n\n    def __init__(self):\n        self._cache = Cache(\n            directory=str(self.CACHE_DIR),\n            size_limit=self.SIZE_LIMIT,\n        )\n\n    def get(self, match_id: int) -&gt; Optional[ParsedReplayData]:\n        \"\"\"Get cached data if available.\"\"\"\n        key = f\"replay_{match_id}\"\n        data = self._cache.get(key)\n        if data:\n            self._cache.touch(key, expire=self.PRIMARY_TTL)\n            return self._deserialize(data)\n        return None\n\n    def set(self, match_id: int, data: ParsedReplayData) -&gt; None:\n        \"\"\"Cache parsed data.\"\"\"\n        key = f\"replay_{match_id}\"\n        self._cache.set(key, self._serialize(data), expire=self.PRIMARY_TTL)\n\n    def clear_expired(self) -&gt; int:\n        \"\"\"Remove expired entries.\"\"\"\n        return self._cache.expire()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#directory-structure","title":"Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 mcp/                              # MCP Layer (thin wrapper)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 server.py                     # FastMCP setup, tool registration\n\u2502   \u251c\u2500\u2500 tools/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 match_tools.py            # get_match_info, get_draft, etc.\n\u2502   \u2502   \u251c\u2500\u2500 combat_tools.py           # get_kills, get_hero_deaths, etc.\n\u2502   \u2502   \u251c\u2500\u2500 fight_tools.py            # list_fights, get_fight, etc.\n\u2502   \u2502   \u251c\u2500\u2500 lane_tools.py             # get_lane_equilibrium, get_aggro_events\n\u2502   \u2502   \u251c\u2500\u2500 jungle_tools.py           # get_camp_stacks, get_camp_pulls\n\u2502   \u2502   \u251c\u2500\u2500 objective_tools.py        # get_roshan_kills, get_tower_kills\n\u2502   \u2502   \u2514\u2500\u2500 timeline_tools.py         # get_timeline, get_stats_at_minute\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 heroes_resource.py        # Hero data resources\n\u2502       \u2514\u2500\u2500 map_resource.py           # Map data resources\n\u2502\n\u251c\u2500\u2500 utils/                            # Utilities (helpers)\n\u2502   \u251c\u2500\u2500 match_fetcher.py              # OpenDota API fetcher\n\u2502   \u251c\u2500\u2500 timeline_parser.py            # Timeline extraction (uses ParsedReplayData)\n\u2502   \u251c\u2500\u2500 match_info_parser.py          # Match info extraction (uses ParsedReplayData)\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 services/                         # Services Layer (business logic)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 cache/                        # Caching layer\n\u2502   \u2502   \u2514\u2500\u2500 replay_cache.py           # Disk-based replay data cache\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 replay/                       # Replay services\n\u2502   \u2502   \u2514\u2500\u2500 replay_service.py         # Main entry, download + parse + cache\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 combat/                       # Combat services\n\u2502   \u2502   \u251c\u2500\u2500 combat_service.py         # Hero deaths, combat log\n\u2502   \u2502   \u2514\u2500\u2500 fight_service.py          # Fight detection\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 farming/                      # Farming services\n\u2502   \u2502   \u2514\u2500\u2500 farming_service.py        # Farming pattern analysis\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 lane/                         # Lane services\n\u2502   \u2502   \u2514\u2500\u2500 lane_service.py           # Laning phase analysis\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 opendota/                     # OpenDota API services\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 match_service.py          # Match data from API\n\u2502   \u2502   \u251c\u2500\u2500 player_service.py         # Player data\n\u2502   \u2502   \u2514\u2500\u2500 hero_service.py           # Hero metadata\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 analyzers/                    # Post-parse analyzers\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 fight_detector.py         # Fight detection\n\u2502   \u2502   \u251c\u2500\u2500 lane_analyzer.py          # Lane equilibrium\n\u2502   \u2502   \u251c\u2500\u2500 jungle_analyzer.py        # Pulls, stacks\n\u2502   \u2502   \u251c\u2500\u2500 objective_analyzer.py     # Roshan, towers\n\u2502   \u2502   \u2514\u2500\u2500 vision_analyzer.py        # Wards, smokes\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 models/                       # Data models (Pydantic)\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 replay_data.py            # ParsedReplayData\n\u2502       \u251c\u2500\u2500 combat.py                 # CombatLogEntry, DamageSource\n\u2502       \u251c\u2500\u2500 fights.py                 # Fight, Kill\n\u2502       \u251c\u2500\u2500 lanes.py                  # LaneState, CreepAggroEvent\n\u2502       \u251c\u2500\u2500 jungle.py                 # CampPull, CampStack\n\u2502       \u251c\u2500\u2500 objectives.py             # ObjectiveEvent\n\u2502       \u251c\u2500\u2500 vision.py                 # WardEvent, SmokeEvent\n\u2502       \u251c\u2500\u2500 entities.py               # EntitySnapshot, HeroState\n\u2502       \u2514\u2500\u2500 common.py                 # Position, TimeRange, etc.\n\u2502\n\u2514\u2500\u2500 __init__.py\n\n# Entry point\ndota_match_mcp_server.py              # Imports and runs src/mcp/server.py\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP Client calls: get_fight(match_id=123, fight_id=\"fight_45000\")     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP LAYER: src/mcp/tools/fight_tools.py                               \u2502\n\u2502                                                                         \u2502\n\u2502  @mcp.tool()                                                           \u2502\n\u2502  async def get_fight(match_id: int, fight_id: str):                    \u2502\n\u2502      data = await replay_service.get_parsed_data(match_id)  \u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502      fight = fight_service.get_fight(data, fight_id)              \u2502    \u2502\n\u2502      return _format_fight(fight)                                  \u2502    \u2502\n\u2502                                                                   \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2518\n                                                                    \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  SERVICES LAYER: src/services/replay/replay_service.py                 \u2502\n\u2502                                                                         \u2502\n\u2502  def get_parsed_data(match_id):                                        \u2502\n\u2502      # Check cache                                                     \u2502\n\u2502      cached = cache.get(match_id)  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502      if cached: return cached                           \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Parse with python-manta v2 (single pass)         \u2502              \u2502\n\u2502      result = Parser(path).parse(...)                   \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Run analyzers                                    \u2502              \u2502\n\u2502      fights, kills = FightDetector().analyze(...)       \u2502              \u2502\n\u2502      lane_states = LaneAnalyzer().analyze(...)          \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Cache and return                                 \u2502              \u2502\n\u2502      cache.set(match_id, data)                          \u2502              \u2502\n\u2502      return data                                        \u2502              \u2502\n\u2502                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                             \u2502\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                          \u2502                                     \u2502\n                    CACHE HIT                              CACHE MISS\n                          \u2502                                     \u2502\n                          \u25bc                                     \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Return cached    \u2502              \u2502  python-manta v2      \u2502\n              \u2502  ParsedReplayData \u2502              \u2502  Parser(path).parse() \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502  Single-pass parsing  \u2502\n                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#first-parse-complete-data-extraction","title":"First Parse: Complete Data Extraction","text":"<p>During first parse, extract EVERYTHING:</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#raw-data-from-python-manta-v2","title":"Raw Data (from python-manta v2)","text":"<ul> <li>[ ] Header info</li> <li>[ ] Game info (draft, teams, result)</li> <li>[ ] Combat log (all types: damage, heal, death, ability, item, purchase)</li> <li>[ ] Entity snapshots (heroes, buildings, creeps, neutrals, wards)</li> <li>[ ] Game events (all dota_* events)</li> <li>[ ] Modifiers (buffs/debuffs)</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#derived-data-from-analyzers","title":"Derived Data (from analyzers)","text":"<ul> <li>[ ] Fights (grouped, deduplicated)</li> <li>[ ] Kills (with fight references)</li> <li>[ ] Lane states (equilibrium at intervals)</li> <li>[ ] Creep aggro events</li> <li>[ ] Camp pulls</li> <li>[ ] Camp stacks</li> <li>[ ] Objective events (Roshan, towers, barracks)</li> <li>[ ] Ward events</li> <li>[ ] Smoke events</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#indexed-data-for-fast-lookup","title":"Indexed Data (for fast lookup)","text":"<ul> <li>[ ] Hero positions by tick</li> <li>[ ] Tick \u2194 game time mapping</li> <li>[ ] Fight index by ID</li> <li>[ ] Kill index by ID</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#summary","title":"Summary","text":"Layer Location Responsibility Dependencies MCP <code>src/mcp/</code> Tool definitions, parameter validation, response formatting FastMCP, Services Services <code>src/services/</code> Business logic, parsing, caching, analysis python-manta, opendota-sdk Models <code>src/services/models/</code> Data structures (Pydantic) None <p>This separation allows: - Services can be used in CLI tools, web APIs, tests without MCP - MCP layer stays thin and focused on MCP concerns - Easy to add new interfaces (REST API, GraphQL) using same services</p>"},{"location":"changelog/","title":"Changelog","text":"\ud83e\udd16 AI Summary <p>Project changelog following Keep a Changelog format. v1.0.0 release includes: MCP resources (heroes, map, pro scene), 30+ MCP tools for match analysis, replay parsing with python-manta, fight detection with highlights, farming pattern analysis, rotation tracking, pro scene integration with fuzzy search.</p> <p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#120-2025-12-11","title":"[1.2.0] - 2025-12-11","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Position (1-5) assignment for all match tools:</li> <li><code>get_match_heroes</code>, <code>get_match_players</code>, <code>get_match_draft</code> now include <code>position</code> field</li> <li>Position determined from OpenDota lane data (<code>lane_role</code>) and GPM:<ul> <li>Pos 1 = Safelane core (lane_role=1, highest GPM)</li> <li>Pos 2 = Mid (lane_role=2)</li> <li>Pos 3 = Offlane core (lane_role=3, highest GPM)</li> <li>Pos 4 = Soft support (higher GPM support)</li> <li>Pos 5 = Hard support (lowest GPM support)</li> </ul> </li> <li> <p>Fixes LLM incorrectly guessing positions (e.g., Axe as pos5 instead of pos3)</p> </li> <li> <p>Draft context data in <code>get_match_draft</code> picks:</p> </li> <li><code>counters</code>: Heroes that counter this pick (bad matchups)</li> <li><code>good_against</code>: Heroes this pick counters (favorable matchups)</li> <li><code>when_to_pick</code>: Conditions when this hero is strong</li> <li>Helps LLM understand draft decisions and counter-picking</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>assign_roles()</code> renamed to <code>assign_positions()</code> in match_fetcher.py</li> <li><code>DraftAction</code> model now includes <code>position</code>, <code>counters</code>, <code>good_against</code>, <code>when_to_pick</code> fields</li> <li><code>HeroStats</code> and <code>MatchPlayerInfo</code> models now include <code>position</code> field</li> </ul>"},{"location":"changelog/#114-2025-12-11","title":"[1.1.4] - 2025-12-11","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li><code>get_pro_matches</code> tool - Enhanced team filtering with head-to-head support:</li> <li>Renamed <code>team_name</code> parameter to <code>team1_name</code></li> <li>Added <code>team2_name</code> parameter for head-to-head filtering</li> <li>Single team filter (<code>team1_name</code> only): Returns all matches involving that team</li> <li>Head-to-head filter (<code>team1_name</code> + <code>team2_name</code>): Returns only matches where both teams played against each other, regardless of radiant/dire side</li> <li>Combine with <code>league_name</code>, <code>tier</code>, and <code>days_back</code> for deep filtering (e.g., Spirit vs OG at The International)</li> </ul>"},{"location":"changelog/#113-2025-12-10","title":"[1.1.3] - 2025-12-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>ability_filter</code> parameter for focused ability analysis:</li> <li><code>get_raw_combat_events</code>: Filter combat log by specific ability (e.g., \"ice_path\", \"chronosphere\")</li> <li><code>get_hero_performance</code>: Filter ability summary and per-fight abilities by name</li> <li>Case-insensitive partial matching (e.g., \"fissure\" matches \"earthshaker_fissure\")</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Tool renames for clarity (LLM routing improvement):</li> <li><code>get_combat_log</code> \u2192 <code>get_raw_combat_events</code> (emphasizes raw event debugging)</li> <li> <p><code>get_hero_combat_analysis</code> \u2192 <code>get_hero_performance</code> (clearer purpose)</p> </li> <li> <p>Added routing hints to competing tools:</p> </li> <li><code>get_hero_deaths</code>, <code>list_fights</code>, <code>get_teamfights</code>, <code>get_rotation_analysis</code> now include \"NOT FOR HERO PERFORMANCE QUESTIONS \u2192 Use get_hero_performance instead\" in docstrings</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Ability counting now covers entire match - Previously only counted abilities used during detected fights; now counts ALL ability usage across the entire match with per-fight breakdown preserved</li> </ul>"},{"location":"changelog/#112-2025-12-09","title":"[1.1.2] - 2025-12-09","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>detail_level</code> parameter for combat log tools - Controls token usage (~98% reduction with <code>narrative</code>):</li> <li><code>narrative</code> (default): Deaths, abilities, items, purchases, buybacks (~500-2,000 tokens)</li> <li><code>tactical</code>: Adds hero-to-hero damage and debuffs (~2,000-5,000 tokens)</li> <li><code>full</code>: All events including creeps (~50,000+ tokens, debugging only)</li> <li>Applied to <code>get_combat_log</code> and <code>get_fight_combat_log</code> tools</li> <li><code>max_events</code> parameter added (default 500, max 2000) to prevent overflow</li> <li><code>truncated</code> field in response indicates if results were capped</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Removed <code>significant_only</code> parameter - Replaced by <code>detail_level</code> enum for finer control</li> <li>Default behavior now uses <code>narrative</code> detail level (was equivalent to <code>significant_only=True</code>)</li> </ul>"},{"location":"changelog/#111-2025-12-08","title":"[1.1.1] - 2025-12-08","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>get_hero_combat_analysis</code> tool - Per-hero combat performance analysis across all fights:</li> <li>Tracks kills, deaths, assists per fight</li> <li>Ability usage with hit rates (total casts vs hero hits)</li> <li>Damage dealt and received per fight</li> <li>Teamfight vs skirmish classification</li> <li>Ground-targeted ability tracking: Ice Path, Fissure, etc. track hits via MODIFIER_ADD events (stun debuffs applied)</li> <li>Hit rate can exceed 100% for AoE abilities hitting multiple heroes per cast</li> <li>Aggregate stats across all fights for the hero</li> </ul>"},{"location":"changelog/#110-2025-12-08","title":"[1.1.0] - 2025-12-08","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Major refactor: Tools split into domain-specific modules (92% code reduction in main entry point)</li> <li><code>dota_match_mcp_server.py</code>: 2606 \u2192 206 lines</li> <li>New <code>src/tools/</code> directory with modular tool registration:<ul> <li><code>replay_tools.py</code> - Replay download tool</li> <li><code>combat_tools.py</code> - Deaths, combat log, objectives, runes, couriers</li> <li><code>fight_tools.py</code> - Fight detection, teamfights, fight replay</li> <li><code>match_tools.py</code> - Match info, timeline, draft, heroes, positions</li> <li><code>pro_scene_tools.py</code> - Pro players, teams, leagues, matches</li> <li><code>analysis_tools.py</code> - Jungle, lane, farming patterns, rotations</li> </ul> </li> <li>Service injection pattern via <code>register_all_tools(mcp, services)</code> coordinator</li> <li>No functional changes - all 30+ tools work identically</li> </ul>"},{"location":"changelog/#technical","title":"Technical","text":"<ul> <li>Clean separation of concerns: each tool module handles one domain</li> <li>Services dictionary pattern for dependency injection</li> <li>Easier maintenance and testing of individual tool groups</li> </ul>"},{"location":"changelog/#104-2025-12-08","title":"[1.0.4] - 2025-12-08","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Hero counter picks database integrated into <code>/heroes</code> resource:</li> <li>848 counter matchups with mechanical explanations (WHY a hero counters another)</li> <li>438 favorable matchups (heroes each hero is good against)</li> <li>529 \"when_to_pick\" conditions describing optimal draft situations</li> <li> <p>Curated data based on game mechanics: BKB-piercing, silences, roots, mana burn, Blademail, saves, mobility</p> </li> <li> <p>New fields in <code>dota2://heroes/all</code> resource:</p> </li> <li><code>counters</code>: List of heroes that counter this hero with reasons</li> <li><code>good_against</code>: List of heroes this hero counters with reasons</li> <li> <p><code>when_to_pick</code>: Draft conditions when the hero is strong</p> </li> <li> <p>Pydantic models for counter data in <code>src/models/hero_counters.py</code>:</p> </li> <li><code>CounterMatchup</code>, <code>HeroCounters</code>, <code>HeroCountersDatabase</code></li> <li> <p><code>CounterPickResponse</code>, <code>DraftCounterAnalysis</code>, <code>DraftAnalysisResponse</code></p> </li> <li> <p><code>HeroesResource</code> methods for counter data access:</p> </li> <li><code>get_hero_counters(hero_id)</code>: Get counter data for a specific hero</li> <li> <p><code>get_all_hero_counters()</code>: Get all hero counter data</p> </li> <li> <p><code>get_match_heroes</code> tool now includes counter picks for each hero:</p> </li> <li>Enables draft analysis directly from match data</li> <li>Each hero includes counters, good_against, when_to_pick</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li><code>dota2://heroes/all</code> now includes counter picks data for draft analysis</li> <li><code>get_match_heroes</code> enriched with counter picks for draft analysis</li> <li>Updated documentation with counter picks examples</li> </ul>"},{"location":"changelog/#103-2025-12-08","title":"[1.0.3] - 2025-12-08","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Combat-intensity based fight detection - Major refactor of fight detection algorithm:</li> <li>Fights are now detected based on hero-to-hero combat activity, not just deaths</li> <li>Catches teamfights where teams disengage before anyone dies</li> <li>Properly captures fight initiation phase (BKB+Blink) before first death</li> <li>Uses intensity-based windowing to separate distinct engagements</li> <li>Filters out harassment/poke (brief exchanges that aren't real fights)</li> <li> <p>New <code>detect_fights_from_combat()</code> and <code>get_fight_at_time_from_combat()</code> methods</p> </li> <li> <p>Extended fight highlight detection with new patterns:</p> </li> <li>BKB + Blink combos: Detects BKB + Blink \u2192 Big Ability (either order), marks first as initiator, rest as follow-ups</li> <li>Coordinated ultimates: Detects when 2+ heroes from the same team use big teamfight abilities within 3 seconds. Includes <code>team</code> field (radiant/dire)</li> <li>Refresher combos: Detects when a hero uses Refresher to double-cast an ultimate</li> <li>Clutch saves: Detects self-saves (Outworld Staff, Aeon Disk) and ally saves (Glimmer Cape, Lotus Orb, Force Staff, Shadow Demon Disruption)</li> <li> <p>Self-save detection includes tracking what ability the hero was saved FROM (e.g., Omnislash)</p> </li> <li> <p>New data models in <code>combat_data.py</code>:</p> </li> <li><code>BKBBlinkCombo</code>: BKB + Blink combo with <code>is_initiator</code> flag</li> <li><code>CoordinatedUltimates</code>: Multiple heroes ulting together with <code>team</code> field and window tracking</li> <li><code>RefresherCombo</code>: Refresher double ultimate with cast times</li> <li><code>ClutchSave</code>: Save detection with saver, save type, and ability saved from</li> <li> <p><code>CombatWindow</code>: Internal dataclass for combat-intensity based fight detection</p> </li> <li> <p>Added <code>nevermore_requiem</code> alias to BIG_TEAMFIGHT_ABILITIES (replays use old internal name)</p> </li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li><code>get_fight_combat_log</code> now uses combat-based detection by default (captures initiation)</li> <li>Fight detection parameters tuned: 8s combat gap, 3s intensity window, 5 min events per window</li> <li>Removed <code>fight_initiator</code> and <code>initiation_ability</code> fields (replaced by <code>bkb_blink_combos</code> with <code>is_initiator</code> flag)</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Generic AoE detection now properly filters self-targeting (e.g., Echo Slam damaging caster)</li> <li>BKB+Blink detection now accepts either order (BKB\u2192Blink or Blink\u2192BKB)</li> <li>Clutch saves now require target to be \"in danger\" (3+ hero damage hits in 2s) to filter false positives</li> <li>Hero deaths include position coordinates and location descriptions from entity snapshots</li> <li><code>significant_only</code> filter now excludes non-hero deaths (creep kills) from combat events</li> <li>Autoattack kills now show <code>\"ability\": \"attack\"</code> instead of <code>\"dota_unknown\"</code></li> <li>Coordinated ultimates now only detects same-team coordination (was incorrectly grouping opposing team abilities)</li> <li>Team hero extraction now correctly finds all 10 heroes by scanning entity snapshots after game start</li> </ul>"},{"location":"changelog/#102-2025-12-08","title":"[1.0.2] - 2025-12-08","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed <code>get_pro_matches</code> and <code>get_league_matches</code> returning <code>null</code> team names</li> <li>OpenDota API doesn't always include team names in match responses</li> <li>Now resolves team names from cached teams data when missing</li> <li> <p>Eliminates need for extra <code>get_team</code> tool calls to resolve team names</p> </li> <li> <p>Fixed <code>get_match_heroes</code> validation error with item fields</p> </li> <li>Items now return human-readable names (e.g., \"Blink Dagger\") instead of integer IDs</li> <li>Added <code>get_item_name()</code> and <code>convert_item_ids_to_names()</code> to constants_fetcher</li> <li>Neutral items also converted to display names</li> </ul>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Model validation tests (<code>tests/test_model_validation.py</code>)</li> <li>Tests for HeroStats, MatchHeroesResponse, MatchPlayerInfo validation</li> <li>Tests for item ID to name conversion</li> <li>Ensures Pydantic models reject invalid data types</li> </ul>"},{"location":"changelog/#101-2025-12-08","title":"[1.0.1] - 2025-12-08","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Updated examples documentation to match v1.0.0 Pydantic response models</li> <li>Added fight highlights to <code>get_fight_combat_log</code> examples (multi_hero_abilities, kill_streaks, team_wipes)</li> <li>Fixed <code>get_farming_pattern</code> example to use <code>camp_sequence</code> and <code>level_timings</code></li> <li>Added missing standard fields to all tool response examples</li> </ul>"},{"location":"changelog/#100-2025-12-08","title":"[1.0.0] - 2025-12-08","text":""},{"location":"changelog/#added_7","title":"Added","text":""},{"location":"changelog/#mcp-resources","title":"MCP Resources","text":"<ul> <li><code>dota2://heroes/all</code> - All Dota 2 heroes with stats and abilities</li> <li><code>dota2://map</code> - Map geometry with towers, barracks, neutral camps, runes, landmarks</li> <li><code>dota2://pro/players</code> - Pro player database with team affiliations</li> <li><code>dota2://pro/teams</code> - Pro team database with rosters</li> </ul>"},{"location":"changelog/#match-analysis-tools","title":"Match Analysis Tools","text":"<ul> <li><code>download_replay</code> - Pre-cache replay files before analysis (50-400MB files)</li> <li><code>get_hero_deaths</code> - All hero deaths with positions and abilities</li> <li><code>get_combat_log</code> - Raw combat events with time/hero filters</li> <li><code>get_fight_combat_log</code> - Auto-detect fight boundaries with highlights:</li> <li>Multi-hero abilities (Chronosphere, Black Hole, Ravage hitting 2+ heroes)</li> <li>Kill streaks (Double kill through Rampage, 18-second window)</li> <li>Team wipes (Aces)</li> <li>Fight initiation detection</li> <li><code>get_item_purchases</code> - Item purchase timeline</li> <li><code>get_objective_kills</code> - Roshan, tormentors, towers, barracks</li> <li><code>get_match_timeline</code> - Net worth, XP, KDA over time for all players</li> <li><code>get_stats_at_minute</code> - Snapshot of all players at specific minute</li> <li><code>get_courier_kills</code> - Courier snipes with positions</li> <li><code>get_rune_pickups</code> - Rune pickup tracking</li> <li><code>get_match_draft</code> - Complete draft order for Captains Mode</li> <li><code>get_match_info</code> - Match metadata (teams, players, winner, duration)</li> <li><code>get_match_heroes</code> - 10 heroes with KDA, items, stats</li> <li><code>get_match_players</code> - 10 players with names and hero assignments</li> </ul>"},{"location":"changelog/#game-state-tools","title":"Game State Tools","text":"<ul> <li><code>list_fights</code> - All fights with teamfight/skirmish classification</li> <li><code>get_teamfights</code> - Major teamfights (3+ deaths)</li> <li><code>get_fight</code> - Detailed fight information with positions</li> <li><code>get_camp_stacks</code> - Neutral camp stacking events</li> <li><code>get_jungle_summary</code> - Stacking efficiency by hero</li> <li><code>get_lane_summary</code> - Laning phase winners and hero stats (OpenDota integration)</li> <li><code>get_cs_at_minute</code> - CS/gold/level at specific minute</li> <li><code>get_hero_positions</code> - Hero positions at specific minute</li> <li><code>get_snapshot_at_time</code> - High-resolution game state at specific time</li> <li><code>get_position_timeline</code> - Hero movement over time range</li> <li><code>get_fight_replay</code> - High-resolution replay data for fights</li> </ul>"},{"location":"changelog/#farming-rotation-analysis","title":"Farming &amp; Rotation Analysis","text":"<ul> <li><code>get_farming_pattern</code> - Minute-by-minute farming breakdown:</li> <li>Lane vs jungle creeps, camp type identification</li> <li>Position tracking, key transitions (first jungle, left lane)</li> <li>Summary stats: jungle %, GPM, CS/min, camps by type</li> <li><code>get_rotation_analysis</code> - Hero rotation tracking:</li> <li>Rotation detection when heroes leave assigned lane</li> <li>Rune correlation (power runes \u2192 rotations)</li> <li>Fight outcomes: kill, died, traded, fight, no_engagement</li> <li>Power/wisdom rune event tracking</li> </ul>"},{"location":"changelog/#pro-scene-features","title":"Pro Scene Features","text":"<ul> <li><code>search_pro_player</code> / <code>search_team</code> - Fuzzy search with alias support</li> <li><code>get_pro_player</code> / <code>get_pro_player_by_name</code> - Player details</li> <li><code>get_team</code> / <code>get_team_by_name</code> - Team details with roster</li> <li><code>get_team_matches</code> - Recent matches for a team</li> <li><code>get_leagues</code> / <code>get_league_matches</code> - League information</li> <li><code>get_pro_matches</code> - Pro matches with filters (tier, team, league, days_back)</li> <li>Series grouping for Bo1/Bo3/Bo5 detection</li> <li>Player signature heroes and role data</li> </ul>"},{"location":"changelog/#pydantic-response-models","title":"Pydantic Response Models","text":"<ul> <li>40+ typed models with Field descriptions in <code>src/models/tool_responses.py</code></li> <li>Timeline: <code>KDASnapshot</code>, <code>PlayerTimeline</code>, <code>TeamGraphs</code></li> <li>Fights: <code>FightSummary</code>, <code>FightHighlights</code>, <code>MultiHeroAbility</code>, <code>KillStreak</code></li> <li>Game state: <code>HeroSnapshot</code>, <code>HeroPosition</code>, <code>PositionPoint</code></li> <li>Better IDE autocomplete and documentation</li> </ul>"},{"location":"changelog/#developer-experience","title":"Developer Experience","text":"<ul> <li>Comprehensive MkDocs documentation with Material theme</li> <li>AI Summary sections on all documentation pages</li> <li>Parallel-safe tool hints for LLM optimization</li> <li>Server instructions with Dota 2 game knowledge</li> </ul>"},{"location":"changelog/#technical_1","title":"Technical","text":""},{"location":"changelog/#replay-parsing","title":"Replay Parsing","text":"<ul> <li>Single-pass parsing with python-manta v2 API</li> <li><code>ReplayService.get_parsed_data(match_id)</code> as main entry point</li> <li>Disk caching via diskcache for parsed replay data</li> <li>CDOTAMatchMetadataFile extraction for timeline data</li> </ul>"},{"location":"changelog/#architecture","title":"Architecture","text":"<ul> <li>Services layer: <code>CombatService</code>, <code>FightService</code>, <code>FarmingService</code>, <code>RotationService</code></li> <li>Clean separation: services have no MCP dependencies</li> <li>Pydantic models throughout for type safety</li> </ul>"},{"location":"api/resources/","title":"Resources Reference","text":"AI Summary <p>Static reference data via URI. Core: <code>dota2://heroes/all</code> (126 heroes with aliases, counter picks, when_to_pick conditions), <code>dota2://map</code> (towers, camps, runes, landmarks). Pro scene: <code>dota2://pro/players</code>, <code>dota2://pro/teams</code>. Resources are for static data the user attaches to context. For match-specific data, use tools like <code>get_match_heroes</code> and <code>get_match_players</code>.</p> <p>Resources are static reference data that users can attach to their context before a conversation. Access via URI.</p> <p>Resources vs Tools</p> <p>Resources provide static reference data (all heroes, map positions, all pro players). For match-specific data that requires computation, use the corresponding tools:</p> <ul> <li>Match heroes: <code>get_match_heroes(match_id)</code> tool</li> <li>Match players: <code>get_match_players(match_id)</code> tool</li> <li>Pro player details: <code>get_pro_player(account_id)</code> tool</li> <li>Team details: <code>get_team(team_id)</code> tool</li> </ul>"},{"location":"api/resources/#dota2heroesall","title":"dota2://heroes/all","text":"<p>All 126 Dota 2 heroes with counter picks data for draft analysis.</p> <pre><code>{\n  \"npc_dota_hero_antimage\": {\n    \"hero_id\": 1,\n    \"canonical_name\": \"Anti-Mage\",\n    \"aliases\": [\"am\", \"antimage\", \"anti-mage\"],\n    \"attribute\": \"agility\",\n    \"counters\": [\n      {\n        \"hero_id\": 6,\n        \"hero_name\": \"npc_dota_hero_doomguard\",\n        \"localized_name\": \"Doom\",\n        \"reason\": \"Doom silences AM completely, preventing Blink escape and Mana Void\"\n      },\n      {\n        \"hero_id\": 6,\n        \"hero_name\": \"npc_dota_hero_axe\",\n        \"localized_name\": \"Axe\",\n        \"reason\": \"Berserker's Call pierces BKB and forces attacks, Counter Helix punishes\"\n      }\n    ],\n    \"good_against\": [\n      {\n        \"hero_id\": 94,\n        \"hero_name\": \"npc_dota_hero_medusa\",\n        \"localized_name\": \"Medusa\",\n        \"reason\": \"Mana Break devastates Medusa's mana shield; Mana Void deals massive damage\"\n      }\n    ],\n    \"when_to_pick\": [\n      \"Enemy has mana-dependent heroes (Storm, Medusa, Invoker)\",\n      \"Your team can hold 4v5 while you farm\",\n      \"Enemy lacks catch/lockdown for Blink\"\n    ]\n  }\n}\n</code></pre> <p>Counter picks data:</p> <ul> <li><code>counters</code>: Heroes that counter this hero (bad matchups) with mechanical reasons</li> <li><code>good_against</code>: Heroes this hero counters (favorable matchups) with reasons</li> <li><code>when_to_pick</code>: Draft conditions when the hero is strong</li> </ul> <p>Draft Analysis</p> <p>Use counter picks data to analyze draft advantages. Check if enemy picks counter your heroes, or identify good counter-picks for the enemy draft.</p> <p>Use for: Hero name resolution, attribute lookups, draft analysis, counter-pick identification.</p>"},{"location":"api/resources/#dota2map","title":"dota2://map","text":"<p>Full map geometry - towers, camps, runes, landmarks.</p> <pre><code>{\n  \"towers\": [\n    {\"name\": \"radiant_t1_mid\", \"team\": \"radiant\", \"tier\": 1, \"lane\": \"mid\", \"x\": -1544, \"y\": -1408},\n    {\"name\": \"dire_t1_mid\", \"team\": \"dire\", \"tier\": 1, \"lane\": \"mid\", \"x\": 524, \"y\": 652}\n  ],\n  \"barracks\": [\n    {\"name\": \"radiant_melee_mid\", \"team\": \"radiant\", \"lane\": \"mid\", \"type\": \"melee\", \"x\": -4672, \"y\": -4016}\n  ],\n  \"neutral_camps\": [\n    {\"name\": \"radiant_small_camp_1\", \"tier\": \"small\", \"side\": \"radiant\", \"x\": -3200, \"y\": -400}\n  ],\n  \"runes\": [\n    {\"type\": \"power\", \"location\": \"top\", \"x\": -1792, \"y\": 1232},\n    {\"type\": \"bounty\", \"location\": \"radiant_jungle\", \"x\": -4096, \"y\": -1664}\n  ],\n  \"landmarks\": [\n    {\"name\": \"roshan_pit\", \"x\": -2432, \"y\": 2016},\n    {\"name\": \"radiant_ancient\", \"x\": -6144, \"y\": -6016}\n  ]\n}\n</code></pre> <p>Coordinate system: - Center of map \u2248 (0, 0) - Radiant base = bottom-left (negative X, negative Y) - Dire base = top-right (positive X, positive Y) - Range: roughly -8000 to +8000</p> <p>Use for: Understanding death positions, analyzing rotations, tower/rax context.</p>"},{"location":"api/resources/#pro-scene-resources","title":"Pro Scene Resources","text":"<p>Static data about professional Dota 2 players and teams.</p>"},{"location":"api/resources/#dota2proplayers","title":"dota2://pro/players","text":"<p>All professional players from OpenDota.</p> <pre><code>dota2://pro/players\n</code></pre> <pre><code>{\n  \"players\": [\n    {\n      \"account_id\": 311360822,\n      \"name\": \"Yatoro\",\n      \"personaname\": \"Yatoro\",\n      \"team_id\": 8599101,\n      \"team_name\": \"Team Spirit\",\n      \"team_tag\": \"Spirit\",\n      \"country_code\": \"UA\",\n      \"fantasy_role\": 1,\n      \"is_active\": true\n    }\n  ],\n  \"total_players\": 2500\n}\n</code></pre> <p>Use for: Looking up pro player info, finding players by team.</p>"},{"location":"api/resources/#dota2proteams","title":"dota2://pro/teams","text":"<p>All professional teams from OpenDota.</p> <pre><code>dota2://pro/teams\n</code></pre> <pre><code>{\n  \"teams\": [\n    {\n      \"team_id\": 8599101,\n      \"name\": \"Team Spirit\",\n      \"tag\": \"Spirit\",\n      \"rating\": 1500.0,\n      \"wins\": 450,\n      \"losses\": 200\n    }\n  ],\n  \"total_teams\": 500\n}\n</code></pre> <p>Use for: Looking up team info, comparing team ratings.</p> <p>For detailed player/team info</p> <p>Use the <code>get_pro_player(account_id)</code> and <code>get_team(team_id)</code> tools for detailed information including aliases and rosters.</p>"},{"location":"api/tools/","title":"Tools Reference","text":"AI Summary <p>Match Analysis Tools (require <code>match_id</code>): <code>download_replay</code> (call first), <code>get_hero_deaths</code>, <code>get_combat_log</code>, <code>get_fight_combat_log</code>, <code>get_item_purchases</code>, <code>get_objective_kills</code>, <code>get_match_timeline</code>, <code>get_stats_at_minute</code>, <code>get_courier_kills</code>, <code>get_rune_pickups</code>, <code>get_match_draft</code>, <code>get_match_info</code>, <code>get_match_heroes</code>, <code>get_match_players</code>.</p> <p>Game State Tools: <code>list_fights</code>, <code>get_teamfights</code>, <code>get_fight</code>, <code>get_camp_stacks</code>, <code>get_jungle_summary</code>, <code>get_lane_summary</code>, <code>get_cs_at_minute</code>, <code>get_hero_positions</code>, <code>get_snapshot_at_time</code>, <code>get_position_timeline</code>, <code>get_fight_replay</code>.</p> <p>Farming Analysis: <code>get_farming_pattern(hero, start_minute, end_minute)</code> - THE tool for \"how did X farm?\" questions. Returns minute-by-minute lane/neutral kills, camp types, positions, transitions (first jungle, first large camp), and summary stats. Replaces 25+ tool calls with 1 call.</p> <p>Rotation Analysis: <code>get_rotation_analysis(start_minute, end_minute)</code> - THE tool for \"what rotations happened?\" questions. Detects when heroes leave assigned lanes, correlates with rune pickups, links outcomes to fight_ids. Returns rotations, power/wisdom rune events, and per-hero statistics.</p> <p>Pro Scene Tools: <code>search_pro_player(query)</code>, <code>search_team(query)</code>, <code>get_pro_player(account_id)</code>, <code>get_pro_player_by_name(name)</code>, <code>get_team(team_id)</code>, <code>get_team_by_name(name)</code>, <code>get_team_matches(team_id)</code>, <code>get_leagues(tier?)</code>, <code>get_pro_matches(limit?, tier?, team1_name?, team2_name?, league_name?, days_back?)</code>, <code>get_league_matches(league_id)</code>. Head-to-head filtering: pass both <code>team1_name</code> and <code>team2_name</code> to get matches where both teams played against each other.</p> <p>Parallel-safe tools: <code>get_stats_at_minute</code>, <code>get_cs_at_minute</code>, <code>get_hero_positions</code>, <code>get_snapshot_at_time</code>, <code>get_fight</code>, <code>get_position_timeline</code>, <code>get_fight_replay</code> - call multiple times with different parameters in parallel for efficiency.</p> <p>Tools are functions the LLM can call. All match analysis tools take <code>match_id</code> as required parameter.</p>"},{"location":"api/tools/#tool-categories","title":"Tool Categories","text":"Category Description Tools Match Analysis Query match events, deaths, items, timeline 14 tools Pro Scene Search players, teams, leagues, pro matches 10 tools Game State High-resolution positions, snapshots, fights 11 tools Farming &amp; Rotation Farming patterns and rotation analysis 2 tools"},{"location":"api/tools/#parallel-tool-execution","title":"Parallel Tool Execution","text":"<p>Many tools are parallel-safe and can be called simultaneously with different parameters. This significantly speeds up analysis when comparing multiple time points or fights.</p>"},{"location":"api/tools/#parallel-safe-tools","title":"Parallel-Safe Tools","text":"Tool Parallelize By <code>get_stats_at_minute</code> Different minutes (e.g., 10, 20, 30) <code>get_cs_at_minute</code> Different minutes (e.g., 5, 10, 15) <code>get_hero_positions</code> Different minutes <code>get_snapshot_at_time</code> Different game times <code>get_fight</code> Different fight_ids <code>get_position_timeline</code> Different time ranges or heroes <code>get_fight_replay</code> Different fights"},{"location":"api/tools/#example-laning-analysis","title":"Example: Laning Analysis","text":"<p>Instead of calling sequentially: <pre><code># Slow - sequential calls\nget_cs_at_minute(match_id=123, minute=5)\nget_cs_at_minute(match_id=123, minute=10)\n</code></pre></p> <p>Call both in parallel: <pre><code># Fast - parallel calls in same LLM response\nget_cs_at_minute(match_id=123, minute=5)  # AND\nget_cs_at_minute(match_id=123, minute=10)\n</code></pre></p> <p>The LLM can issue multiple tool calls in a single response, and the runtime executes them concurrently.</p>"},{"location":"api/tools/farming-rotation/","title":"Farming &amp; Rotation Tools","text":"<p>High-level analysis tools that aggregate data from multiple sources to answer complex gameplay questions.</p>"},{"location":"api/tools/farming-rotation/#get_farming_pattern","title":"get_farming_pattern","text":"<p>Analyze a hero's farming pattern - creep kills, camp rotations, and map movement.</p> <p>This is THE tool for questions about \"farming pattern\", \"how did X farm\", \"when did they start jungling\", or \"show me the farming movement minute by minute\".</p> <pre><code>get_farming_pattern(\n    match_id=8461956309,\n    hero=\"antimage\",\n    start_minute=0,\n    end_minute=15\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"hero\": \"antimage\",\n  \"start_minute\": 0,\n  \"end_minute\": 15,\n  \"minutes\": [\n    {\n      \"minute\": 5,\n      \"lane_creeps_killed\": 28,\n      \"camps_cleared\": 2,\n      \"camp_sequence\": [\n        {\"time_str\": \"5:12\", \"camp\": \"large_centaur\", \"tier\": \"large\", \"area\": \"radiant_jungle\"},\n        {\"time_str\": \"5:45\", \"camp\": \"medium_wolf\", \"tier\": \"medium\", \"area\": \"radiant_jungle\"}\n      ],\n      \"position_at_start\": {\"x\": -5200, \"y\": -4100, \"area\": \"radiant_safelane\"},\n      \"gold\": 2100,\n      \"level\": 6\n    }\n  ],\n  \"creep_kills\": [\n    {\n      \"game_time\": 312.5,\n      \"game_time_str\": \"5:12\",\n      \"creep_name\": \"npc_dota_neutral_centaur_khan\",\n      \"creep_type\": \"neutral\",\n      \"neutral_camp\": \"large_centaur\",\n      \"camp_tier\": \"large\",\n      \"map_area\": \"radiant_jungle\"\n    }\n  ],\n  \"multi_camp_clears\": [\n    {\n      \"time_str\": \"14:05\",\n      \"camps\": [\"large_centaur\", \"medium_wolf\"],\n      \"duration_seconds\": 1.1,\n      \"creeps_killed\": 4,\n      \"area\": \"dire_jungle\"\n    }\n  ],\n  \"transitions\": {\n    \"first_jungle_kill_str\": \"4:23\",\n    \"first_large_camp_str\": \"5:12\",\n    \"left_lane_str\": \"6:45\"\n  },\n  \"summary\": {\n    \"total_lane_creeps\": 85,\n    \"total_neutral_creeps\": 42,\n    \"jungle_percentage\": 33.1,\n    \"gpm\": 520.0,\n    \"cs_per_min\": 8.5,\n    \"multi_camp_clears\": 3\n  }\n}\n</code></pre></p> <p>Key Fields:</p> Field Description <code>camp_sequence</code> Ordered list of camps cleared each minute <code>creep_kills[].camp_tier</code> Tier from replay parser: <code>small</code>, <code>medium</code>, <code>large</code>, <code>ancient</code> <code>multi_camp_clears</code> Detects when hero farms 2+ camps simultaneously (stacked/adjacent camps) <code>summary.multi_camp_clears</code> Total count of multi-camp clear events <p>Multi-Camp Detection:</p> <p>Detects heroes like Medusa or Luna farming stacked or adjacent camps with AoE abilities. A multi-camp clear is recorded when creeps from 2+ different camp types are killed within 3 seconds.</p> <p>Example Questions This Tool Answers:</p> <ul> <li>\"What was Terrorblade's farming pattern in the first 10 minutes?\"</li> <li>\"When did Anti-Mage start jungling?\"</li> <li>\"Which camps did Luna clear between minutes 5-15?\"</li> <li>\"How did the carry move across the map while farming?\"</li> <li>\"Did Medusa farm stacked camps? How efficiently?\"</li> </ul>"},{"location":"api/tools/farming-rotation/#get_rotation_analysis","title":"get_rotation_analysis","text":"<p>Analyze hero rotations - movement patterns between lanes, rune correlations, and outcomes.</p> <p>This is THE tool for questions about rotations, ganks, mid rotations after rune pickups, or support movements between lanes.</p> <pre><code>get_rotation_analysis(\n    match_id=8461956309,\n    start_minute=0,\n    end_minute=20\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"start_minute\": 0,\n  \"end_minute\": 20,\n  \"rotations\": [\n    {\n      \"rotation_id\": \"rot_1\",\n      \"hero\": \"nevermore\",\n      \"role\": \"mid\",\n      \"game_time\": 365.0,\n      \"game_time_str\": \"6:05\",\n      \"from_lane\": \"mid\",\n      \"to_lane\": \"bot\",\n      \"rune_before\": {\n        \"rune_type\": \"haste\",\n        \"pickup_time\": 362.0,\n        \"pickup_time_str\": \"6:02\",\n        \"seconds_before_rotation\": 3.0\n      },\n      \"outcome\": {\n        \"type\": \"kill\",\n        \"fight_id\": \"fight_3\",\n        \"deaths_in_window\": 1,\n        \"rotation_hero_died\": false,\n        \"kills_by_rotation_hero\": [\"antimage\"]\n      },\n      \"travel_time_seconds\": 45.0,\n      \"returned_to_lane\": true,\n      \"return_time_str\": \"7:30\"\n    }\n  ],\n  \"rune_events\": {\n    \"power_runes\": [\n      {\n        \"spawn_time\": 360.0,\n        \"spawn_time_str\": \"6:00\",\n        \"location\": \"top\",\n        \"taken_by\": \"nevermore\",\n        \"pickup_time\": 362.0,\n        \"led_to_rotation\": true,\n        \"rotation_id\": \"rot_1\"\n      }\n    ],\n    \"wisdom_runes\": [\n      {\n        \"spawn_time\": 420.0,\n        \"spawn_time_str\": \"7:00\",\n        \"location\": \"radiant_jungle\",\n        \"contested\": true,\n        \"fight_id\": \"fight_4\",\n        \"deaths_nearby\": 2\n      }\n    ]\n  },\n  \"summary\": {\n    \"total_rotations\": 8,\n    \"by_hero\": {\n      \"nevermore\": {\n        \"hero\": \"nevermore\",\n        \"role\": \"mid\",\n        \"total_rotations\": 3,\n        \"successful_ganks\": 2,\n        \"failed_ganks\": 0,\n        \"trades\": 1,\n        \"rune_rotations\": 3\n      }\n    },\n    \"runes_leading_to_kills\": 4,\n    \"wisdom_rune_fights\": 2,\n    \"most_active_rotator\": \"nevermore\"\n  }\n}\n</code></pre></p> <p>Key Features:</p> <ul> <li>Rotation Detection: Tracks when heroes leave their assigned lane and go to another lane</li> <li>Rune Correlation: Links power rune pickups (within 60s) to subsequent rotations</li> <li>Fight Outcome: Determines if rotation resulted in kill, death, trade, or no engagement</li> <li>Fight Linking: Provides <code>fight_id</code> - use <code>get_fight(fight_id)</code> for detailed combat log</li> <li>Wisdom Rune Fights: Detects contested wisdom rune spawns with deaths nearby</li> </ul> <p>Outcome Types:</p> Type Description <code>kill</code> Rotating hero got a kill without dying <code>died</code> Rotating hero died without getting a kill <code>traded</code> Rotating hero got a kill but also died <code>fight</code> Rotation led to a fight but no kills by/on rotating hero <code>no_engagement</code> No deaths occurred within 60s of rotation <p>Example Questions This Tool Answers:</p> <ul> <li>\"How many rotations did the mid player make after power runes?\"</li> <li>\"Which rotations resulted in kills vs deaths?\"</li> <li>\"Were there any fights at wisdom rune spawns?\"</li> <li>\"Who was the most active rotator in the early game?\"</li> <li>\"Did the mid rotate after the 6-minute rune?\"</li> </ul>"},{"location":"api/tools/game-state/","title":"Game State Tools","text":"<p>High-resolution game state analysis tools. Many of these are parallel-safe and can be called simultaneously with different parameters.</p>"},{"location":"api/tools/game-state/#list_fights","title":"list_fights","text":"<p>List all fights in a match. Fights are grouped by deaths occurring within 15 seconds of each other.</p> <pre><code>list_fights(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_fights\": 12,\n  \"teamfights\": 5,\n  \"skirmishes\": 7,\n  \"total_deaths\": 45,\n  \"fights\": [\n    {\n      \"fight_id\": \"fight_1\",\n      \"start_time\": \"4:48\",\n      \"total_deaths\": 2,\n      \"participants\": [\"earthshaker\", \"disruptor\"]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_teamfights","title":"get_teamfights","text":"<p>Get only major teamfights (3+ deaths by default).</p> <pre><code>get_teamfights(match_id=8461956309, min_deaths=3)\n</code></pre>"},{"location":"api/tools/game-state/#get_fight","title":"get_fight","text":"<p>Get detailed information about a specific fight. Parallel-safe: call with multiple fight_ids.</p> <pre><code>get_fight(match_id=8461956309, fight_id=\"fight_5\")\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"fight_id\": \"fight_5\",\n  \"start_time\": \"23:15\",\n  \"end_time\": \"23:42\",\n  \"duration_seconds\": 27,\n  \"is_teamfight\": true,\n  \"total_deaths\": 4,\n  \"participants\": [\"medusa\", \"earthshaker\", \"naga_siren\", \"disruptor\", \"pangolier\"],\n  \"deaths\": [\n    {\"game_time\": \"23:18\", \"killer\": \"medusa\", \"victim\": \"earthshaker\", \"ability\": \"medusa_stone_gaze\"}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_camp_stacks","title":"get_camp_stacks","text":"<p>Get all neutral camp stacks in the match.</p> <pre><code>get_camp_stacks(match_id=8461956309, hero_filter=\"crystal_maiden\")\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_stacks\": 8,\n  \"stacks\": [\n    {\"game_time\": \"0:53\", \"stacker\": \"crystal_maiden\", \"camp_type\": \"large\", \"stack_count\": 2}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_jungle_summary","title":"get_jungle_summary","text":"<p>Overview of jungle activity - stacking efficiency by hero.</p> <pre><code>get_jungle_summary(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_stacks\": 15,\n  \"stacks_by_hero\": {\"crystal_maiden\": 5, \"chen\": 4, \"medusa\": 6},\n  \"stack_efficiency_per_10min\": {\"crystal_maiden\": 1.2, \"chen\": 1.0, \"medusa\": 1.5}\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_lane_summary","title":"get_lane_summary","text":"<p>Laning phase analysis (first 10 minutes).</p> <pre><code>get_lane_summary(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"lane_winners\": {\"top\": \"dire\", \"mid\": \"radiant\", \"bot\": \"even\"},\n  \"team_scores\": {\"radiant\": 2.5, \"dire\": 1.5},\n  \"hero_stats\": [\n    {\n      \"hero\": \"antimage\",\n      \"lane\": \"bot\",\n      \"role\": \"core\",\n      \"team\": \"dire\",\n      \"last_hits_5min\": 35,\n      \"last_hits_10min\": 82,\n      \"gold_10min\": 4850,\n      \"level_10min\": 10\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_cs_at_minute","title":"get_cs_at_minute","text":"<p>Get CS, gold, and level for all heroes at a specific minute. Parallel-safe: call for multiple minutes.</p> <pre><code>get_cs_at_minute(match_id=8461956309, minute=10)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"minute\": 10,\n  \"heroes\": [\n    {\"hero\": \"antimage\", \"team\": \"dire\", \"last_hits\": 82, \"denies\": 5, \"gold\": 4850, \"level\": 10}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_hero_positions","title":"get_hero_positions","text":"<p>Get X,Y coordinates for all heroes at a specific minute. Parallel-safe: call for multiple minutes.</p> <pre><code>get_hero_positions(match_id=8461956309, minute=5)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"minute\": 5,\n  \"positions\": [\n    {\"hero\": \"antimage\", \"team\": \"dire\", \"x\": -5200.5, \"y\": -4100.2, \"game_time\": 300}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_snapshot_at_time","title":"get_snapshot_at_time","text":"<p>High-resolution game state at a specific second. Parallel-safe: call for multiple times.</p> <pre><code>get_snapshot_at_time(match_id=8461956309, game_time=300.0)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"tick\": 18000,\n  \"game_time\": 300.0,\n  \"game_time_str\": \"5:00\",\n  \"radiant_gold\": 12500,\n  \"dire_gold\": 11800,\n  \"heroes\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"x\": -5200.5,\n      \"y\": -4100.2,\n      \"health\": 720,\n      \"max_health\": 720,\n      \"mana\": 291,\n      \"max_mana\": 291,\n      \"level\": 7,\n      \"alive\": true\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_position_timeline","title":"get_position_timeline","text":"<p>Hero positions over a time range. Parallel-safe: call for different ranges or heroes.</p> <pre><code>get_position_timeline(\n    match_id=8461956309,\n    start_time=300.0,\n    end_time=360.0,\n    hero_filter=\"antimage\",\n    interval_seconds=1.0\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"heroes\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"positions\": [\n        {\"tick\": 18000, \"game_time\": 300.0, \"x\": -5200.5, \"y\": -4100.2},\n        {\"tick\": 18060, \"game_time\": 301.0, \"x\": -5180.3, \"y\": -4120.1}\n      ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/game-state/#get_fight_replay","title":"get_fight_replay","text":"<p>High-resolution replay data for a fight. Parallel-safe: call for multiple fights.</p> <pre><code>get_fight_replay(\n    match_id=8461956309,\n    start_time=1395.0,\n    end_time=1420.0,\n    interval_seconds=0.5\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"start_time\": 1395.0,\n  \"end_time\": 1420.0,\n  \"total_snapshots\": 50,\n  \"snapshots\": [\n    {\n      \"tick\": 83700,\n      \"game_time\": 1395.0,\n      \"game_time_str\": \"23:15\",\n      \"heroes\": [\n        {\"hero\": \"medusa\", \"team\": \"dire\", \"x\": 1200.5, \"y\": 800.2, \"health\": 2100, \"alive\": true}\n      ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/","title":"Match Analysis Tools","text":"<p>These tools query match events, deaths, items, and timeline data. All require <code>match_id</code> as a parameter.</p>"},{"location":"api/tools/match-analysis/#download_replay","title":"download_replay","text":"<p>Pre-download and cache a replay file. Use this first before asking analysis questions about a new match. Replay files are large (50-400MB) and can take 1-5 minutes to download.</p> <pre><code>download_replay(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"replay_path\": \"/home/user/dota2/replays/8461956309.dem\",\n  \"file_size_mb\": 398.0,\n  \"already_cached\": false\n}\n</code></pre></p> <p>If already cached: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"replay_path\": \"/home/user/dota2/replays/8461956309.dem\",\n  \"file_size_mb\": 398.0,\n  \"already_cached\": true\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_hero_deaths","title":"get_hero_deaths","text":"<p>All hero deaths in the match.</p> <pre><code>get_hero_deaths(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"total_deaths\": 45,\n  \"deaths\": [\n    {\n      \"game_time\": 288,\n      \"game_time_str\": \"4:48\",\n      \"victim\": \"earthshaker\",\n      \"killer\": \"disruptor\",\n      \"killer_is_hero\": true,\n      \"ability\": \"disruptor_thunder_strike\",\n      \"position\": {\"x\": 4200, \"y\": 1800, \"region\": \"dire_safelane\", \"location\": \"Dire safelane near tower\"}\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_hero_performance","title":"get_hero_performance","text":"<p>THE PRIMARY TOOL for analyzing a hero's performance in a match. Use this for ANY question about how a player/hero performed.</p> <p>Use this for:</p> <ul> <li>\"How did Whitemon's Jakiro perform?\"</li> <li>\"What was Collapse's impact on Mars?\"</li> <li>\"How many Ice Paths landed?\"</li> <li>\"Show me Yatoro's fight participation\"</li> </ul> <p>Returns per-fight statistics including kills, deaths, assists, ability usage with hit rates, and damage dealt/received.</p> <pre><code>get_hero_performance(\n    match_id=8461956309,\n    hero=\"earthshaker\"\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"hero\": \"earthshaker\",\n  \"total_fights\": 3,\n  \"total_teamfights\": 1,\n  \"total_kills\": 2,\n  \"total_deaths\": 2,\n  \"total_assists\": 0,\n  \"ability_summary\": [\n    {\"ability\": \"earthshaker_fissure\", \"total_casts\": 3, \"hero_hits\": 6, \"hit_rate\": 200.0},\n    {\"ability\": \"earthshaker_enchant_totem\", \"total_casts\": 3, \"hero_hits\": 2, \"hit_rate\": 66.7},\n    {\"ability\": \"earthshaker_echo_slam\", \"total_casts\": 1, \"hero_hits\": 0, \"hit_rate\": 0.0}\n  ],\n  \"fights\": [\n    {\n      \"fight_id\": \"fight_1\",\n      \"fight_start\": 288.0,\n      \"fight_start_str\": \"4:48\",\n      \"fight_end\": 295.0,\n      \"fight_end_str\": \"4:55\",\n      \"is_teamfight\": false,\n      \"kills\": 0,\n      \"deaths\": 1,\n      \"assists\": 0,\n      \"damage_dealt\": 53,\n      \"damage_received\": 366,\n      \"abilities_used\": [\n        {\"ability\": \"earthshaker_enchant_totem\", \"total_casts\": 1, \"hero_hits\": 0, \"hit_rate\": 0.0}\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>Key fields:</p> Field Description <code>ability_summary</code> Overall ability usage across all fights <code>hero_hits</code> Times ability affected an enemy hero (includes stuns/debuffs from ground-targeted abilities like Ice Path, Fissure) <code>hit_rate</code> Can exceed 100% for AoE abilities that hit multiple heroes per cast <code>fights</code> Per-fight breakdown with K/D/A and ability usage <code>is_teamfight</code> True if the fight had 3+ deaths <p>Ground-Targeted Abilities</p> <p>Abilities like Ice Path, Fissure, and Kinetic Field are tracked via MODIFIER_ADD events (stun debuffs applied to heroes), not just the cast event. This ensures accurate hit detection for ground-targeted CC abilities.</p>"},{"location":"api/tools/match-analysis/#get_raw_combat_events","title":"get_raw_combat_events","text":"<p>Raw combat events for a SPECIFIC TIME WINDOW ONLY.</p> <p>When NOT to use this tool</p> <ul> <li>\"How did X hero perform?\" \u2192 Use <code>get_hero_performance</code></li> <li>\"Show me the fights\" \u2192 Use <code>list_fights</code> or <code>get_teamfights</code></li> <li>\"What happened in the game?\" \u2192 Use <code>get_match_timeline</code></li> </ul> <p>Use this only when you need raw event-by-event details for a specific 30-second to 3-minute window.</p> <pre><code># Default: narrative detail (recommended for most queries)\nget_raw_combat_events(\n    match_id=8461956309,\n    start_time=280,\n    end_time=300,\n    hero_filter=\"earthshaker\"\n)\n\n# Tactical: includes hero-to-hero damage\nget_raw_combat_events(\n    match_id=8461956309,\n    start_time=280,\n    end_time=300,\n    detail_level=\"tactical\"\n)\n\n# Full: all events (WARNING: can overflow context)\nget_raw_combat_events(\n    match_id=8461956309,\n    start_time=280,\n    end_time=290,  # Keep time range SHORT!\n    detail_level=\"full\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>match_id</code> int Required. The match ID <code>start_time</code> float Optional. Filter events after this game time (seconds). Note: Pre-game purchases happen at negative times (~-80s). Use <code>-90</code> to include strategy phase, or omit entirely. <code>start_time=0</code> excludes pre-game. <code>end_time</code> float Optional. Filter events before this game time (seconds) <code>hero_filter</code> string Optional. Only events involving this hero (e.g., \"earthshaker\") <code>detail_level</code> string Controls verbosity: <code>\"narrative\"</code> (default), <code>\"tactical\"</code>, or <code>\"full\"</code>. See below. <code>max_events</code> int Maximum events to return (default 500, max 2000). Prevents overflow. <p>Detail Levels:</p> Level ~Tokens Best For <code>narrative</code> 500-2,000 \"What happened?\" - Deaths, abilities, items, purchases, buybacks <code>tactical</code> 2,000-5,000 \"How much damage?\" - Adds hero-to-hero damage, debuffs on heroes <code>full</code> 50,000+ Debugging only - All events including creeps. \u26a0\ufe0f WARNING: Can overflow context <p>Narrative Mode (default):</p> Included Event Type Description \u2705 <code>ABILITY</code> Hero ability casts \u2705 <code>DEATH</code> Hero deaths only \u2705 <code>ITEM</code> Active item usage \u2705 <code>PURCHASE</code> Item purchases \u2705 <code>BUYBACK</code> Buybacks <p>Tactical Mode (adds):</p> Added Event Type Description \u2795 <code>DAMAGE</code> Hero-to-hero damage only \u2795 <code>MODIFIER_ADD</code> Debuffs applied to heroes <p>Full Mode:</p> Added Event Type Reason to avoid \u2795 All <code>DAMAGE</code> Creep/tower damage creates noise \u2795 All <code>MODIFIER_*</code> Buff/debuff spam \u2795 <code>HEAL</code> Minor heals flood log <p>When to use each level:</p> <ul> <li><code>narrative</code> (default): Fight overview, rotation analysis, item timings</li> <li><code>tactical</code>: Damage breakdown, ability impact analysis</li> <li><code>full</code>: Debugging only, with short time windows (&lt;30s)</li> </ul> <p>Returns: <pre><code>{\n  \"events\": [\n    {\n      \"type\": \"DAMAGE\",\n      \"game_time\": 285,\n      \"game_time_str\": \"4:45\",\n      \"attacker\": \"disruptor\",\n      \"attacker_is_hero\": true,\n      \"target\": \"earthshaker\",\n      \"target_is_hero\": true,\n      \"ability\": \"disruptor_thunder_strike\",\n      \"value\": 160\n    }\n  ]\n}\n</code></pre></p> <p>Event types: <code>DAMAGE</code>, <code>MODIFIER_ADD</code>, <code>MODIFIER_REMOVE</code>, <code>ABILITY</code>, <code>ITEM</code>, <code>DEATH</code>, <code>HEAL</code>, <code>PURCHASE</code>, <code>BUYBACK</code></p>"},{"location":"api/tools/match-analysis/#get_fight_combat_log","title":"get_fight_combat_log","text":"<p>Get combat log for ONE SPECIFIC FIGHT at a known time.</p> <p>When NOT to use this tool</p> <ul> <li>\"How did X hero perform?\" \u2192 Use <code>get_hero_performance</code></li> <li>\"Show me all teamfights\" \u2192 Use <code>get_teamfights</code></li> <li>\"List all fights\" \u2192 Use <code>list_fights</code></li> </ul> <p>Use this when you have a specific death time and want details about that particular fight.</p> <p>Auto-detects fight boundaries around a reference time. Returns combat events plus fight highlights including multi-hero abilities, kill streaks, and team wipes.</p> <pre><code># Default: narrative detail (recommended)\nget_fight_combat_log(\n    match_id=8461956309,\n    reference_time=288,    # e.g., death time from get_hero_deaths\n    hero=\"earthshaker\"     # optional: anchor detection to this hero\n)\n\n# Tactical: for damage analysis\nget_fight_combat_log(\n    match_id=8461956309,\n    reference_time=288,\n    detail_level=\"tactical\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>match_id</code> int Required. The match ID <code>reference_time</code> float Required. Game time in seconds to anchor fight detection (e.g., death time) <code>hero</code> string Optional. Hero name to anchor fight detection <code>detail_level</code> string <code>\"narrative\"</code> (default), <code>\"tactical\"</code>, or <code>\"full\"</code>. Same as <code>get_combat_log</code>. <code>max_events</code> int Maximum events (default 200). Prevents overflow. <p>Returns: <pre><code>{\n  \"fight_start\": 280,\n  \"fight_end\": 295,\n  \"fight_start_str\": \"4:40\",\n  \"fight_end_str\": \"4:55\",\n  \"duration\": 15,\n  \"participants\": [\"earthshaker\", \"disruptor\", \"naga_siren\", \"medusa\"],\n  \"total_events\": 47,\n  \"events\": [...],\n  \"highlights\": {\n    \"multi_hero_abilities\": [\n      {\n        \"game_time\": 282.5,\n        \"game_time_str\": \"4:42\",\n        \"ability\": \"faceless_void_chronosphere\",\n        \"ability_display\": \"Chronosphere\",\n        \"caster\": \"faceless_void\",\n        \"targets\": [\"crystal_maiden\", \"lion\", \"earthshaker\"],\n        \"hero_count\": 3\n      }\n    ],\n    \"kill_streaks\": [\n      {\n        \"game_time\": 290.0,\n        \"game_time_str\": \"4:50\",\n        \"hero\": \"medusa\",\n        \"streak_type\": \"triple_kill\",\n        \"kills\": 3,\n        \"victims\": [\"crystal_maiden\", \"lion\", \"earthshaker\"]\n      }\n    ],\n    \"team_wipes\": [\n      {\n        \"game_time\": 295.0,\n        \"game_time_str\": \"4:55\",\n        \"team_wiped\": \"radiant\",\n        \"killer_team\": \"dire\",\n        \"duration\": 13.0\n      }\n    ],\n    \"bkb_blink_combos\": [\n      {\n        \"game_time\": 282.0,\n        \"game_time_str\": \"4:42\",\n        \"hero\": \"earthshaker\",\n        \"ability\": \"earthshaker_echo_slam\",\n        \"ability_display\": \"Echo Slam\",\n        \"bkb_time\": 281.5,\n        \"blink_time\": 281.8,\n        \"is_initiator\": true\n      }\n    ],\n    \"coordinated_ults\": [\n      {\n        \"game_time\": 282.0,\n        \"game_time_str\": \"4:42\",\n        \"team\": \"radiant\",\n        \"heroes\": [\"earthshaker\", \"nevermore\"],\n        \"abilities\": [\"earthshaker_echo_slam\", \"nevermore_requiem\"],\n        \"window_seconds\": 1.5\n      }\n    ],\n    \"clutch_saves\": [\n      {\n        \"game_time\": 290.0,\n        \"game_time_str\": \"4:50\",\n        \"saved_hero\": \"medusa\",\n        \"save_type\": \"self_banish\",\n        \"save_ability\": \"item_outworld_staff\",\n        \"saved_from\": \"juggernaut_omni_slash\",\n        \"saver\": null\n      }\n    ],\n    \"refresher_combos\": [],\n    \"buybacks\": [],\n    \"generic_aoe_hits\": []\n  }\n}\n</code></pre></p> <p>Highlights Explained:</p> Field Description <code>multi_hero_abilities</code> Big ultimates/abilities hitting 2+ enemy heroes (Chronosphere, Black Hole, Ravage, Ice Path, etc.) <code>kill_streaks</code> Double kill through Rampage (uses Dota 2's 18-second window between kills) <code>team_wipes</code> All 5 heroes of one team killed within the fight (Ace!) <code>bkb_blink_combos</code> BKB + Blink into big ability (classic initiation pattern). <code>is_initiator=true</code> for first combo, <code>false</code> for follow-ups <code>coordinated_ults</code> 2+ heroes from the same team using big abilities within 3 seconds. Includes <code>team</code> field (radiant/dire) <code>clutch_saves</code> Self-saves (Outworld Staff, Euls) or ally saves (Glimmer Cape on teammates under attack) <code>refresher_combos</code> Hero using Refresher to double-cast an ultimate (double Echo Slam, double Ravage, etc.) <code>buybacks</code> Heroes buying back during the fight <code>generic_aoe_hits</code> Any ability hitting 3+ heroes (catches abilities not in the big-ability list) <p>Tracked Abilities (60+): - Ultimates: Chronosphere, Black Hole, Ravage, Reverse Polarity, Echo Slam, Requiem of Souls, etc. - Control: Ice Path, Kinetic Field, Dream Coil, Static Storm, etc. - Team wipe detectors: Tracks all deaths to determine if entire team was killed - Initiation: BKB + Blink combos with is_initiator flag for the first combo</p>"},{"location":"api/tools/match-analysis/#get_item_purchases","title":"get_item_purchases","text":"<p>When items were bought.</p> <pre><code>get_item_purchases(\n    match_id=8461956309,\n    hero_filter=\"antimage\"  # optional\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"purchases\": [\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"hero\": \"antimage\", \"item\": \"item_tango\"},\n    {\"game_time\": 540, \"game_time_str\": \"9:00\", \"hero\": \"antimage\", \"item\": \"item_bfury\"}\n  ]\n}\n</code></pre></p> <p>Negative times = purchased before horn (0:00).</p>"},{"location":"api/tools/match-analysis/#get_objective_kills","title":"get_objective_kills","text":"<p>Roshan, tormentor, towers, barracks.</p> <pre><code>get_objective_kills(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"roshan_kills\": [\n    {\"game_time\": 1392, \"game_time_str\": \"23:12\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 1}\n  ],\n  \"tormentor_kills\": [\n    {\"game_time\": 1215, \"game_time_str\": \"20:15\", \"killer\": \"medusa\", \"team\": \"dire\", \"side\": \"dire\"}\n  ],\n  \"tower_kills\": [\n    {\"game_time\": 669, \"game_time_str\": \"11:09\", \"tower\": \"dire_t1_mid\", \"team\": \"dire\", \"tier\": 1, \"lane\": \"mid\", \"killer\": \"nevermore\"}\n  ],\n  \"barracks_kills\": [\n    {\"game_time\": 2373, \"game_time_str\": \"39:33\", \"barracks\": \"radiant_melee_mid\", \"team\": \"radiant\", \"lane\": \"mid\", \"type\": \"melee\", \"killer\": \"medusa\"}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_match_timeline","title":"get_match_timeline","text":"<p>Net worth, XP, KDA over time for all players.</p> <pre><code>get_match_timeline(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"players\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"net_worth\": [500, 800, 1200, ...],  // every 30 seconds\n      \"hero_damage\": [0, 0, 150, ...],\n      \"kda_timeline\": [\n        {\"game_time\": 0, \"kills\": 0, \"deaths\": 0, \"assists\": 0, \"level\": 1},\n        {\"game_time\": 300, \"kills\": 0, \"deaths\": 0, \"assists\": 0, \"level\": 5}\n      ]\n    }\n  ],\n  \"team_graphs\": {\n    \"radiant_xp\": [0, 1200, 2500, ...],\n    \"dire_xp\": [0, 1100, 2400, ...],\n    \"radiant_gold\": [0, 600, 1300, ...],\n    \"dire_gold\": [0, 650, 1400, ...]\n  }\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_stats_at_minute","title":"get_stats_at_minute","text":"<p>Snapshot of all players at a specific minute. Parallel-safe: call for multiple minutes.</p> <pre><code>get_stats_at_minute(match_id=8461956309, minute=10)\n</code></pre> <p>Returns: <pre><code>{\n  \"minute\": 10,\n  \"players\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"net_worth\": 5420,\n      \"last_hits\": 78,\n      \"denies\": 8,\n      \"kills\": 0,\n      \"deaths\": 0,\n      \"assists\": 0,\n      \"level\": 10,\n      \"hero_damage\": 450\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_courier_kills","title":"get_courier_kills","text":"<p>Courier snipes.</p> <pre><code>get_courier_kills(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"kills\": [\n    {\n      \"game_time\": 420,\n      \"game_time_str\": \"7:00\",\n      \"killer\": \"bounty_hunter\",\n      \"killer_is_hero\": true,\n      \"owner\": \"antimage\",\n      \"team\": \"dire\",\n      \"position\": {\"x\": 2100, \"y\": -1500, \"region\": \"river\", \"location\": \"River near Radiant outpost\"}\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_rune_pickups","title":"get_rune_pickups","text":"<p>All rune pickups in the match.</p> <pre><code>get_rune_pickups(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"pickups\": [\n    {\n      \"game_time\": 0,\n      \"game_time_str\": \"0:00\",\n      \"hero\": \"pangolier\",\n      \"rune_type\": \"bounty\"\n    }\n  ],\n  \"total_pickups\": 42\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_match_draft","title":"get_match_draft","text":"<p>Complete draft with bans and picks in order (for Captains Mode matches). Includes position assignment and drafting context (counters, good matchups, when to pick) for each hero.</p> <pre><code>get_match_draft(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"match_id\": 8461956309,\n  \"game_mode\": 2,\n  \"game_mode_name\": \"Captains Mode\",\n  \"actions\": [\n    {\n      \"order\": 1,\n      \"is_pick\": false,\n      \"team\": \"radiant\",\n      \"hero_id\": 23,\n      \"hero_name\": \"kunkka\",\n      \"localized_name\": \"Kunkka\",\n      \"position\": null,\n      \"counters\": [{\"hero_id\": 6, \"localized_name\": \"Doom\", \"reason\": \"Doom disables all abilities...\"}],\n      \"good_against\": [{\"hero_id\": 32, \"localized_name\": \"Riki\", \"reason\": \"Torrent and X reveal invis...\"}],\n      \"when_to_pick\": [\"Team needs stun setup\", \"Against melee cores\"]\n    },\n    {\n      \"order\": 8,\n      \"is_pick\": true,\n      \"team\": \"dire\",\n      \"hero_id\": 89,\n      \"hero_name\": \"naga_siren\",\n      \"localized_name\": \"Naga Siren\",\n      \"position\": 1,\n      \"counters\": [...],\n      \"good_against\": [...],\n      \"when_to_pick\": [...]\n    }\n  ],\n  \"radiant_picks\": [...],\n  \"radiant_bans\": [...],\n  \"dire_picks\": [...],\n  \"dire_bans\": [...]\n}\n</code></pre></p> <p>Position Field:</p> <ul> <li><code>position</code> is <code>1-5</code> for picks (determined from OpenDota lane data and GPM):</li> <li>1 = Carry (safelane core)</li> <li>2 = Mid</li> <li>3 = Offlane</li> <li>4 = Soft support</li> <li>5 = Hard support</li> <li><code>position</code> is <code>null</code> for bans (hero wasn't picked)</li> </ul> <p>Draft Analysis</p> <p>Use <code>counters</code>, <code>good_against</code>, and <code>when_to_pick</code> fields to analyze draft decisions. The <code>position</code> field tells you which role the hero was played in.</p>"},{"location":"api/tools/match-analysis/#get_match_info","title":"get_match_info","text":"<p>Match metadata including teams, players, winner, duration.</p> <pre><code>get_match_info(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"match_id\": 8461956309,\n  \"is_pro_match\": true,\n  \"league_id\": 18324,\n  \"game_mode\": 2,\n  \"game_mode_name\": \"Captains Mode\",\n  \"winner\": \"dire\",\n  \"duration_seconds\": 4672,\n  \"duration_str\": \"77:52\",\n  \"radiant_team\": {\"team_id\": 8291895, \"team_tag\": \"XG\", \"team_name\": \"XG\"},\n  \"dire_team\": {\"team_id\": 8894818, \"team_tag\": \"FLCN\", \"team_name\": \"FLCN\"},\n  \"players\": [\n    {\"player_name\": \"Ame\", \"hero_name\": \"juggernaut\", \"hero_localized\": \"Juggernaut\", \"team\": \"radiant\", \"steam_id\": 123456}\n  ],\n  \"radiant_players\": [...],\n  \"dire_players\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/match-analysis/#get_match_heroes","title":"get_match_heroes","text":"<p>Get the 10 heroes in a match with detailed stats, position assignment, and counter picks data for draft analysis.</p> <pre><code>get_match_heroes(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"radiant_heroes\": [\n    {\n      \"hero_id\": 1,\n      \"hero_name\": \"antimage\",\n      \"localized_name\": \"Anti-Mage\",\n      \"team\": \"radiant\",\n      \"position\": 1,\n      \"lane\": \"safe_lane\",\n      \"role\": \"core\",\n      \"kills\": 8,\n      \"deaths\": 2,\n      \"assists\": 5,\n      \"last_hits\": 420,\n      \"gpm\": 650,\n      \"xpm\": 580,\n      \"net_worth\": 28500,\n      \"hero_damage\": 15200,\n      \"items\": [\"Manta Style\", \"Battle Fury\", \"Abyssal Blade\"],\n      \"player_name\": \"PlayerOne\",\n      \"pro_name\": \"Yatoro\",\n      \"counters\": [\n        {\"hero_id\": 6, \"localized_name\": \"Doom\", \"reason\": \"Doom silences AM completely...\"}\n      ],\n      \"good_against\": [\n        {\"hero_id\": 94, \"localized_name\": \"Medusa\", \"reason\": \"Mana Break devastates mana shield...\"}\n      ],\n      \"when_to_pick\": [\"Enemy has mana-dependent heroes\", \"Team can hold 4v5\"]\n    }\n  ],\n  \"dire_heroes\": [...]\n}\n</code></pre></p> <p>Position Field:</p> Position Role Lane 1 Carry Safelane core 2 Mid Mid lane 3 Offlane Offlane core 4 Soft support Higher GPM support 5 Hard support Lowest GPM support <p>Draft Analysis</p> <p>Use the <code>counters</code> and <code>good_against</code> fields to analyze draft advantages. The <code>position</code> field tells you which role each hero played (1-5).</p>"},{"location":"api/tools/match-analysis/#get_match_players","title":"get_match_players","text":"<p>Get the 10 players in a match with their hero assignments and position (1-5).</p> <pre><code>get_match_players(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"radiant\": [\n    {\n      \"player_name\": \"PlayerOne\",\n      \"pro_name\": \"Yatoro\",\n      \"account_id\": 311360822,\n      \"hero_id\": 1,\n      \"hero_name\": \"antimage\",\n      \"localized_name\": \"Anti-Mage\",\n      \"position\": 1\n    }\n  ],\n  \"dire\": [...]\n}\n</code></pre></p> <p>The <code>position</code> field indicates the player's role (1=carry, 2=mid, 3=offlane, 4=soft support, 5=hard support) based on lane assignment and farm priority (GPM).</p>"},{"location":"api/tools/pro-scene/","title":"Pro Scene Tools","text":"<p>These tools query professional Dota 2 data from OpenDota.</p>"},{"location":"api/tools/pro-scene/#search_pro_player","title":"search_pro_player","text":"<p>Fuzzy search for pro players by name or alias.</p> <pre><code>search_pro_player(query=\"yatoro\", max_results=5)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"query\": \"yatoro\",\n  \"total_results\": 1,\n  \"results\": [\n    {\"id\": 311360822, \"name\": \"Yatoro\", \"matched_alias\": \"Yatoro\", \"similarity\": 1.0}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#search_team","title":"search_team","text":"<p>Fuzzy search for teams by name or tag.</p> <pre><code>search_team(query=\"spirit\", max_results=5)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"query\": \"spirit\",\n  \"total_results\": 2,\n  \"results\": [\n    {\"id\": 8599101, \"name\": \"Team Spirit\", \"matched_alias\": \"spirit\", \"similarity\": 0.95}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_pro_player","title":"get_pro_player","text":"<p>Get pro player details by account ID.</p> <pre><code>get_pro_player(account_id=311360822)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"player\": {\n    \"account_id\": 311360822,\n    \"name\": \"Yatoro\",\n    \"personaname\": \"Yatoro\",\n    \"team_id\": 8599101,\n    \"team_name\": \"Team Spirit\",\n    \"country_code\": \"UA\",\n    \"fantasy_role\": 1,\n    \"is_active\": true,\n    \"aliases\": [\"yatoro\", \"raddan\"]\n  }\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_pro_player_by_name","title":"get_pro_player_by_name","text":"<p>Get pro player details by name (uses fuzzy search).</p> <pre><code>get_pro_player_by_name(name=\"Yatoro\")\n</code></pre>"},{"location":"api/tools/pro-scene/#get_team","title":"get_team","text":"<p>Get team details by team ID.</p> <pre><code>get_team(team_id=8599101)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"team\": {\n    \"team_id\": 8599101,\n    \"name\": \"Team Spirit\",\n    \"tag\": \"Spirit\",\n    \"rating\": 1500.0,\n    \"wins\": 450,\n    \"losses\": 200,\n    \"aliases\": [\"ts\", \"spirit\"]\n  },\n  \"roster\": [\n    {\"account_id\": 311360822, \"player_name\": \"Yatoro\", \"games_played\": 300, \"wins\": 200, \"is_current\": true}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_team_by_name","title":"get_team_by_name","text":"<p>Get team details by name (uses fuzzy search).</p> <pre><code>get_team_by_name(name=\"Team Spirit\")\n</code></pre>"},{"location":"api/tools/pro-scene/#get_team_matches","title":"get_team_matches","text":"<p>Get recent matches for a team with series grouping.</p> <pre><code>get_team_matches(team_id=8599101, limit=20)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"team_id\": 8599101,\n  \"team_name\": \"Team Spirit\",\n  \"total_matches\": 20,\n  \"series\": [\n    {\n      \"series_id\": 123,\n      \"series_type\": \"bo3\",\n      \"games_in_series\": 2,\n      \"wins_needed\": 2,\n      \"radiant_team_id\": 8599101,\n      \"dire_team_id\": 7391077,\n      \"winner_team_id\": 8599101,\n      \"league_name\": \"ESL One\"\n    }\n  ],\n  \"matches\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_leagues","title":"get_leagues","text":"<p>Get all leagues/tournaments, optionally filtered by tier.</p> <pre><code>get_leagues(tier=\"premium\")  # \"premium\", \"professional\", \"amateur\", or None for all\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_leagues\": 15,\n  \"leagues\": [\n    {\"league_id\": 15728, \"name\": \"The International 2023\", \"tier\": \"premium\"}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_pro_matches","title":"get_pro_matches","text":"<p>Get recent professional matches with series grouping. By default returns ALL matches including low-tier leagues - use filters to narrow down results.</p> <p>Parameters:</p> Parameter Type Description <code>limit</code> int Maximum matches to return (default: 100) <code>tier</code> string Filter by league tier: <code>\"premium\"</code> (TI, Majors), <code>\"professional\"</code>, or <code>\"amateur\"</code> <code>team1_name</code> string Filter by first team (fuzzy match). Alone: returns all matches for that team <code>team2_name</code> string Filter by second team (fuzzy match). With team1: returns head-to-head matches <code>league_name</code> string Contains match on league name (e.g., \"SLAM\", \"ESL\", \"DreamLeague\") <code>days_back</code> int Only return matches from the last N days <p>Team Filtering:</p> <ul> <li>Single team (<code>team1_name</code> only): Returns all matches involving that team (either radiant or dire)</li> <li>Head-to-head (<code>team1_name</code> + <code>team2_name</code>): Returns only matches where both teams played against each other, regardless of which side (radiant/dire) they were on</li> </ul> <p>Data Blending: When team filters are provided, this tool automatically blends data from two sources:</p> <ol> <li>Team-specific endpoint (<code>/teams/{id}/matches</code>) - captures matches that OpenDota's <code>/proMatches</code> often misses (e.g., major tournaments like SLAM)</li> <li>General pro matches (<code>/proMatches</code>) - provides broader coverage</li> </ol> <p>This ensures comprehensive results when searching for specific teams.</p> <pre><code># Get top-tier tournament matches only\nget_pro_matches(tier=\"premium\")\n\n# Find all matches for a specific team\nget_pro_matches(team1_name=\"Tundra\", days_back=7)\n\n# Find head-to-head matches between two teams\nget_pro_matches(team1_name=\"Team Spirit\", team2_name=\"OG\")\n\n# Head-to-head at a specific tournament\nget_pro_matches(team1_name=\"Spirit\", team2_name=\"OG\", league_name=\"International\")\n\n# Find matches in a specific tournament\nget_pro_matches(league_name=\"SLAM\")\n\n# Combine filters: team matches at premium tournaments\nget_pro_matches(tier=\"premium\", team1_name=\"Team Spirit\", days_back=30)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_matches\": 100,\n  \"series\": [...],\n  \"matches\": [\n    {\n      \"match_id\": 8461956309,\n      \"radiant_team_id\": 8291895,\n      \"radiant_team_name\": \"XG\",\n      \"dire_team_id\": 8894818,\n      \"dire_team_name\": \"FLCN\",\n      \"radiant_win\": false,\n      \"duration\": 4672,\n      \"league_name\": \"Elite League\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/pro-scene/#get_league_matches","title":"get_league_matches","text":"<p>Get matches from a specific league with series grouping.</p> <pre><code>get_league_matches(league_id=15728, limit=50)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"league_id\": 15728,\n  \"league_name\": \"The International 2023\",\n  \"total_matches\": 50,\n  \"series\": [...],\n  \"matches\": [...]\n}\n</code></pre></p>"},{"location":"examples/use-cases/","title":"Real Use Cases","text":"\ud83e\udd16 AI Summary <p>Example LLM conversations showing tool usage with realistic JSON responses. Lost teamfight - <code>get_hero_deaths</code> \u2192 <code>get_fight_combat_log</code> with highlights (multi-hero abilities, kill streaks, team wipes, fight initiator). Carry farm tracking - <code>get_item_purchases</code> \u2192 <code>get_stats_at_minute</code>. Farming pattern - <code>get_farming_pattern</code> \u2192 <code>camp_sequence</code>, <code>level_timings</code>, <code>item_timings</code>, position tracking. Rotation analysis - <code>get_rotation_analysis</code> \u2192 rune-rotation correlation, outcomes. Gank analysis - death positions \u2192 fight highlights \u2192 initiator detection. Roshan control - <code>get_objective_kills</code> \u2192 full objective timeline. Laning comparison - <code>get_stats_at_minute(10)</code> \u2192 net worth, hero damage, KDA, level.</p> <p>These are example conversations showing how an LLM uses the MCP tools to analyze matches.</p>"},{"location":"examples/use-cases/#analyzing-a-lost-teamfight","title":"Analyzing a Lost Teamfight","text":"<p>User: \"In match 8461956309, we lost a big fight around 25 minutes. What went wrong?\"</p> <p>LLM thinks: I need to find deaths around minute 25 and analyze the fight.</p> <p>LLM calls: <code>get_hero_deaths(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"total_deaths\": 45,\n  \"deaths\": [\n    {\"game_time\": 1487, \"game_time_str\": \"24:47\", \"victim\": \"pangolier\", \"killer\": \"medusa\", \"killer_is_hero\": true, \"ability\": \"medusa_split_shot\"},\n    {\"game_time\": 1492, \"game_time_str\": \"24:52\", \"victim\": \"earthshaker\", \"killer\": \"disruptor\", \"killer_is_hero\": true, \"ability\": \"disruptor_static_storm\"},\n    {\"game_time\": 1495, \"game_time_str\": \"24:55\", \"victim\": \"nevermore\", \"killer\": \"naga_siren\", \"killer_is_hero\": true, \"ability\": \"naga_siren_rip_tide\"},\n    {\"game_time\": 1498, \"game_time_str\": \"24:58\", \"victim\": \"dawnbreaker\", \"killer\": \"medusa\", \"killer_is_hero\": true, \"ability\": \"medusa_mystic_snake\"}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_fight_combat_log(match_id=8461956309, reference_time=1492, hero=\"earthshaker\")</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"fight_start\": 1480,\n  \"fight_start_str\": \"24:40\",\n  \"fight_end\": 1502,\n  \"fight_end_str\": \"25:02\",\n  \"duration\": 22,\n  \"participants\": [\"pangolier\", \"earthshaker\", \"nevermore\", \"dawnbreaker\", \"medusa\", \"disruptor\", \"naga_siren\", \"luna\", \"necrophos\"],\n  \"total_events\": 47,\n  \"events\": [\n    {\"type\": \"ABILITY\", \"game_time\": 1481, \"game_time_str\": \"24:41\", \"attacker\": \"earthshaker\", \"attacker_is_hero\": true, \"target\": \"medusa\", \"target_is_hero\": true, \"ability\": \"earthshaker_echo_slam\"},\n    {\"type\": \"DAMAGE\", \"game_time\": 1481, \"game_time_str\": \"24:41\", \"attacker\": \"earthshaker\", \"attacker_is_hero\": true, \"target\": \"medusa\", \"target_is_hero\": true, \"ability\": \"earthshaker_echo_slam\", \"value\": 287},\n    {\"type\": \"MODIFIER_ADD\", \"game_time\": 1482, \"game_time_str\": \"24:42\", \"attacker\": \"disruptor\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true, \"ability\": \"disruptor_static_storm\"},\n    {\"type\": \"DAMAGE\", \"game_time\": 1485, \"game_time_str\": \"24:45\", \"attacker\": \"medusa\", \"attacker_is_hero\": true, \"target\": \"pangolier\", \"target_is_hero\": true, \"ability\": \"medusa_split_shot\", \"value\": 412}\n  ],\n  \"highlights\": {\n    \"multi_hero_abilities\": [\n      {\n        \"game_time\": 1481.0,\n        \"game_time_str\": \"24:41\",\n        \"ability\": \"earthshaker_echo_slam\",\n        \"ability_display\": \"Echo Slam\",\n        \"caster\": \"earthshaker\",\n        \"targets\": [\"medusa\", \"disruptor\", \"naga_siren\", \"luna\", \"necrophos\"],\n        \"hero_count\": 5\n      }\n    ],\n    \"kill_streaks\": [\n      {\n        \"game_time\": 1498.0,\n        \"game_time_str\": \"24:58\",\n        \"hero\": \"medusa\",\n        \"streak_type\": \"triple_kill\",\n        \"kills\": 3,\n        \"victims\": [\"pangolier\", \"nevermore\", \"dawnbreaker\"]\n      }\n    ],\n    \"team_wipes\": [],\n    \"fight_initiator\": \"earthshaker\",\n    \"initiation_ability\": \"Echo Slam\"\n  }\n}\n</code></pre></p> <p>LLM responds:</p> <p>The fight at 24:40 was a disaster for Radiant. Here's the breakdown from the highlights:</p> <p>The Initiation: - Earthshaker initiated with Echo Slam at 24:41, hitting all 5 Dire heroes (Medusa, Disruptor, Naga, Luna, Necrophos) - Despite hitting 5 targets, the damage was underwhelming (287 on Medusa) - likely low Aftershock stacks</p> <p>What Went Wrong: 1. Disruptor immediately countered with Static Storm on Earthshaker at 24:42, silencing him before any follow-up 2. Medusa cleaned house - achieved a Triple Kill on Pangolier, Nevermore, and Dawnbreaker 3. 22-second fight with 4 Radiant deaths</p> <p>The Issue: The Echo Slam was mechanically good (5 heroes hit!) but strategically bad: - No BKB against Disruptor Static Storm - Radiant had no follow-up damage after ES was silenced - Medusa tanked the initiation and turned the fight with Split Shot</p>"},{"location":"examples/use-cases/#tracking-carry-farm","title":"Tracking Carry Farm","text":"<p>User: \"How did their Anti-Mage get Battle Fury so fast in match 8461956309?\"</p> <p>LLM calls: <code>get_item_purchases(match_id=8461956309, hero_filter=\"antimage\")</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"hero_filter\": \"antimage\",\n  \"total_purchases\": 7,\n  \"purchases\": [\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"hero\": \"antimage\", \"item\": \"item_tango\"},\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"hero\": \"antimage\", \"item\": \"item_quelling_blade\"},\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"hero\": \"antimage\", \"item\": \"item_slippers\"},\n    {\"game_time\": 180, \"game_time_str\": \"3:00\", \"hero\": \"antimage\", \"item\": \"item_ring_of_health\"},\n    {\"game_time\": 420, \"game_time_str\": \"7:00\", \"hero\": \"antimage\", \"item\": \"item_boots\"},\n    {\"game_time\": 540, \"game_time_str\": \"9:00\", \"hero\": \"antimage\", \"item\": \"item_bfury\"},\n    {\"game_time\": 780, \"game_time_str\": \"13:00\", \"hero\": \"antimage\", \"item\": \"item_manta\"}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_stats_at_minute(match_id=8461956309, minute=9)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"minute\": 9,\n  \"players\": [\n    {\"hero\": \"antimage\", \"team\": \"dire\", \"net_worth\": 5420, \"hero_damage\": 450, \"kills\": 0, \"deaths\": 0, \"assists\": 0, \"level\": 10},\n    {\"hero\": \"nevermore\", \"team\": \"radiant\", \"net_worth\": 4100, \"hero_damage\": 1200, \"kills\": 1, \"deaths\": 1, \"assists\": 0, \"level\": 9}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Anti-Mage got a 9-minute Battle Fury, which is quite fast. Here's how:</p> <ul> <li>78 last hits by minute 9 - excellent lane farming</li> <li>0 deaths - completely free lane, no pressure</li> <li>Ring of Health at 3:00 - sustain let him stay in lane indefinitely</li> </ul> <p>Compare to Nevermore mid who had 62 CS but died once - that death probably cost 300-400 gold and 30 seconds of farm.</p> <p>The real question is why Radiant's offlane didn't pressure AM. A 9-minute BFury usually means the safelane was uncontested.</p>"},{"location":"examples/use-cases/#understanding-a-gank","title":"Understanding a Gank","text":"<p>User: \"I was playing Earthshaker and got killed at first blood. What could I have done differently?\"</p> <p>LLM calls: <code>get_hero_deaths(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"total_deaths\": 45,\n  \"deaths\": [\n    {\"game_time\": 288, \"game_time_str\": \"4:48\", \"victim\": \"earthshaker\", \"killer\": \"disruptor\", \"killer_is_hero\": true, \"ability\": \"disruptor_thunder_strike\", \"position\": {\"x\": 4200, \"y\": 1800, \"region\": \"dire_safelane\", \"location\": \"Dire safelane near tower\"}}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_fight_combat_log(match_id=8461956309, reference_time=288, hero=\"earthshaker\")</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"hero\": \"earthshaker\",\n  \"fight_start\": 280,\n  \"fight_start_str\": \"4:40\",\n  \"fight_end\": 290,\n  \"fight_end_str\": \"4:50\",\n  \"duration\": 10,\n  \"participants\": [\"earthshaker\", \"disruptor\", \"naga_siren\", \"medusa\"],\n  \"total_events\": 12,\n  \"events\": [\n    {\"type\": \"MODIFIER_ADD\", \"game_time\": 281, \"game_time_str\": \"4:41\", \"attacker\": \"naga_siren\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true, \"ability\": \"naga_siren_ensnare\"},\n    {\"type\": \"DAMAGE\", \"game_time\": 282, \"game_time_str\": \"4:42\", \"attacker\": \"disruptor\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true, \"ability\": \"disruptor_thunder_strike\", \"value\": 160},\n    {\"type\": \"DAMAGE\", \"game_time\": 284, \"game_time_str\": \"4:44\", \"attacker\": \"medusa\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true, \"ability\": \"medusa_mystic_snake\", \"value\": 140},\n    {\"type\": \"DAMAGE\", \"game_time\": 286, \"game_time_str\": \"4:46\", \"attacker\": \"naga_siren\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true, \"value\": 58},\n    {\"type\": \"DEATH\", \"game_time\": 288, \"game_time_str\": \"4:48\", \"attacker\": \"disruptor\", \"attacker_is_hero\": true, \"target\": \"earthshaker\", \"target_is_hero\": true}\n  ],\n  \"highlights\": {\n    \"multi_hero_abilities\": [],\n    \"kill_streaks\": [],\n    \"team_wipes\": [],\n    \"fight_initiator\": \"naga_siren\",\n    \"initiation_ability\": \"Ensnare\"\n  }\n}\n</code></pre></p> <p>LLM responds:</p> <p>Here's what happened at first blood (4:48):</p> <p>Fight Summary: - Duration: 10 seconds (4:40 - 4:50) - Initiator: Naga Siren with Ensnare (detected automatically in highlights) - Participants: 3v1 gank (Naga, Disruptor, Medusa vs Earthshaker)</p> <p>Kill Timeline: 1. 4:41 - Naga Siren lands Ensnare (3-second root) 2. 4:42 - Disruptor Thunder Strike (160 damage over time) 3. 4:44 - Medusa Mystic Snake (140 damage) 4. 4:46 - Naga right-click (58 damage) 5. 4:48 - Death</p> <p>Position: x:4200, y:1800 - deep in Dire safelane near their tower.</p> <p>What went wrong: You were caught in a 3v1 without escape. Once Naga lands Ensnare, you have no mobility and they chain their damage perfectly.</p> <p>What to do differently: - Stay near trees for juke paths against Naga - Track enemy positions before contesting pulls - ES needs level 6 to threaten this trilane - play for XP until then</p>"},{"location":"examples/use-cases/#objective-control-analysis","title":"Objective Control Analysis","text":"<p>User: \"When did Roshan die and who took the Aegis?\"</p> <p>LLM calls: <code>get_objective_kills(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"roshan_kills\": [\n    {\"game_time\": 1392, \"game_time_str\": \"23:12\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 1},\n    {\"game_time\": 2040, \"game_time_str\": \"34:00\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 2},\n    {\"game_time\": 2580, \"game_time_str\": \"43:00\", \"killer\": \"luna\", \"team\": \"dire\", \"kill_number\": 3},\n    {\"game_time\": 3120, \"game_time_str\": \"52:00\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 4}\n  ],\n  \"tormentor_kills\": [],\n  \"tower_kills\": [\n    {\"game_time\": 669, \"game_time_str\": \"11:09\", \"tower\": \"dire_t1_mid\", \"team\": \"dire\", \"tier\": 1, \"lane\": \"mid\", \"killer\": \"nevermore\", \"killer_is_hero\": true},\n    {\"game_time\": 1440, \"game_time_str\": \"24:00\", \"tower\": \"radiant_t1_bot\", \"team\": \"radiant\", \"tier\": 1, \"lane\": \"bot\", \"killer\": \"medusa\", \"killer_is_hero\": true}\n  ],\n  \"barracks_kills\": []\n}\n</code></pre></p> <p>LLM responds:</p> <p>Roshan Timeline:</p> Rosh # Time Killer Team 1 23:12 Medusa Dire 2 34:00 Medusa Dire 3 43:00 Luna Dire 4 52:00 Medusa Dire <p>Dire took all 4 Roshans. Medusa got 3 of them personally - she was likely the Aegis carrier for most of the game.</p> <p>This is a big factor in why the game went late - Medusa with Aegis is extremely hard to kill, and Dire maintained complete Roshan control throughout.</p>"},{"location":"examples/use-cases/#comparing-laning-phase","title":"Comparing Laning Phase","text":"<p>User: \"Compare the midlaners at 10 minutes\"</p> <p>LLM calls: <code>get_stats_at_minute(match_id=8461956309, minute=10)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"minute\": 10,\n  \"players\": [\n    {\"hero\": \"nevermore\", \"team\": \"radiant\", \"net_worth\": 4800, \"hero_damage\": 2100, \"kills\": 2, \"deaths\": 0, \"assists\": 1, \"level\": 11},\n    {\"hero\": \"pangolier\", \"team\": \"dire\", \"net_worth\": 3200, \"hero_damage\": 1400, \"kills\": 0, \"deaths\": 1, \"assists\": 0, \"level\": 9}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Mid Lane at 10:00 - Nevermore vs Pangolier:</p> Stat Nevermore (Radiant) Pangolier (Dire) Net Worth 4,800 3,200 Hero Damage 2,100 1,400 K/D/A 2/0/1 0/1/0 Level 11 9 <p>Nevermore dominated the lane: - +1,600 net worth advantage (50% more gold) - +700 hero damage dealt - SF was more aggressive - +2 levels (level 11 vs 9) - 2 kills, 0 deaths vs 0/1 for Pango</p> <p>Shadow Fiend's early damage from Necromastery stacks and Raze harass let him win trades. The 2 kills suggest SF was rotating or getting ganks, while Pango's death cost him farm time.</p>"},{"location":"examples/use-cases/#analyzing-carry-farming-pattern","title":"Analyzing Carry Farming Pattern","text":"<p>User: \"What was Anti-Mage's farming pattern in the first 10 minutes? When did he start jungling?\"</p> <p>LLM calls: <code>get_farming_pattern(match_id=8461956309, hero=\"antimage\", start_minute=0, end_minute=10)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"hero\": \"antimage\",\n  \"start_minute\": 0,\n  \"end_minute\": 10,\n  \"level_timings\": [\n    {\"level\": 6, \"time\": 420.0, \"time_str\": \"7:00\"},\n    {\"level\": 10, \"time\": 600.0, \"time_str\": \"10:00\"}\n  ],\n  \"item_timings\": [\n    {\"item\": \"ring_of_health\", \"time\": 180.0, \"time_str\": \"3:00\"},\n    {\"item\": \"bfury\", \"time\": 540.0, \"time_str\": \"9:00\"}\n  ],\n  \"minutes\": [\n    {\n      \"minute\": 5,\n      \"position_at_start\": {\"x\": 5800, \"y\": 3200, \"area\": \"dire_safelane\"},\n      \"position_at_end\": {\"x\": 6200, \"y\": 4800, \"area\": \"dire_jungle\"},\n      \"camp_sequence\": [\n        {\"time_str\": \"5:15\", \"camp\": \"medium_wolf\", \"tier\": \"medium\", \"area\": \"dire_jungle\"},\n        {\"time_str\": \"5:42\", \"camp\": \"small_kobold\", \"tier\": \"small\", \"area\": \"dire_jungle\"}\n      ],\n      \"lane_creeps_killed\": 5,\n      \"camps_cleared\": 2,\n      \"gold\": 1580,\n      \"last_hits\": 33,\n      \"level\": 5\n    },\n    {\n      \"minute\": 6,\n      \"position_at_start\": {\"x\": 6200, \"y\": 4800, \"area\": \"dire_jungle\"},\n      \"position_at_end\": {\"x\": 5500, \"y\": 5200, \"area\": \"dire_jungle\"},\n      \"camp_sequence\": [\n        {\"time_str\": \"6:08\", \"camp\": \"large_centaur\", \"tier\": \"hard\", \"area\": \"dire_jungle\"},\n        {\"time_str\": \"6:35\", \"camp\": \"medium_wolf\", \"tier\": \"medium\", \"area\": \"dire_jungle\"}\n      ],\n      \"lane_creeps_killed\": 4,\n      \"camps_cleared\": 2,\n      \"gold\": 2100,\n      \"last_hits\": 42,\n      \"level\": 6\n    }\n  ],\n  \"transitions\": {\n    \"first_jungle_kill_time\": 278.5,\n    \"first_jungle_kill_str\": \"4:38\",\n    \"first_large_camp_time\": 336.2,\n    \"first_large_camp_str\": \"5:36\",\n    \"left_lane_time\": 360.0,\n    \"left_lane_str\": \"6:00\"\n  },\n  \"summary\": {\n    \"total_lane_creeps\": 52,\n    \"total_neutral_creeps\": 29,\n    \"jungle_percentage\": 35.8,\n    \"gpm\": 452.0,\n    \"cs_per_min\": 8.1,\n    \"camps_cleared\": {\"large_centaur\": 3, \"large_satyr\": 4, \"medium_wolf\": 4, \"medium_harpy\": 2, \"small_kobold\": 1},\n    \"multi_camp_clears\": 0\n  },\n  \"multi_camp_clears\": []\n}\n</code></pre></p> <p>LLM responds:</p> <p>Anti-Mage's Farming Pattern (0-10 min):</p> <p>Power Spike Timeline:</p> Time Event 3:00 Ring of Health purchased 4:38 First jungle creep killed 5:36 First large camp (centaur) 6:00 Left lane for jungle rotation 7:00 Level 6 (Blink available) 9:00 Battle Fury completed 10:00 Level 10 <p>Minute 5-6 Farming Route:</p> <p>The <code>camp_sequence</code> shows his exact route: - 5:15 \u2192 Medium wolf camp (first jungle stop) - 5:42 \u2192 Small kobold camp - 6:08 \u2192 Large centaur camp - 6:35 \u2192 Back to medium wolf (respawned)</p> <p>Position tracking shows he went from <code>dire_safelane</code> at 5:00 to <code>dire_jungle</code> by 5:59.</p> <p>Summary: - 8.1 CS/min with 36% jungle farm - excellent efficiency - Ring of Health at 3:00 enabled jungle sustain - Hit level 6 at 7:00 (Blink for escape) just as he committed to jungle - 9-minute Battle Fury from uncontested lane + efficient jungle rotation</p>"},{"location":"examples/use-cases/#analyzing-mid-rotations-after-runes","title":"Analyzing Mid Rotations After Runes","text":"<p>User: \"Did the mid player rotate after rune pickups in the early game?\"</p> <p>LLM thinks: I need to analyze rotations and correlate them with rune pickups.</p> <p>LLM calls: <code>get_rotation_analysis(match_id=8461956309, start_minute=0, end_minute=15)</code></p> <p>Tool returns: <pre><code>{\n  \"success\": true,\n  \"rotations\": [\n    {\n      \"rotation_id\": \"rot_1\",\n      \"hero\": \"nevermore\",\n      \"role\": \"mid\",\n      \"game_time\": 365.0,\n      \"game_time_str\": \"6:05\",\n      \"from_lane\": \"mid\",\n      \"to_lane\": \"bot\",\n      \"rune_before\": {\n        \"rune_type\": \"haste\",\n        \"pickup_time\": 362.0,\n        \"seconds_before_rotation\": 3.0\n      },\n      \"outcome\": {\n        \"type\": \"kill\",\n        \"fight_id\": \"fight_2\",\n        \"kills_by_rotation_hero\": [\"antimage\"]\n      }\n    },\n    {\n      \"rotation_id\": \"rot_2\",\n      \"hero\": \"nevermore\",\n      \"role\": \"mid\",\n      \"game_time\": 485.0,\n      \"game_time_str\": \"8:05\",\n      \"from_lane\": \"mid\",\n      \"to_lane\": \"top\",\n      \"rune_before\": {\n        \"rune_type\": \"double_damage\",\n        \"pickup_time\": 482.0,\n        \"seconds_before_rotation\": 3.0\n      },\n      \"outcome\": {\n        \"type\": \"traded\",\n        \"fight_id\": \"fight_4\",\n        \"rotation_hero_died\": true,\n        \"kills_by_rotation_hero\": [\"earthshaker\"]\n      }\n    }\n  ],\n  \"summary\": {\n    \"total_rotations\": 5,\n    \"by_hero\": {\n      \"nevermore\": {\n        \"total_rotations\": 3,\n        \"successful_ganks\": 1,\n        \"failed_ganks\": 1,\n        \"trades\": 1,\n        \"rune_rotations\": 3\n      }\n    },\n    \"runes_leading_to_kills\": 2,\n    \"most_active_rotator\": \"nevermore\"\n  }\n}\n</code></pre></p> <p>LLM responds:</p> <p>Shadow Fiend's Rotation Pattern (0-15 min):</p> <p>SF rotated 3 times in the early game, all 3 after picking up power runes.</p> Time Rune Target Lane Outcome 6:05 Haste Bot Kill on Anti-Mage 8:05 DD Top Traded - killed ES but died 10:02 Arcane Bot No engagement <p>Analysis: - Rune discipline: SF consistently contested and secured power runes - Rotation efficiency: 2/3 rotations resulted in kills (67% success) - Risk management: The 8:05 rotation was greedy - diving with DD against a counter-gank setup</p> <p>Coaching point: The DD rotation at 8:05 shows good aggression but poor awareness. Check the fight log with <code>get_fight(fight_id=\"fight_4\")</code> to see if the counter-gank was telegraphed (TPs, missing enemies).</p>"},{"location":"getting-started/docker/","title":"Docker Deployment","text":"<p>The Dota 2 Match MCP Server can be run in Docker for faster startup times and consistent deployment.</p>"},{"location":"getting-started/docker/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/docker/#build-the-image","title":"Build the Image","text":"<pre><code>docker build -t dota2-mcp-server .\n</code></pre>"},{"location":"getting-started/docker/#run-with-sse-transport-recommended-for-docker","title":"Run with SSE Transport (Recommended for Docker)","text":"<pre><code>docker run -p 8081:8081 dota2-mcp-server --transport sse\n</code></pre> <p>The server will be available at <code>http://localhost:8081/sse</code>.</p>"},{"location":"getting-started/docker/#run-with-docker-compose","title":"Run with Docker Compose","text":"<pre><code>docker compose up\n</code></pre>"},{"location":"getting-started/docker/#transport-modes","title":"Transport Modes","text":""},{"location":"getting-started/docker/#sse-server-sent-events-recommended-for-docker","title":"SSE (Server-Sent Events) - Recommended for Docker","text":"<p>SSE transport runs an HTTP server, which is ideal for Docker deployments:</p> <pre><code>docker run -p 8081:8081 dota2-mcp-server --transport sse --port 8081\n</code></pre> <p>Configure your MCP client to connect to <code>http://localhost:8081/sse</code>.</p>"},{"location":"getting-started/docker/#stdio-standard-io","title":"STDIO (Standard I/O)","text":"<p>STDIO transport is the default for local development but requires interactive mode in Docker:</p> <pre><code>docker run -i dota2-mcp-server\n</code></pre>"},{"location":"getting-started/docker/#persistent-cache","title":"Persistent Cache","text":"<p>Replay files are large (50-400MB) and take time to download and parse. Mount a volume to persist the cache:</p> <pre><code>docker run -p 8081:8081 \\\n  -v dota2-replay-cache:/app/.cache/mcp_dota2 \\\n  dota2-mcp-server --transport sse\n</code></pre>"},{"location":"getting-started/docker/#environment-variables","title":"Environment Variables","text":"Variable Default Description <code>PORT</code> <code>8081</code> Port for SSE transport"},{"location":"getting-started/docker/#claude-desktop-configuration","title":"Claude Desktop Configuration","text":"<p>For Claude Desktop with Docker SSE transport:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"url\": \"http://localhost:8081/sse\"\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/docker/#startup-optimization","title":"Startup Optimization","text":"<p>The Docker image uses several optimizations for fast startup:</p> <ol> <li>Pre-compiled bytecode (<code>UV_COMPILE_BYTECODE=1</code>) - Python bytecode is compiled at build time</li> <li>Slim base image - Uses <code>python:3.12-slim-bookworm</code> for minimal size</li> <li>Layer caching - Dependencies are installed in a separate layer for faster rebuilds</li> <li>No runtime dependency resolution - Uses locked dependencies from <code>uv.lock</code></li> </ol>"},{"location":"getting-started/docker/#building-for-production","title":"Building for Production","text":"<p>For production deployments, consider:</p> <ol> <li> <p>Use a specific tag instead of <code>latest</code>:    <pre><code>docker build -t dota2-mcp-server:1.0.0 .\n</code></pre></p> </li> <li> <p>Set resource limits:    <pre><code>docker run -p 8081:8081 \\\n  --memory=2g \\\n  --cpus=2 \\\n  dota2-mcp-server --transport sse\n</code></pre></p> </li> <li> <p>Health checks are included in <code>docker-compose.yml</code></p> </li> </ol>"},{"location":"getting-started/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/docker/#slow-startup","title":"Slow Startup","text":"<p>If startup is slow, ensure: - The Docker image has been built (not building on first run) - The cache volume is mounted (avoids re-downloading replays) - Sufficient memory is allocated (at least 1GB recommended)</p>"},{"location":"getting-started/docker/#connection-refused","title":"Connection Refused","text":"<p>If you get \"connection refused\" when connecting to SSE: - Ensure the container is running: <code>docker ps</code> - Check the port mapping: <code>docker run -p 8081:8081 ...</code> - Verify the transport mode: <code>--transport sse</code></p>"},{"location":"getting-started/installation/","title":"Installation","text":"\ud83e\udd16 AI Summary <p>Requires Python 3.12 and <code>uv</code>. Install: <code>git clone</code> repo, <code>uv sync</code>. Verify: <code>uv run python dota_match_mcp_server.py</code>. Then connect to your LLM client (Claude Desktop, Claude Code, etc.).</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12</li> <li>uv package manager</li> </ul>"},{"location":"getting-started/installation/#install","title":"Install","text":"<pre><code>git clone https://github.com/DeepBlueCoding/mcp-replay-dota2.git\ncd mcp-replay-dota2\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<pre><code>uv run python dota_match_mcp_server.py\n</code></pre> <p>You should see: <pre><code>Dota 2 Match MCP Server starting...\nResources: dota2://heroes/all, dota2://map, ...\nTools: get_hero_deaths, get_combat_log, ...\n</code></pre></p>"},{"location":"getting-started/installation/#next-step","title":"Next Step","text":"<p>Connect to your LLM</p>"},{"location":"integrations/","title":"Connecting to LLMs","text":"\ud83e\udd16 AI Summary <p>Integration options by difficulty: Easy - Claude Desktop (config JSON), Claude Code CLI (.mcp.json), FastMCP Client (Python). Medium - LangChain, LangGraph, CrewAI, AutoGen, MCP SDK. Hard - Anthropic API, OpenAI API (manual tool loop). For quick chat \u2192 Claude Desktop. For Python apps \u2192 FastMCP/LangChain. For multi-step agents \u2192 LangGraph. For multi-agent \u2192 CrewAI.</p> <p>This MCP server can connect to any LLM that supports the Model Context Protocol or tool calling.</p>"},{"location":"integrations/#native-mcp-support","title":"Native MCP Support","text":"<p>These clients have built-in MCP support:</p> Client Setup Difficulty Best For Claude Desktop Easy Interactive chat with tools Claude Code CLI Easy Development workflows"},{"location":"integrations/#agentic-frameworks","title":"Agentic Frameworks","text":"<p>Use MCP tools with popular agent frameworks:</p> Framework Setup Difficulty Best For LangChain Medium Complex agent pipelines LangGraph Medium Stateful multi-step agents CrewAI Medium Multi-agent collaboration AutoGen Medium Conversational agents"},{"location":"integrations/#direct-api-integration","title":"Direct API Integration","text":"<p>For custom implementations:</p> Method Setup Difficulty Best For FastMCP Client Easy Python scripts MCP SDK Medium Custom clients Anthropic API Hard Full control OpenAI API Hard OpenAI models"},{"location":"integrations/#which-should-i-use","title":"Which Should I Use?","text":"<p>Just want to chat with match analysis? \u2192 Claude Desktop</p> <p>Building a Python application? \u2192 FastMCP Client or LangChain</p> <p>Need complex multi-step analysis? \u2192 LangGraph</p> <p>Want multiple specialized agents? \u2192 CrewAI</p>"},{"location":"integrations/anthropic-api/","title":"Anthropic API","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install anthropic mcp</code>. Define tools with <code>input_schema</code>. Create <code>MCPToolExecutor</code> class to call MCP server. Implement agentic loop: call Claude with tools \u2192 check <code>stop_reason</code> \u2192 if <code>tool_use</code>, execute via MCP, return results \u2192 repeat until <code>end_turn</code>. Supports streaming with <code>messages.stream()</code>.</p> <p>Integrate MCP tools directly with Claude API for full control.</p>"},{"location":"integrations/anthropic-api/#overview","title":"Overview","text":"<p>This approach gives you complete control over the tool calling loop. You define tools for Claude, handle tool calls yourself by calling the MCP server, and return results to Claude.</p>"},{"location":"integrations/anthropic-api/#install","title":"Install","text":"<pre><code>pip install anthropic mcp\n</code></pre>"},{"location":"integrations/anthropic-api/#setup","title":"Setup","text":"<pre><code>import anthropic\nimport asyncio\nimport json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclient = anthropic.Anthropic()\n\n# Tool definitions for Claude\nTOOLS = [\n    {\n        \"name\": \"get_hero_deaths\",\n        \"description\": \"Get all hero deaths in a Dota 2 match. Returns killer, victim, ability, and timing for each death.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\n                    \"type\": \"integer\",\n                    \"description\": \"The Dota 2 match ID\"\n                }\n            },\n            \"required\": [\"match_id\"]\n        }\n    },\n    {\n        \"name\": \"get_fight_combat_log\",\n        \"description\": \"Get combat log for a fight around a specific time. Auto-detects fight boundaries.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"},\n                \"reference_time\": {\"type\": \"number\", \"description\": \"Game time in seconds\"},\n                \"hero\": {\"type\": \"string\", \"description\": \"Optional hero to anchor detection\"}\n            },\n            \"required\": [\"match_id\", \"reference_time\"]\n        }\n    },\n    {\n        \"name\": \"get_objective_kills\",\n        \"description\": \"Get Roshan, tormentor, tower, and barracks kills.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"}\n            },\n            \"required\": [\"match_id\"]\n        }\n    },\n    {\n        \"name\": \"get_item_purchases\",\n        \"description\": \"Get item purchase timings for heroes.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"},\n                \"hero_filter\": {\"type\": \"string\", \"description\": \"Optional hero name filter\"}\n            },\n            \"required\": [\"match_id\"]\n        }\n    }\n]\n</code></pre>"},{"location":"integrations/anthropic-api/#mcp-tool-executor","title":"MCP Tool Executor","text":"<pre><code>class MCPToolExecutor:\n    def __init__(self, server_path: str):\n        self.server_path = server_path\n\n    async def execute(self, tool_name: str, tool_input: dict) -&gt; str:\n        server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=self.server_path\n        )\n\n        async with stdio_client(server_params) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                result = await session.call_tool(tool_name, arguments=tool_input)\n                return result.content[0].text\n\nexecutor = MCPToolExecutor(\"/path/to/mcp-replay-dota2\")\n</code></pre>"},{"location":"integrations/anthropic-api/#agentic-loop","title":"Agentic Loop","text":"<pre><code>async def analyze_match(user_message: str):\n    messages = [{\"role\": \"user\", \"content\": user_message}]\n\n    while True:\n        # Call Claude\n        response = client.messages.create(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            tools=TOOLS,\n            messages=messages\n        )\n\n        # Check if done\n        if response.stop_reason == \"end_turn\":\n            # Extract final text response\n            for block in response.content:\n                if block.type == \"text\":\n                    return block.text\n            return \"\"\n\n        # Handle tool use\n        if response.stop_reason == \"tool_use\":\n            # Add assistant message\n            messages.append({\"role\": \"assistant\", \"content\": response.content})\n\n            # Process each tool call\n            tool_results = []\n            for block in response.content:\n                if block.type == \"tool_use\":\n                    print(f\"Calling {block.name}({block.input})\")\n\n                    # Execute via MCP\n                    result = await executor.execute(block.name, block.input)\n\n                    tool_results.append({\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": block.id,\n                        \"content\": result\n                    })\n\n            # Add tool results\n            messages.append({\"role\": \"user\", \"content\": tool_results})\n\n# Run\nresult = asyncio.run(analyze_match(\n    \"Analyze match 8461956309. Focus on the first blood and subsequent laning phase.\"\n))\nprint(result)\n</code></pre>"},{"location":"integrations/anthropic-api/#streaming-response","title":"Streaming Response","text":"<pre><code>async def analyze_match_streaming(user_message: str):\n    messages = [{\"role\": \"user\", \"content\": user_message}]\n\n    while True:\n        with client.messages.stream(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            tools=TOOLS,\n            messages=messages\n        ) as stream:\n            response = stream.get_final_message()\n\n        if response.stop_reason == \"end_turn\":\n            for block in response.content:\n                if block.type == \"text\":\n                    print(block.text)\n            break\n\n        if response.stop_reason == \"tool_use\":\n            messages.append({\"role\": \"assistant\", \"content\": response.content})\n\n            tool_results = []\n            for block in response.content:\n                if block.type == \"tool_use\":\n                    result = await executor.execute(block.name, block.input)\n                    tool_results.append({\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": block.id,\n                        \"content\": result\n                    })\n\n            messages.append({\"role\": \"user\", \"content\": tool_results})\n\nasyncio.run(analyze_match_streaming(\"Why did Radiant lose match 8461956309?\"))\n</code></pre>"},{"location":"integrations/anthropic-api/#with-system-prompt","title":"With System Prompt","text":"<pre><code>SYSTEM_PROMPT = \"\"\"You are an expert Dota 2 analyst. When analyzing matches:\n\n1. Start by getting hero deaths to understand the flow of the game\n2. For important deaths, get the fight combat log to understand what happened\n3. Check objectives to understand macro gameplay\n4. Always explain findings in terms casual players can understand\n\nFocus on actionable insights - what could the losing team have done differently?\"\"\"\n\nresponse = client.messages.create(\n    model=\"claude-sonnet-4-20250514\",\n    max_tokens=4096,\n    system=SYSTEM_PROMPT,\n    tools=TOOLS,\n    messages=[{\"role\": \"user\", \"content\": \"Analyze match 8461956309\"}]\n)\n</code></pre>"},{"location":"integrations/autogen/","title":"AutoGen","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install pyautogen langchain-mcp-adapters</code>. Create <code>AssistantAgent</code> with function definitions, <code>UserProxyAgent</code> with <code>function_map</code> to execute MCP tools. Use <code>a_initiate_chat()</code> for conversation. For multi-agent: create specialists (FightExpert, MacroExpert) and use <code>GroupChat</code> + <code>GroupChatManager</code>.</p> <p>Build conversational agents that analyze matches through dialogue.</p>"},{"location":"integrations/autogen/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install pyautogen langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/autogen/#setup","title":"Setup","text":"<pre><code>import asyncio\nfrom autogen import AssistantAgent, UserProxyAgent, config_list_from_json\nfrom langchain_mcp_adapters import MCPToolkit\n\n# Connect to MCP server\ntoolkit = MCPToolkit(\n    command=\"uv\",\n    args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n    cwd=\"/path/to/mcp-replay-dota2\"\n)\n\n# LLM config\nconfig_list = [{\"model\": \"gpt-4o\", \"api_key\": \"your-api-key\"}]\nllm_config = {\"config_list\": config_list}\n</code></pre>"},{"location":"integrations/autogen/#define-tool-functions","title":"Define Tool Functions","text":"<pre><code>async def get_hero_deaths(match_id: int) -&gt; dict:\n    \"\"\"Get all hero deaths in a Dota 2 match.\"\"\"\n    return await toolkit.acall_tool(\"get_hero_deaths\", {\"match_id\": match_id})\n\nasync def get_fight_combat_log(match_id: int, reference_time: float, hero: str = None) -&gt; dict:\n    \"\"\"Get combat log for a fight around a specific time.\"\"\"\n    return await toolkit.acall_tool(\"get_fight_combat_log\", {\n        \"match_id\": match_id,\n        \"reference_time\": reference_time,\n        \"hero\": hero\n    })\n\nasync def get_objective_kills(match_id: int) -&gt; dict:\n    \"\"\"Get Roshan, tower, and barracks kills.\"\"\"\n    return await toolkit.acall_tool(\"get_objective_kills\", {\"match_id\": match_id})\n</code></pre>"},{"location":"integrations/autogen/#create-agents","title":"Create Agents","text":"<pre><code># Analyst agent with tool access\nanalyst = AssistantAgent(\n    name=\"DotaAnalyst\",\n    system_message=\"\"\"You are an expert Dota 2 analyst. Use the available tools to analyze matches.\n    Always explain your findings in terms casual players can understand.\n    Focus on actionable insights - what could the losing team have done differently?\"\"\",\n    llm_config={\n        **llm_config,\n        \"functions\": [\n            {\n                \"name\": \"get_hero_deaths\",\n                \"description\": \"Get all hero deaths in a match\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\"match_id\": {\"type\": \"integer\"}},\n                    \"required\": [\"match_id\"]\n                }\n            },\n            {\n                \"name\": \"get_fight_combat_log\",\n                \"description\": \"Get combat log for a fight\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"match_id\": {\"type\": \"integer\"},\n                        \"reference_time\": {\"type\": \"number\"},\n                        \"hero\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"match_id\", \"reference_time\"]\n                }\n            },\n            {\n                \"name\": \"get_objective_kills\",\n                \"description\": \"Get Roshan and tower kills\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\"match_id\": {\"type\": \"integer\"}},\n                    \"required\": [\"match_id\"]\n                }\n            }\n        ]\n    }\n)\n\n# User proxy that can execute functions\nuser_proxy = UserProxyAgent(\n    name=\"User\",\n    human_input_mode=\"NEVER\",\n    max_consecutive_auto_reply=10,\n    code_execution_config=False,\n    function_map={\n        \"get_hero_deaths\": get_hero_deaths,\n        \"get_fight_combat_log\": get_fight_combat_log,\n        \"get_objective_kills\": get_objective_kills\n    }\n)\n</code></pre>"},{"location":"integrations/autogen/#run-analysis","title":"Run Analysis","text":"<pre><code>async def main():\n    async with toolkit:\n        await user_proxy.a_initiate_chat(\n            analyst,\n            message=\"Analyze match 8461956309. I was playing Earthshaker and we lost. What did I do wrong?\"\n        )\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/autogen/#multi-agent-discussion","title":"Multi-Agent Discussion","text":"<p>Create multiple specialists that discuss the match:</p> <pre><code>fight_expert = AssistantAgent(\n    name=\"FightExpert\",\n    system_message=\"You specialize in teamfight analysis. Focus on ability usage and positioning.\",\n    llm_config=llm_config\n)\n\nmacro_expert = AssistantAgent(\n    name=\"MacroExpert\",\n    system_message=\"You specialize in macro gameplay - objectives, map control, and timing.\",\n    llm_config=llm_config\n)\n\n# Group chat for discussion\nfrom autogen import GroupChat, GroupChatManager\n\ngroupchat = GroupChat(\n    agents=[user_proxy, analyst, fight_expert, macro_expert],\n    messages=[],\n    max_round=12\n)\n\nmanager = GroupChatManager(groupchat=groupchat, llm_config=llm_config)\n\nasync def main():\n    async with toolkit:\n        await user_proxy.a_initiate_chat(\n            manager,\n            message=\"Analyze match 8461956309 as a team. Each expert should contribute their specialty.\"\n        )\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/claude-code/","title":"Claude Code CLI","text":"\ud83e\udd16 AI Summary <p>Add to <code>.mcp.json</code> (project) or <code>~/.claude/settings.json</code> (global): <code>{\"mcpServers\": {\"dota2\": {\"command\": \"uv\", \"args\": [\"run\", \"--frozen\", \"--project\", \"/path/to/repo\", \"python\", \"/path/to/repo/dota_match_mcp_server.py\"]}}}</code>. Verify with <code>/tools</code>. Ask: \"Analyze match 8461956309\". Can also generate scripts using real match data.</p> <p>Use the Dota 2 MCP server within Claude Code for development workflows.</p>"},{"location":"integrations/claude-code/#project-level-setup","title":"Project-Level Setup","text":"<p>Add to your project's <code>.mcp.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--frozen\",\n        \"--project\", \"/absolute/path/to/mcp-replay-dota2\",\n        \"python\",\n        \"/absolute/path/to/mcp-replay-dota2/dota_match_mcp_server.py\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/claude-code/#global-setup","title":"Global Setup","text":"<p>Add to <code>~/.claude/settings.json</code> to make it available in all projects:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--frozen\",\n        \"--project\", \"/absolute/path/to/mcp-replay-dota2\",\n        \"python\",\n        \"/absolute/path/to/mcp-replay-dota2/dota_match_mcp_server.py\"\n      ]\n    }\n  }\n}\n</code></pre> <p>Why <code>--frozen --project</code>?</p> <ul> <li><code>--frozen</code> ensures dependencies are locked (no unexpected updates)</li> <li><code>--project</code> explicitly sets the project path (avoids working directory issues)</li> </ul>"},{"location":"integrations/claude-code/#verify","title":"Verify","text":"<p>Run Claude Code and check available tools:</p> <pre><code>claude\n&gt; /tools\n</code></pre> <p>You should see the Dota 2 tools listed.</p>"},{"location":"integrations/claude-code/#usage","title":"Usage","text":"<p>In any Claude Code session:</p> <pre><code>&gt; Analyze match 8461956309 and tell me about the first blood\n</code></pre> <p>Claude will use the MCP tools automatically.</p>"},{"location":"integrations/claude-code/#use-case-replay-analysis-scripts","title":"Use Case: Replay Analysis Scripts","text":"<p>You can ask Claude Code to write scripts that use match data:</p> <pre><code>&gt; Write a Python script that analyzes carry farm efficiency using match 8461956309 data\n</code></pre> <p>Claude will call the tools to get real data and generate code that processes it.</p>"},{"location":"integrations/claude-desktop/","title":"Claude Desktop","text":"\ud83e\udd16 AI Summary <p>Add to <code>claude_desktop_config.json</code>: <code>{\"mcpServers\": {\"dota2\": {\"command\": \"uv\", \"args\": [\"run\", \"--frozen\", \"--project\", \"/path/to/repo\", \"python\", \"/path/to/repo/dota_match_mcp_server.py\"]}}}</code>. Restart Claude Desktop. Look for hammer icon (\ud83d\udd28) to verify. Ask naturally: \"Analyze match 8461956309\".</p> <p>The simplest way to use this MCP server - just configure and chat.</p>"},{"location":"integrations/claude-desktop/#setup","title":"Setup","text":"<p>Add to your Claude Desktop config file:</p> <p>Linux: <code>~/.config/claude/claude_desktop_config.json</code> macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code> Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code></p> <p>=== \"Linux/macOS\"</p> <pre><code>```json\n{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--frozen\",\n        \"--project\", \"/home/user/projects/mcp-replay-dota2\",\n        \"python\",\n        \"/home/user/projects/mcp-replay-dota2/dota_match_mcp_server.py\"\n      ]\n    }\n  }\n}\n```\n</code></pre> <p>=== \"Windows\"</p> <pre><code>```json\n{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"run\",\n        \"--frozen\",\n        \"--project\", \"C:\\\\Users\\\\username\\\\projects\\\\mcp-replay-dota2\",\n        \"python\",\n        \"C:\\\\Users\\\\username\\\\projects\\\\mcp-replay-dota2\\\\dota_match_mcp_server.py\"\n      ]\n    }\n  }\n}\n```\n</code></pre> <p>Why <code>--frozen --project</code>?</p> <ul> <li><code>--frozen</code> ensures dependencies are locked (no unexpected updates)</li> <li><code>--project</code> explicitly sets the project path (avoids working directory issues)</li> </ul>"},{"location":"integrations/claude-desktop/#restart-claude-desktop","title":"Restart Claude Desktop","text":"<p>After saving the config, restart Claude Desktop completely (quit and reopen).</p>"},{"location":"integrations/claude-desktop/#verify-connection","title":"Verify Connection","text":"<p>You should see a hammer icon (\ud83d\udd28) in the chat input area. Click it to see available tools:</p> <ul> <li><code>get_hero_deaths</code></li> <li><code>get_combat_log</code></li> <li><code>get_fight_combat_log</code></li> <li><code>get_item_purchases</code></li> <li><code>get_objective_kills</code></li> <li><code>get_match_timeline</code></li> <li><code>get_stats_at_minute</code></li> <li><code>get_courier_kills</code></li> </ul>"},{"location":"integrations/claude-desktop/#usage","title":"Usage","text":"<p>Just ask naturally:</p> <p>\"Analyze match 8461956309. Why did Radiant lose the fight at 25 minutes?\"</p> <p>Claude will automatically: 1. Call <code>get_hero_deaths</code> to find deaths around that time 2. Call <code>get_fight_combat_log</code> to get fight details 3. Synthesize an analysis</p>"},{"location":"integrations/claude-desktop/#troubleshooting","title":"Troubleshooting","text":"<p>No hammer icon?</p> <ul> <li>Check the config file path is correct</li> <li>Ensure <code>uv</code> is in your PATH</li> <li>Check Claude Desktop logs for errors</li> </ul> <p>Tools not working?</p> <ul> <li>Verify the <code>--project</code> path points to the cloned repository</li> <li>Test manually:</li> </ul> <pre><code>uv run --frozen --project /path/to/mcp-replay-dota2 python /path/to/mcp-replay-dota2/dota_match_mcp_server.py\n</code></pre>"},{"location":"integrations/crewai/","title":"CrewAI","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install crewai crewai-tools langchain-mcp-adapters</code>. Wrap MCP tools with <code>@tool</code> decorator. Create specialized Agents: FightAnalyst, EconomyAnalyst, ObjectiveAnalyst, LeadAnalyst. Define Tasks with <code>context</code> for dependencies. Run with <code>Crew.kickoff()</code>. Agents collaborate and synthesize analysis.</p> <p>Build multi-agent systems where specialized agents collaborate on match analysis.</p>"},{"location":"integrations/crewai/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install crewai crewai-tools langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/crewai/#setup-mcp-tools-for-crewai","title":"Setup MCP Tools for CrewAI","text":"<pre><code>import asyncio\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import tool\nfrom langchain_mcp_adapters import MCPToolkit\n\n# Connect to MCP server\ntoolkit = MCPToolkit(\n    command=\"uv\",\n    args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n    cwd=\"/path/to/mcp-replay-dota2\"\n)\n\n# Wrap MCP tools as CrewAI tools\n@tool(\"Get Hero Deaths\")\ndef get_hero_deaths(match_id: int) -&gt; dict:\n    \"\"\"Get all hero deaths in a Dota 2 match.\"\"\"\n    return toolkit.call_tool(\"get_hero_deaths\", {\"match_id\": match_id})\n\n@tool(\"Get Fight Combat Log\")\ndef get_fight_combat_log(match_id: int, reference_time: float, hero: str = None) -&gt; dict:\n    \"\"\"Get combat log for a fight around a specific time.\"\"\"\n    return toolkit.call_tool(\"get_fight_combat_log\", {\n        \"match_id\": match_id,\n        \"reference_time\": reference_time,\n        \"hero\": hero\n    })\n\n@tool(\"Get Item Purchases\")\ndef get_item_purchases(match_id: int, hero_filter: str = None) -&gt; dict:\n    \"\"\"Get item purchase timings for heroes.\"\"\"\n    return toolkit.call_tool(\"get_item_purchases\", {\n        \"match_id\": match_id,\n        \"hero_filter\": hero_filter\n    })\n\n@tool(\"Get Objectives\")\ndef get_objective_kills(match_id: int) -&gt; dict:\n    \"\"\"Get Roshan, tower, and barracks kills.\"\"\"\n    return toolkit.call_tool(\"get_objective_kills\", {\"match_id\": match_id})\n</code></pre>"},{"location":"integrations/crewai/#define-specialized-agents","title":"Define Specialized Agents","text":"<pre><code># Agent that analyzes teamfights\nfight_analyst = Agent(\n    role=\"Teamfight Analyst\",\n    goal=\"Analyze teamfights and identify what went wrong or right\",\n    backstory=\"Expert at breaking down Dota 2 teamfights, understanding ability usage and positioning\",\n    tools=[get_hero_deaths, get_fight_combat_log],\n    verbose=True\n)\n\n# Agent that analyzes economy\neconomy_analyst = Agent(\n    role=\"Economy Analyst\",\n    goal=\"Track gold, items, and farm efficiency\",\n    backstory=\"Specialist in Dota 2 economy, item timings, and net worth analysis\",\n    tools=[get_item_purchases],\n    verbose=True\n)\n\n# Agent that tracks objectives\nobjective_analyst = Agent(\n    role=\"Objective Analyst\",\n    goal=\"Track Roshan, towers, and map control\",\n    backstory=\"Expert at macro gameplay, objective timings, and strategic decisions\",\n    tools=[get_objective_kills],\n    verbose=True\n)\n\n# Lead analyst that synthesizes everything\nlead_analyst = Agent(\n    role=\"Lead Analyst\",\n    goal=\"Synthesize analysis from all specialists into actionable insights\",\n    backstory=\"Senior Dota 2 coach who combines tactical and strategic analysis\",\n    verbose=True\n)\n</code></pre>"},{"location":"integrations/crewai/#create-analysis-tasks","title":"Create Analysis Tasks","text":"<pre><code>match_id = 8461956309\n\nfight_task = Task(\n    description=f\"Analyze all major teamfights in match {match_id}. Find the 3 most impactful fights and explain what happened.\",\n    expected_output=\"Detailed breakdown of 3 key teamfights with ability usage and positioning analysis\",\n    agent=fight_analyst\n)\n\neconomy_task = Task(\n    description=f\"Analyze carry item timings in match {match_id}. Compare farming efficiency.\",\n    expected_output=\"Item timing analysis for carries with efficiency comparison\",\n    agent=economy_analyst\n)\n\nobjective_task = Task(\n    description=f\"Track all objective kills in match {match_id}. Analyze Roshan control and tower trading.\",\n    expected_output=\"Timeline of objectives with strategic analysis\",\n    agent=objective_analyst\n)\n\nsynthesis_task = Task(\n    description=\"Combine all analyses into a match report. Identify the key reasons for the outcome.\",\n    expected_output=\"Complete match analysis with 3-5 key takeaways\",\n    agent=lead_analyst,\n    context=[fight_task, economy_task, objective_task]\n)\n</code></pre>"},{"location":"integrations/crewai/#run-the-crew","title":"Run the Crew","text":"<pre><code>crew = Crew(\n    agents=[fight_analyst, economy_analyst, objective_analyst, lead_analyst],\n    tasks=[fight_task, economy_task, objective_task, synthesis_task],\n    verbose=True\n)\n\nasync def main():\n    async with toolkit:\n        result = crew.kickoff()\n        print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/crewai/#example-output","title":"Example Output","text":"<pre><code>[Fight Analyst] Analyzing deaths in match 8461956309...\n[Fight Analyst] Found 45 deaths. Identifying major fights...\n[Fight Analyst] Key fight at 24:47 - 4 deaths in 11 seconds...\n\n[Economy Analyst] Checking item timings...\n[Economy Analyst] Anti-Mage Battle Fury at 9:00 (excellent)\n[Economy Analyst] Medusa Manta at 18:00 (good)\n\n[Objective Analyst] Tracking objectives...\n[Objective Analyst] Dire took all 4 Roshans\n[Objective Analyst] 14 towers destroyed...\n\n[Lead Analyst] Synthesizing analysis...\n\nMATCH ANALYSIS - 8461956309\n===========================\nRadiant lost due to:\n1. Lost Roshan control (0/4)\n2. Teamfight at 24:47 cost them high ground\n3. Medusa snowballed with uncontested farm\n...\n</code></pre>"},{"location":"integrations/fastmcp/","title":"FastMCP Client","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install fastmcp</code>. Use <code>Client(\"uv run python dota_match_mcp_server.py\")</code> as async context manager. Call tools: <code>await client.call_tool(\"get_hero_deaths\", match_id=123)</code>. Get resources: <code>await client.get_resource(\"dota2://heroes/all\")</code>. Handles errors and supports batch processing.</p> <p>The simplest Python integration - use the same library the server is built with.</p>"},{"location":"integrations/fastmcp/#install","title":"Install","text":"<pre><code>pip install fastmcp\n</code></pre>"},{"location":"integrations/fastmcp/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom fastmcp import Client\n\nasync def main():\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Call tools directly\n        deaths = await client.call_tool(\"get_hero_deaths\", match_id=8461956309)\n        print(f\"Total deaths: {deaths['total_deaths']}\")\n\n        for death in deaths['deaths'][:5]:\n            print(f\"  {death['game_time_str']}: {death['killer']} killed {death['victim']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/fastmcp/#working-with-resources","title":"Working with Resources","text":"<pre><code>async def main():\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Get static hero reference data\n        heroes = await client.get_resource(\"dota2://heroes/all\")\n        print(f\"Total heroes: {len(heroes)}\")\n\n        # Get match-specific data using tools\n        match_heroes = await client.call_tool(\"get_match_heroes\", match_id=8461956309)\n        for hero in match_heroes['radiant'] + match_heroes['dire']:\n            print(f\"{hero['localized_name']} - {hero['team']} - K/D/A: {hero['kills']}/{hero['deaths']}/{hero['assists']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/fastmcp/#complete-analysis-script","title":"Complete Analysis Script","text":"<pre><code>import asyncio\nfrom fastmcp import Client\n\nasync def analyze_match(match_id: int):\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Get all data\n        deaths = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n        objectives = await client.call_tool(\"get_objective_kills\", match_id=match_id)\n\n        print(f\"\\n=== Match {match_id} Analysis ===\\n\")\n\n        # Deaths summary\n        print(f\"Total Deaths: {deaths['total_deaths']}\")\n\n        # First blood\n        if deaths['deaths']:\n            fb = deaths['deaths'][0]\n            print(f\"First Blood: {fb['game_time_str']} - {fb['killer']} killed {fb['victim']}\")\n\n        # Roshan control\n        rosh = objectives['roshan_kills']\n        print(f\"\\nRoshan Kills: {len(rosh)}\")\n        for r in rosh:\n            print(f\"  Rosh #{r['kill_number']} at {r['game_time_str']} by {r['team']}\")\n\n        # Tower score\n        towers = objectives['tower_kills']\n        radiant_towers = len([t for t in towers if t['team'] == 'radiant'])\n        dire_towers = len([t for t in towers if t['team'] == 'dire'])\n        print(f\"\\nTowers Lost - Radiant: {radiant_towers}, Dire: {dire_towers}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_match(8461956309))\n</code></pre>"},{"location":"integrations/fastmcp/#error-handling","title":"Error Handling","text":"<pre><code>async def safe_analysis(match_id: int):\n    try:\n        async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n            result = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n\n            if not result.get('success', True):\n                print(f\"Error: {result.get('error', 'Unknown error')}\")\n                return None\n\n            return result\n\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return None\n</code></pre>"},{"location":"integrations/fastmcp/#batch-processing","title":"Batch Processing","text":"<pre><code>async def analyze_multiple_matches(match_ids: list[int]):\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        results = {}\n\n        for match_id in match_ids:\n            print(f\"Analyzing {match_id}...\")\n            deaths = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n            objectives = await client.call_tool(\"get_objective_kills\", match_id=match_id)\n\n            results[match_id] = {\n                \"deaths\": deaths['total_deaths'],\n                \"roshans\": len(objectives['roshan_kills']),\n                \"towers\": len(objectives['tower_kills'])\n            }\n\n        return results\n\n# Analyze recent matches\nmatches = [8461956309, 8461956310, 8461956311]\nresults = asyncio.run(analyze_multiple_matches(matches))\n</code></pre>"},{"location":"integrations/langchain/","title":"LangChain","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install langchain langchain-openai langchain-mcp-adapters</code>. Use <code>MCPToolkit</code> to connect, <code>toolkit.get_tools()</code> returns LangChain tools. Bind to any LLM: <code>llm.bind_tools(tools)</code>. Works with agents via <code>create_tool_calling_agent()</code>. Supports Claude via <code>langchain-anthropic</code>.</p> <p>Use MCP tools as LangChain tools with any supported LLM.</p>"},{"location":"integrations/langchain/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install langchain langchain-openai langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/langchain/#basic-setup","title":"Basic Setup","text":"<pre><code>import asyncio\nfrom langchain_openai import ChatOpenAI\nfrom langchain_mcp_adapters import MCPToolkit\n\nasync def main():\n    # Connect to MCP server\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with toolkit:\n        # Get tools as LangChain tools\n        tools = toolkit.get_tools()\n        print(f\"Available tools: {[t.name for t in tools]}\")\n\n        # Use with any LangChain LLM\n        llm = ChatOpenAI(model=\"gpt-4o\")\n        llm_with_tools = llm.bind_tools(tools)\n\n        response = await llm_with_tools.ainvoke(\n            \"What happened at first blood in match 8461956309?\"\n        )\n        print(response)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langchain/#with-langchain-agents","title":"With LangChain Agents","text":"<pre><code>from langchain.agents import AgentExecutor, create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate\n\nasync def main():\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with toolkit:\n        tools = toolkit.get_tools()\n        llm = ChatOpenAI(model=\"gpt-4o\")\n\n        prompt = ChatPromptTemplate.from_messages([\n            (\"system\", \"You are a Dota 2 analyst. Use the available tools to analyze matches.\"),\n            (\"human\", \"{input}\"),\n            (\"placeholder\", \"{agent_scratchpad}\")\n        ])\n\n        agent = create_tool_calling_agent(llm, tools, prompt)\n        executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n\n        result = await executor.ainvoke({\n            \"input\": \"Analyze the teamfight at 25 minutes in match 8461956309\"\n        })\n        print(result[\"output\"])\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langchain/#with-claude-via-langchain","title":"With Claude via LangChain","text":"<pre><code>from langchain_anthropic import ChatAnthropic\n\nllm = ChatAnthropic(model=\"claude-sonnet-4-20250514\")\nllm_with_tools = llm.bind_tools(tools)\n</code></pre>"},{"location":"integrations/langchain/#tool-descriptions","title":"Tool Descriptions","text":"<p>The MCP adapter preserves tool descriptions, so the LLM knows when to use each tool:</p> Tool LangChain Description <code>get_hero_deaths</code> Get all hero deaths in a Dota 2 match <code>get_fight_combat_log</code> Get combat log for a fight around a specific time <code>get_item_purchases</code> Get item purchase timings for heroes"},{"location":"integrations/langgraph/","title":"LangGraph","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install langgraph langchain-openai langchain-mcp-adapters</code>. Use <code>create_react_agent(llm, tools)</code> for simple ReAct agent. Build custom <code>StateGraph</code> for specialized flows: get_deaths \u2192 identify_fights \u2192 get_objectives \u2192 synthesize. Supports streaming via <code>astream_events()</code>.</p> <p>Build stateful, multi-step Dota 2 analysis agents with LangGraph.</p>"},{"location":"integrations/langgraph/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install langgraph langchain-openai langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/langgraph/#react-agent","title":"ReAct Agent","text":"<p>The simplest LangGraph agent - reasons and acts in a loop:</p> <pre><code>import asyncio\nfrom langchain_openai import ChatOpenAI\nfrom langchain_mcp_adapters import MCPToolkit\nfrom langgraph.prebuilt import create_react_agent\n\nasync def main():\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with toolkit:\n        tools = toolkit.get_tools()\n        llm = ChatOpenAI(model=\"gpt-4o\")\n\n        # Create ReAct agent\n        agent = create_react_agent(llm, tools)\n\n        # Run analysis\n        response = await agent.ainvoke({\n            \"messages\": [{\n                \"role\": \"user\",\n                \"content\": \"Analyze match 8461956309. First get all deaths, then analyze the biggest teamfight.\"\n            }]\n        })\n\n        print(response[\"messages\"][-1].content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langgraph/#custom-graph-for-match-analysis","title":"Custom Graph for Match Analysis","text":"<p>Build a specialized graph that follows a specific analysis flow:</p> <pre><code>from langgraph.graph import StateGraph, END\nfrom typing import TypedDict, Annotated\nimport operator\n\nclass AnalysisState(TypedDict):\n    match_id: int\n    deaths: list\n    fights: list\n    objectives: list\n    analysis: str\n    messages: Annotated[list, operator.add]\n\ndef get_deaths(state: AnalysisState):\n    # Call get_hero_deaths tool\n    deaths = tools[\"get_hero_deaths\"].invoke({\"match_id\": state[\"match_id\"]})\n    return {\"deaths\": deaths[\"deaths\"]}\n\ndef identify_fights(state: AnalysisState):\n    # Find clusters of deaths = teamfights\n    fights = []\n    for death in state[\"deaths\"]:\n        fight = tools[\"get_fight_combat_log\"].invoke({\n            \"match_id\": state[\"match_id\"],\n            \"reference_time\": death[\"game_time\"],\n            \"hero\": death[\"victim\"]\n        })\n        if fight[\"duration\"] &gt; 10 and len(fight[\"participants\"]) &gt; 4:\n            fights.append(fight)\n    return {\"fights\": fights}\n\ndef get_objectives(state: AnalysisState):\n    objectives = tools[\"get_objective_kills\"].invoke({\"match_id\": state[\"match_id\"]})\n    return {\"objectives\": objectives}\n\ndef synthesize(state: AnalysisState):\n    # Use LLM to synthesize analysis\n    prompt = f\"\"\"Analyze this match:\n    - {len(state['deaths'])} total deaths\n    - {len(state['fights'])} major teamfights\n    - Roshan kills: {len(state['objectives']['roshan_kills'])}\n    - Towers: {len(state['objectives']['tower_kills'])}\n\n    Key fights: {state['fights'][:3]}\n    \"\"\"\n    response = llm.invoke(prompt)\n    return {\"analysis\": response.content}\n\n# Build graph\ngraph = StateGraph(AnalysisState)\ngraph.add_node(\"get_deaths\", get_deaths)\ngraph.add_node(\"identify_fights\", identify_fights)\ngraph.add_node(\"get_objectives\", get_objectives)\ngraph.add_node(\"synthesize\", synthesize)\n\ngraph.set_entry_point(\"get_deaths\")\ngraph.add_edge(\"get_deaths\", \"identify_fights\")\ngraph.add_edge(\"get_deaths\", \"get_objectives\")  # parallel\ngraph.add_edge(\"identify_fights\", \"synthesize\")\ngraph.add_edge(\"get_objectives\", \"synthesize\")\ngraph.add_edge(\"synthesize\", END)\n\napp = graph.compile()\n</code></pre>"},{"location":"integrations/langgraph/#streaming-results","title":"Streaming Results","text":"<p>LangGraph supports streaming for long analyses:</p> <pre><code>async for event in agent.astream_events(\n    {\"messages\": [{\"role\": \"user\", \"content\": \"Full analysis of match 8461956309\"}]},\n    version=\"v2\"\n):\n    if event[\"event\"] == \"on_chat_model_stream\":\n        print(event[\"data\"][\"chunk\"].content, end=\"\", flush=True)\n</code></pre>"},{"location":"integrations/mcp-sdk/","title":"MCP SDK","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install mcp</code>. Use <code>StdioServerParameters</code> + <code>stdio_client()</code> + <code>ClientSession</code>. Initialize with <code>await session.initialize()</code>. List tools/resources with <code>session.list_tools()</code>. Call tools: <code>session.call_tool(name, arguments={})</code>. Read resources: <code>session.read_resource(uri)</code>. Build custom client class for cleaner API.</p> <p>Use the official MCP Python SDK for low-level control.</p>"},{"location":"integrations/mcp-sdk/#install","title":"Install","text":"<pre><code>pip install mcp\n</code></pre>"},{"location":"integrations/mcp-sdk/#basic-client","title":"Basic Client","text":"<pre><code>import asyncio\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nasync def main():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize connection\n            await session.initialize()\n\n            # List available tools\n            tools = await session.list_tools()\n            print(\"Available tools:\")\n            for tool in tools.tools:\n                print(f\"  - {tool.name}: {tool.description}\")\n\n            # List available resources\n            resources = await session.list_resources()\n            print(\"\\nAvailable resources:\")\n            for resource in resources.resources:\n                print(f\"  - {resource.uri}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/mcp-sdk/#calling-tools","title":"Calling Tools","text":"<pre><code>async def call_tool_example():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Call get_hero_deaths\n            result = await session.call_tool(\n                \"get_hero_deaths\",\n                arguments={\"match_id\": 8461956309}\n            )\n\n            # Result is a list of content blocks\n            for content in result.content:\n                if content.type == \"text\":\n                    import json\n                    data = json.loads(content.text)\n                    print(f\"Total deaths: {data['total_deaths']}\")\n\nasyncio.run(call_tool_example())\n</code></pre>"},{"location":"integrations/mcp-sdk/#reading-resources","title":"Reading Resources","text":"<pre><code>async def read_resource_example():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp-replay-dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Read hero resource\n            result = await session.read_resource(\"dota2://heroes/all\")\n\n            for content in result.contents:\n                if content.mimeType == \"application/json\":\n                    import json\n                    heroes = json.loads(content.text)\n                    print(f\"Total heroes: {len(heroes)}\")\n\nasyncio.run(read_resource_example())\n</code></pre>"},{"location":"integrations/mcp-sdk/#building-a-custom-client-class","title":"Building a Custom Client Class","text":"<pre><code>import json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclass Dota2MCPClient:\n    def __init__(self, server_path: str):\n        self.server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=server_path\n        )\n        self._session = None\n        self._read = None\n        self._write = None\n\n    async def __aenter__(self):\n        transport = stdio_client(self.server_params)\n        self._read, self._write = await transport.__aenter__()\n        self._session = ClientSession(self._read, self._write)\n        await self._session.__aenter__()\n        await self._session.initialize()\n        return self\n\n    async def __aexit__(self, *args):\n        if self._session:\n            await self._session.__aexit__(*args)\n\n    async def get_hero_deaths(self, match_id: int) -&gt; dict:\n        result = await self._session.call_tool(\n            \"get_hero_deaths\",\n            arguments={\"match_id\": match_id}\n        )\n        return json.loads(result.content[0].text)\n\n    async def get_objectives(self, match_id: int) -&gt; dict:\n        result = await self._session.call_tool(\n            \"get_objective_kills\",\n            arguments={\"match_id\": match_id}\n        )\n        return json.loads(result.content[0].text)\n\n    async def get_fight(self, match_id: int, time: float, hero: str = None) -&gt; dict:\n        args = {\"match_id\": match_id, \"reference_time\": time}\n        if hero:\n            args[\"hero\"] = hero\n        result = await self._session.call_tool(\"get_fight_combat_log\", arguments=args)\n        return json.loads(result.content[0].text)\n\n# Usage\nasync def main():\n    async with Dota2MCPClient(\"/path/to/mcp-replay-dota2\") as client:\n        deaths = await client.get_hero_deaths(8461956309)\n        print(f\"Deaths: {deaths['total_deaths']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/openai-api/","title":"OpenAI API","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install openai mcp</code>. Define tools with <code>type: \"function\"</code> schema. Create <code>MCPToolExecutor</code> to call MCP server. Agentic loop: call <code>chat.completions.create()</code> with tools \u2192 check <code>message.tool_calls</code> \u2192 execute via MCP \u2192 add tool results \u2192 repeat until no tool_calls. Supports streaming and parallel tool calls.</p> <p>Use MCP tools with OpenAI models (GPT-4, GPT-4o, etc.).</p>"},{"location":"integrations/openai-api/#install","title":"Install","text":"<pre><code>pip install openai mcp\n</code></pre>"},{"location":"integrations/openai-api/#setup","title":"Setup","text":"<pre><code>from openai import OpenAI\nimport asyncio\nimport json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclient = OpenAI()\n\n# Tool definitions for OpenAI\nTOOLS = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_hero_deaths\",\n            \"description\": \"Get all hero deaths in a Dota 2 match\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\", \"description\": \"The Dota 2 match ID\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_fight_combat_log\",\n            \"description\": \"Get combat log for a fight around a specific time\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"},\n                    \"reference_time\": {\"type\": \"number\"},\n                    \"hero\": {\"type\": \"string\"}\n                },\n                \"required\": [\"match_id\", \"reference_time\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_objective_kills\",\n            \"description\": \"Get Roshan, tower, and barracks kills\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_item_purchases\",\n            \"description\": \"Get item purchase timings\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"},\n                    \"hero_filter\": {\"type\": \"string\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    }\n]\n</code></pre>"},{"location":"integrations/openai-api/#mcp-tool-executor","title":"MCP Tool Executor","text":"<pre><code>class MCPToolExecutor:\n    def __init__(self, server_path: str):\n        self.server_path = server_path\n\n    async def execute(self, tool_name: str, tool_args: dict) -&gt; str:\n        server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=self.server_path\n        )\n\n        async with stdio_client(server_params) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                result = await session.call_tool(tool_name, arguments=tool_args)\n                return result.content[0].text\n\nexecutor = MCPToolExecutor(\"/path/to/mcp-replay-dota2\")\n</code></pre>"},{"location":"integrations/openai-api/#agentic-loop","title":"Agentic Loop","text":"<pre><code>async def analyze_match(user_message: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are an expert Dota 2 analyst. Use the available tools to analyze matches and provide insights.\"},\n        {\"role\": \"user\", \"content\": user_message}\n    ]\n\n    while True:\n        response = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n            tools=TOOLS,\n            tool_choice=\"auto\"\n        )\n\n        message = response.choices[0].message\n\n        # Check if done\n        if message.tool_calls is None:\n            return message.content\n\n        # Add assistant message\n        messages.append(message)\n\n        # Process tool calls\n        for tool_call in message.tool_calls:\n            print(f\"Calling {tool_call.function.name}...\")\n\n            # Parse arguments\n            args = json.loads(tool_call.function.arguments)\n\n            # Execute via MCP\n            result = await executor.execute(tool_call.function.name, args)\n\n            # Add tool result\n            messages.append({\n                \"role\": \"tool\",\n                \"tool_call_id\": tool_call.id,\n                \"content\": result\n            })\n\n# Run\nresult = asyncio.run(analyze_match(\"Analyze match 8461956309. What happened at first blood?\"))\nprint(result)\n</code></pre>"},{"location":"integrations/openai-api/#streaming","title":"Streaming","text":"<pre><code>async def analyze_match_streaming(user_message: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are an expert Dota 2 analyst.\"},\n        {\"role\": \"user\", \"content\": user_message}\n    ]\n\n    while True:\n        stream = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n            tools=TOOLS,\n            stream=True\n        )\n\n        tool_calls = []\n        content = \"\"\n\n        for chunk in stream:\n            delta = chunk.choices[0].delta\n\n            if delta.content:\n                print(delta.content, end=\"\", flush=True)\n                content += delta.content\n\n            if delta.tool_calls:\n                for tc in delta.tool_calls:\n                    if tc.index &gt;= len(tool_calls):\n                        tool_calls.append({\"id\": \"\", \"name\": \"\", \"arguments\": \"\"})\n                    if tc.id:\n                        tool_calls[tc.index][\"id\"] = tc.id\n                    if tc.function.name:\n                        tool_calls[tc.index][\"name\"] = tc.function.name\n                    if tc.function.arguments:\n                        tool_calls[tc.index][\"arguments\"] += tc.function.arguments\n\n        if not tool_calls:\n            print()\n            return content\n\n        # Process tool calls\n        messages.append({\n            \"role\": \"assistant\",\n            \"content\": content,\n            \"tool_calls\": [\n                {\n                    \"id\": tc[\"id\"],\n                    \"type\": \"function\",\n                    \"function\": {\"name\": tc[\"name\"], \"arguments\": tc[\"arguments\"]}\n                }\n                for tc in tool_calls\n            ]\n        })\n\n        for tc in tool_calls:\n            args = json.loads(tc[\"arguments\"])\n            result = await executor.execute(tc[\"name\"], args)\n            messages.append({\n                \"role\": \"tool\",\n                \"tool_call_id\": tc[\"id\"],\n                \"content\": result\n            })\n\nasyncio.run(analyze_match_streaming(\"Full analysis of match 8461956309\"))\n</code></pre>"},{"location":"integrations/openai-api/#with-parallel-tool-calls","title":"With Parallel Tool Calls","text":"<p>GPT-4o can request multiple tools in parallel:</p> <pre><code># The agentic loop above handles this automatically\n# GPT-4o will return multiple tool_calls when it wants parallel execution\n\n# Example response structure:\n# message.tool_calls = [\n#     ToolCall(id=\"1\", function=Function(name=\"get_hero_deaths\", arguments=\"{\\\"match_id\\\": 8461956309}\")),\n#     ToolCall(id=\"2\", function=Function(name=\"get_objective_kills\", arguments=\"{\\\"match_id\\\": 8461956309}\"))\n# ]\n</code></pre>"}]}