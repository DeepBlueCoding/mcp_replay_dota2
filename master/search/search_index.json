{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MCP Dota 2 Match Analysis Server","text":"AI Summary <p>MCP server for Dota 2 match analysis. Tools (LLM calls these): <code>get_match_heroes</code>, <code>get_match_players</code>, <code>get_hero_deaths</code>, <code>get_combat_log</code>, <code>get_fight_combat_log</code>, <code>get_item_purchases</code>, <code>get_objective_kills</code>, <code>get_match_timeline</code>, <code>get_stats_at_minute</code>, <code>get_courier_kills</code>, plus pro scene tools. Resources (static context): <code>dota2://heroes/all</code>, <code>dota2://map</code>, <code>dota2://pro/players</code>, <code>dota2://pro/teams</code>. Connects to Claude Desktop, Claude Code, LangChain, LangGraph, CrewAI, or direct API integration.</p> <p>A Model Context Protocol (MCP) server that gives LLMs the ability to analyze Dota 2 matches by parsing replay files and querying the OpenDota API.</p>"},{"location":"#what-this-does","title":"What This Does","text":"<p>This server exposes tools and resources that an LLM can call to answer questions about Dota 2 matches:</p> <ul> <li>\"Why did we lose the teamfight at 25 minutes?\"</li> <li>\"How did the enemy Anti-Mage get such a fast Battle Fury?\"</li> <li>\"When did Roshan die and who took the Aegis?\"</li> <li>\"Show me what happened when I died at minute 12\"</li> </ul> <p>The LLM reads the replay data and provides analysis based on actual game events, not guesswork.</p>"},{"location":"#how-mcp-works","title":"How MCP Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   LLM Client    \u2502 \u2500\u2500MCP\u2500\u2500 \u2502   This Server   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25b8 \u2502  Replay Parser  \u2502\n\u2502 (Claude, GPT)   \u2502         \u2502                 \u2502         \u2502  OpenDota API   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                           \u2502\n         \u2502   \"Analyze match 123\"     \u2502\n         \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b8\u2502\n         \u2502                           \u2502\n         \u2502                           \u2502\u2500\u2500 calls get_hero_deaths(123)\n         \u2502                           \u2502\u2500\u2500 calls get_combat_log(123, ...)\n         \u2502                           \u2502\u2500\u2500 calls get_objective_kills(123)\n         \u2502                           \u2502\n         \u2502   structured JSON data    \u2502\n         \u2502 \u25c2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n         \u2502                           \u2502\n         \u25bc                           \u25bc\n   LLM synthesizes response: \"The fight was lost because...\"\n</code></pre> <p>Resources = Static data the LLM can reference (hero list, map positions) Tools = Functions the LLM can call with parameters (get deaths, get combat log)</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-install","title":"1. Install","text":"<pre><code>git clone https://github.com/DeepBlueCoding/mcp_replay_dota2.git\ncd mcp_replay_dota2\nuv sync\n</code></pre>"},{"location":"#2-connect-to-your-llm","title":"2. Connect to Your LLM","text":"<p>See Integrations for setup with:</p> <ul> <li>Claude Desktop</li> <li>Claude Code CLI</li> <li>OpenAI + LangChain</li> <li>Custom Python clients</li> </ul>"},{"location":"#3-ask-questions","title":"3. Ask Questions","text":"<p>Once connected, just ask naturally:</p> <p>\"Analyze match 8461956309. Why did Radiant lose?\"</p> <p>The LLM will automatically call the appropriate tools and synthesize an analysis.</p>"},{"location":"#available-tools","title":"Available Tools","text":""},{"location":"#match-analysis","title":"Match Analysis","text":"Tool What It Does <code>download_replay</code> Pre-cache replay file (call first for new matches) <code>get_match_info</code> Match metadata (teams, players, winner) <code>get_match_heroes</code> 10 heroes in match with KDA, items, stats <code>get_match_players</code> 10 players with names and hero assignments <code>get_match_draft</code> Complete draft order (bans/picks) <code>get_match_timeline</code> Net worth, XP, KDA over time <code>get_stats_at_minute</code> Snapshot of all players at a specific minute <code>get_hero_deaths</code> All deaths with killer, victim, ability used <code>get_combat_log</code> Damage events, abilities, modifiers in a time range <code>get_fight_combat_log</code> Auto-detects fight boundaries around a death <code>get_item_purchases</code> When each item was bought <code>get_objective_kills</code> Roshan, towers, barracks timings <code>get_courier_kills</code> Courier snipes with position <code>get_rune_pickups</code> Rune pickups by hero"},{"location":"#pro-scene","title":"Pro Scene","text":"Tool What It Does <code>search_pro_player</code> Fuzzy search for pro players <code>search_team</code> Fuzzy search for teams <code>get_pro_player</code> Get player details by account ID <code>get_team</code> Get team details + roster <code>get_team_matches</code> Team match history with series grouping <code>get_leagues</code> All leagues/tournaments <code>get_pro_matches</code> Recent pro matches with series grouping <code>get_league_matches</code> Matches from a specific league"},{"location":"#available-resources","title":"Available Resources","text":"<p>Static reference data (user attaches to context):</p> URI Data <code>dota2://heroes/all</code> All 124 heroes with attributes <code>dota2://map</code> Tower, camp, rune, landmark positions <code>dota2://pro/players</code> All pro players <code>dota2://pro/teams</code> All pro teams <p>Match-specific data uses tools</p> <p>For match heroes/players and detailed pro player/team info, use the corresponding tools (<code>get_match_heroes</code>, <code>get_match_players</code>, <code>get_pro_player</code>, <code>get_team</code>).</p>"},{"location":"#example-conversations","title":"Example Conversations","text":"<p>See Use Cases for detailed examples:</p> <ul> <li>Analyzing why a teamfight was lost</li> <li>Tracking a carry's item timings</li> <li>Understanding a gank that went wrong</li> <li>Comparing laning phase performance</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/","title":"Dota 2 Replay Parsing Architecture","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#overview","title":"Overview","text":"<p>This document describes the architecture for parsing Dota 2 replay files (.dem) and exposing match analysis via MCP tools. The architecture is split into two distinct layers:</p> <ol> <li>Services Layer: Business logic for replay parsing and match analysis (no MCP dependencies)</li> <li>MCP Layer: Thin wrapper exposing services via MCP tools/resources (no business logic)</li> </ol> <p>This separation allows the services to be reused in other systems (CLI tools, web APIs, etc.) without MCP dependencies.</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Design Principles</li> <li>Two-Layer Architecture</li> <li>Services Layer</li> <li>MCP Layer</li> <li>python-manta v2 Integration</li> <li>Data Models</li> <li>Cache Strategy</li> <li>Directory Structure</li> <li>Data Flow</li> <li>First Parse: Complete Data Extraction</li> </ol>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#core-principles","title":"Core Principles","text":"Principle Description Separation of Concerns Business logic in services, MCP logic in MCP layer Reusable Services Services have zero MCP dependencies, can be used anywhere Parse Once Single <code>Parser.parse()</code> call per replay via python-manta v2 Cache Everything Full <code>ParsedReplayData</code> stored persistently Thin MCP Layer MCP tools are simple wrappers, no business logic Data-Driven Logic Detection algorithms designed around python-manta v2 data"},{"location":"REPLAY_PARSING_ARCHITECTURE/#layer-rules","title":"Layer Rules","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP LAYER (src/mcp/)                                                   \u2502\n\u2502                                                                         \u2502\n\u2502  \u2713 MCP tool/resource definitions                                       \u2502\n\u2502  \u2713 Parameter validation for MCP                                        \u2502\n\u2502  \u2713 Response formatting for MCP                                         \u2502\n\u2502  \u2717 NO business logic                                                   \u2502\n\u2502  \u2717 NO direct python-manta calls                                        \u2502\n\u2502  \u2717 NO direct opendota-sdk calls                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  SERVICES LAYER (src/services/)                                         \u2502\n\u2502                                                                         \u2502\n\u2502  \u2713 All business logic                                                  \u2502\n\u2502  \u2713 python-manta integration                                            \u2502\n\u2502  \u2713 opendota-sdk integration                                            \u2502\n\u2502  \u2713 Caching logic                                                       \u2502\n\u2502  \u2713 Analysis/detection algorithms                                       \u2502\n\u2502  \u2717 NO MCP imports                                                      \u2502\n\u2502  \u2717 NO FastMCP dependencies                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#two-layer-architecture","title":"Two-Layer Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           MCP CLIENTS                                   \u2502\n\u2502                  (Claude, other MCP consumers)                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           MCP LAYER                                     \u2502\n\u2502                        src/mcp/                                         \u2502\n\u2502                                                                         \u2502\n\u2502   tools/                          resources/                            \u2502\n\u2502   \u251c\u2500\u2500 match_tools.py              \u251c\u2500\u2500 heroes_resource.py               \u2502\n\u2502   \u251c\u2500\u2500 combat_tools.py             \u251c\u2500\u2500 map_resource.py                  \u2502\n\u2502   \u251c\u2500\u2500 fight_tools.py              \u2514\u2500\u2500 items_resource.py                \u2502\n\u2502   \u251c\u2500\u2500 lane_tools.py                                                    \u2502\n\u2502   \u251c\u2500\u2500 jungle_tools.py             server.py (FastMCP setup)            \u2502\n\u2502   \u251c\u2500\u2500 objective_tools.py                                               \u2502\n\u2502   \u2514\u2500\u2500 timeline_tools.py                                                \u2502\n\u2502                                                                         \u2502\n\u2502   Only MCP-specific code: tool definitions, parameter validation,       \u2502\n\u2502   response formatting. NO business logic.                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 Calls\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         SERVICES LAYER                                  \u2502\n\u2502                        src/services/                                    \u2502\n\u2502                                                                         \u2502\n\u2502   replay/                         opendota/                             \u2502\n\u2502   \u251c\u2500\u2500 replay_service.py           \u251c\u2500\u2500 match_service.py                 \u2502\n\u2502   \u251c\u2500\u2500 combat_service.py           \u251c\u2500\u2500 player_service.py                \u2502\n\u2502   \u251c\u2500\u2500 fight_service.py            \u2514\u2500\u2500 hero_service.py                  \u2502\n\u2502   \u251c\u2500\u2500 lane_service.py                                                  \u2502\n\u2502   \u251c\u2500\u2500 jungle_service.py           cache/                               \u2502\n\u2502   \u251c\u2500\u2500 objective_service.py        \u251c\u2500\u2500 replay_cache.py                  \u2502\n\u2502   \u251c\u2500\u2500 vision_service.py           \u2514\u2500\u2500 api_cache.py                     \u2502\n\u2502   \u2514\u2500\u2500 timeline_service.py                                              \u2502\n\u2502                                                                         \u2502\n\u2502   analyzers/                      models/                               \u2502\n\u2502   \u251c\u2500\u2500 fight_detector.py           \u251c\u2500\u2500 replay_data.py                   \u2502\n\u2502   \u251c\u2500\u2500 lane_analyzer.py            \u251c\u2500\u2500 combat.py                        \u2502\n\u2502   \u251c\u2500\u2500 jungle_analyzer.py          \u251c\u2500\u2500 fights.py                        \u2502\n\u2502   \u251c\u2500\u2500 objective_analyzer.py       \u251c\u2500\u2500 lanes.py                         \u2502\n\u2502   \u2514\u2500\u2500 vision_analyzer.py          \u2514\u2500\u2500 ...                              \u2502\n\u2502                                                                         \u2502\n\u2502   All business logic. Zero MCP dependencies.                            \u2502\n\u2502   Can be imported and used by CLI, web API, tests, etc.                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 Uses\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      EXTERNAL DEPENDENCIES                              \u2502\n\u2502                                                                         \u2502\n\u2502   python-manta v2                 opendota-sdk                          \u2502\n\u2502   \u251c\u2500\u2500 Parser class                \u251c\u2500\u2500 OpenDotaClient                   \u2502\n\u2502   \u251c\u2500\u2500 parse() / run()             \u251c\u2500\u2500 get_match()                      \u2502\n\u2502   \u251c\u2500\u2500 Callbacks                   \u251c\u2500\u2500 get_player()                     \u2502\n\u2502   \u2514\u2500\u2500 seek() (Phase 3)            \u2514\u2500\u2500 get_heroes()                     \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#services-layer","title":"Services Layer","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#core-services","title":"Core Services","text":""},{"location":"REPLAY_PARSING_ARCHITECTURE/#replayservice","title":"ReplayService","text":"<p>Main entry point for replay data. Handles caching and orchestrates parsing.</p> <pre><code># src/services/replay/replay_service.py\n\nfrom python_manta import Parser\nfrom ..cache.replay_cache import ReplayCache\nfrom ..models.replay_data import ParsedReplayData\nfrom .analyzers import FightDetector, LaneAnalyzer, JungleAnalyzer\n\nclass ReplayService:\n    \"\"\"\n    Main service for replay data access.\n    Handles parsing, caching, and analysis orchestration.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def __init__(self, cache: ReplayCache):\n        self._cache = cache\n\n    def get_parsed_data(self, match_id: int) -&gt; ParsedReplayData:\n        \"\"\"\n        Get complete parsed data for a match.\n        Returns cached data if available, otherwise parses replay.\n        \"\"\"\n        # Check cache\n        cached = self._cache.get(match_id)\n        if cached:\n            return cached\n\n        # Download and parse\n        replay_path = self._download_replay(match_id)\n        data = self._parse_replay(replay_path, match_id)\n\n        # Cache and return\n        self._cache.set(match_id, data)\n        return data\n\n    def _parse_replay(self, path: str, match_id: int) -&gt; ParsedReplayData:\n        \"\"\"Single-pass parse using python-manta v2.\"\"\"\n\n        parser = Parser(path)\n\n        # Single parse, all data\n        result = parser.parse(\n            header=True,\n            game_info=True,\n            combat_log={\n                \"types\": [0, 1, 2, 3, 4, 5, 6, 11, 13],\n                \"max\": 100000,\n            },\n            entities={\n                \"interval\": 900,\n                \"classes\": [\"Hero\", \"Building\", \"Creep\", \"NeutralCreep\", \"Ward\"],\n            },\n            game_events=True,\n            modifiers=True,\n        )\n\n        # Run analyzers on raw data\n        fights, kills = FightDetector().analyze(\n            result.combat_log.entries,\n            result.entities.snapshots\n        )\n\n        lane_states, aggro_events = LaneAnalyzer().analyze(\n            result.entities.snapshots,\n            result.combat_log.entries\n        )\n\n        camp_pulls, camp_stacks = JungleAnalyzer().analyze(\n            result.entities.snapshots,\n            result.game_events.events\n        )\n\n        # Build complete data model\n        return ParsedReplayData(\n            match_id=match_id,\n            header=result.header,\n            game_info=result.game_info,\n            combat_log=result.combat_log.entries,\n            entity_snapshots=result.entities.snapshots,\n            game_events=result.game_events.events,\n            modifiers=result.modifiers.events,\n            fights=fights,\n            kills=kills,\n            lane_states=lane_states,\n            creep_aggro_events=aggro_events,\n            camp_pulls=camp_pulls,\n            camp_stacks=camp_stacks,\n        )\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#combatservice","title":"CombatService","text":"<p>Provides combat-related queries from parsed data.</p> <pre><code># src/services/replay/combat_service.py\n\nfrom typing import List, Optional\nfrom ..models.combat import Kill, CombatLogEntry\nfrom ..models.replay_data import ParsedReplayData\n\nclass CombatService:\n    \"\"\"\n    Service for combat data queries.\n    Operates on ParsedReplayData, no direct parsing.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_kills(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n        team: Optional[str] = None,\n    ) -&gt; List[Kill]:\n        \"\"\"Get kills, optionally filtered by hero or team.\"\"\"\n        kills = data.kills\n\n        if hero:\n            kills = [k for k in kills if k.killer == hero or k.victim == hero]\n\n        if team:\n            team_id = 2 if team == \"radiant\" else 3\n            kills = [k for k in kills if k.killer_team == team_id]\n\n        return kills\n\n    def get_hero_deaths(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[Kill]:\n        \"\"\"Get hero deaths.\"\"\"\n        deaths = data.kills\n\n        if hero:\n            deaths = [k for k in deaths if k.victim == hero]\n\n        return deaths\n\n    def get_damage_breakdown(\n        self,\n        data: ParsedReplayData,\n        kill_id: str,\n    ) -&gt; List[CombatLogEntry]:\n        \"\"\"Get damage events leading to a kill.\"\"\"\n        kill = data.get_kill_by_id(kill_id)\n        if not kill:\n            return []\n\n        # Find damage events in window before death\n        window_start = kill.game_time - 10.0\n        window_end = kill.game_time\n\n        return [\n            e for e in data.combat_log\n            if e.type == 0  # DAMAGE\n            and e.target_name == kill.victim\n            and window_start &lt;= e.game_time &lt;= window_end\n        ]\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#fightservice","title":"FightService","text":"<p>Provides fight-related queries.</p> <pre><code># src/services/replay/fight_service.py\n\nfrom typing import List, Optional\nfrom ..models.fights import Fight, Kill\nfrom ..models.replay_data import ParsedReplayData\n\nclass FightService:\n    \"\"\"\n    Service for fight data queries.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def list_fights(self, data: ParsedReplayData) -&gt; List[Fight]:\n        \"\"\"Get all fights in the match.\"\"\"\n        return data.fights\n\n    def get_fight(self, data: ParsedReplayData, fight_id: str) -&gt; Optional[Fight]:\n        \"\"\"Get a specific fight by ID.\"\"\"\n        return data.get_fight_by_id(fight_id)\n\n    def get_fight_kills(self, data: ParsedReplayData, fight_id: str) -&gt; List[Kill]:\n        \"\"\"Get all kills in a specific fight.\"\"\"\n        return data.get_kills_for_fight(fight_id)\n\n    def get_teamfights(self, data: ParsedReplayData, min_kills: int = 3) -&gt; List[Fight]:\n        \"\"\"Get fights with at least min_kills deaths.\"\"\"\n        return [f for f in data.fights if f.radiant_kills + f.dire_kills &gt;= min_kills]\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#laneservice","title":"LaneService","text":"<p>Provides laning phase queries.</p> <pre><code># src/services/replay/lane_service.py\n\nfrom typing import List, Optional\nfrom ..models.lanes import LaneState, CreepAggroEvent\nfrom ..models.replay_data import ParsedReplayData\n\nclass LaneService:\n    \"\"\"\n    Service for laning phase data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_lane_state(\n        self,\n        data: ParsedReplayData,\n        game_time: float,\n        lane: str,\n    ) -&gt; Optional[LaneState]:\n        \"\"\"Get lane state at specific time.\"\"\"\n        return data.get_lane_state_at_time(game_time, lane)\n\n    def get_lane_equilibrium_timeline(\n        self,\n        data: ParsedReplayData,\n        lane: str,\n        start_time: float = 0,\n        end_time: float = 600,  # First 10 minutes\n    ) -&gt; List[LaneState]:\n        \"\"\"Get lane equilibrium over time.\"\"\"\n        return [\n            s for s in data.lane_states\n            if s.lane == lane\n            and start_time &lt;= s.game_time &lt;= end_time\n        ]\n\n    def get_creep_aggro_events(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[CreepAggroEvent]:\n        \"\"\"Get creep aggro manipulation events.\"\"\"\n        events = data.creep_aggro_events\n\n        if hero:\n            events = [e for e in events if e.hero == hero]\n\n        return events\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#jungleservice","title":"JungleService","text":"<p>Provides jungle-related queries.</p> <pre><code># src/services/replay/jungle_service.py\n\nfrom typing import List, Optional\nfrom ..models.jungle import CampPull, CampStack\nfrom ..models.replay_data import ParsedReplayData\n\nclass JungleService:\n    \"\"\"\n    Service for jungle data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def get_camp_stacks(\n        self,\n        data: ParsedReplayData,\n        team: Optional[str] = None,\n    ) -&gt; List[CampStack]:\n        \"\"\"Get all camp stacks.\"\"\"\n        stacks = data.camp_stacks\n\n        if team:\n            team_id = 2 if team == \"radiant\" else 3\n            stacks = [s for s in stacks if s.stacker_team == team_id]\n\n        return stacks\n\n    def get_camp_pulls(\n        self,\n        data: ParsedReplayData,\n        hero: Optional[str] = None,\n    ) -&gt; List[CampPull]:\n        \"\"\"Get all camp pulls.\"\"\"\n        pulls = data.camp_pulls\n\n        if hero:\n            pulls = [p for p in pulls if p.puller_hero == hero]\n\n        return pulls\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#analyzers","title":"Analyzers","text":"<p>Analyzers process raw data to detect complex events. They run once during parsing.</p> <pre><code># src/services/analyzers/fight_detector.py\n\nfrom typing import List, Tuple\nfrom ..models.fights import Fight, Kill\nfrom ..models.combat import CombatLogEntry\nfrom ..models.entities import EntitySnapshot\n\nclass FightDetector:\n    \"\"\"\n    Detects and groups fights from combat data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    FIGHT_WINDOW = 15.0  # seconds\n\n    def analyze(\n        self,\n        combat_log: List[CombatLogEntry],\n        entity_snapshots: List[EntitySnapshot],\n    ) -&gt; Tuple[List[Fight], List[Kill]]:\n        \"\"\"\n        Analyze combat log to detect fights.\n\n        Returns:\n            fights: Deduplicated fight objects\n            kills: All kills with fight_id references\n        \"\"\"\n        # Extract hero deaths\n        deaths = [e for e in combat_log if e.type == 4 and self._is_hero(e.target_name)]\n\n        # Group into fights\n        fights = []\n        kills = []\n        current_fight_deaths = []\n\n        for death in sorted(deaths, key=lambda d: d.game_time):\n            if not current_fight_deaths:\n                current_fight_deaths.append(death)\n            elif death.game_time - current_fight_deaths[-1].game_time &lt;= self.FIGHT_WINDOW:\n                current_fight_deaths.append(death)\n            else:\n                # Finalize previous fight\n                fight, fight_kills = self._create_fight(current_fight_deaths, combat_log)\n                fights.append(fight)\n                kills.extend(fight_kills)\n                current_fight_deaths = [death]\n\n        # Handle last fight\n        if current_fight_deaths:\n            fight, fight_kills = self._create_fight(current_fight_deaths, combat_log)\n            fights.append(fight)\n            kills.extend(fight_kills)\n\n        return fights, kills\n</code></pre> <pre><code># src/services/analyzers/lane_analyzer.py\n\nfrom typing import List, Tuple\nfrom ..models.lanes import LaneState, CreepAggroEvent\nfrom ..models.entities import EntitySnapshot\nfrom ..models.combat import CombatLogEntry\n\nclass LaneAnalyzer:\n    \"\"\"\n    Analyzes lane equilibrium and creep manipulation.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def analyze(\n        self,\n        entity_snapshots: List[EntitySnapshot],\n        combat_log: List[CombatLogEntry],\n    ) -&gt; Tuple[List[LaneState], List[CreepAggroEvent]]:\n        \"\"\"\n        Analyze entity snapshots for lane states.\n\n        Returns:\n            lane_states: Lane equilibrium at each snapshot\n            aggro_events: Detected creep aggro manipulation\n        \"\"\"\n        lane_states = []\n        aggro_events = []\n\n        for snapshot in entity_snapshots:\n            # Only analyze laning phase (first 15 minutes)\n            if snapshot.game_time &gt; 900:\n                continue\n\n            for lane in [\"top\", \"mid\", \"bot\"]:\n                state = self._calculate_lane_state(snapshot, lane)\n                lane_states.append(state)\n\n        # Detect aggro manipulation from creep target changes\n        aggro_events = self._detect_aggro_events(entity_snapshots)\n\n        return lane_states, aggro_events\n</code></pre> <pre><code># src/services/analyzers/jungle_analyzer.py\n\nfrom typing import List, Tuple\nfrom ..models.jungle import CampPull, CampStack\nfrom ..models.entities import EntitySnapshot\nfrom ..models.events import GameEvent\n\nclass JungleAnalyzer:\n    \"\"\"\n    Analyzes jungle activity: pulls, stacks.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    def analyze(\n        self,\n        entity_snapshots: List[EntitySnapshot],\n        game_events: List[GameEvent],\n    ) -&gt; Tuple[List[CampPull], List[CampStack]]:\n        \"\"\"\n        Analyze jungle activity.\n\n        Returns:\n            pulls: Detected camp pulls\n            stacks: Detected camp stacks\n        \"\"\"\n        # Detection logic depends on what data python-manta v2 provides\n        # May use game events like \"dota_camp_stacked\" if available\n        # Or detect from entity position/state changes\n\n        pulls = self._detect_pulls(entity_snapshots, game_events)\n        stacks = self._detect_stacks(entity_snapshots, game_events)\n\n        return pulls, stacks\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#mcp-layer","title":"MCP Layer","text":"<p>The MCP layer is a thin wrapper. Each tool: 1. Validates MCP parameters 2. Calls the appropriate service 3. Formats the response for MCP</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#tool-definitions","title":"Tool Definitions","text":"<pre><code># src/mcp/tools/combat_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.combat_service import CombatService\n\ndef register_combat_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register combat-related MCP tools.\"\"\"\n\n    combat_service = CombatService()\n\n    @mcp.tool()\n    async def get_hero_deaths(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get hero deaths in a match.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n\n        Returns:\n            List of hero deaths with killer, position, and context\n        \"\"\"\n        # Get parsed data (cached or fresh parse)\n        data = await replay_service.get_parsed_data(match_id)\n\n        # Call service (business logic)\n        deaths = combat_service.get_hero_deaths(data, hero)\n\n        # Format for MCP response\n        return {\n            \"match_id\": match_id,\n            \"count\": len(deaths),\n            \"deaths\": [_format_kill(d) for d in deaths],\n        }\n\n    @mcp.tool()\n    async def get_kills(\n        match_id: int,\n        killer: str | None = None,\n        team: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get kills in a match.\n\n        Args:\n            match_id: The match ID\n            killer: Optional killer hero name\n            team: Optional team filter (\"radiant\" or \"dire\")\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        kills = combat_service.get_kills(data, killer, team)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(kills),\n            \"kills\": [_format_kill(k) for k in kills],\n        }\n\n\ndef _format_kill(kill) -&gt; dict:\n    \"\"\"Format a Kill object for MCP response.\"\"\"\n    return {\n        \"kill_id\": kill.kill_id,\n        \"fight_id\": kill.fight_id,\n        \"game_time\": kill.game_time,\n        \"game_time_str\": _format_time(kill.game_time),\n        \"victim\": kill.victim,\n        \"killer\": kill.killer,\n        \"assisters\": kill.assisters,\n        \"position\": {\"x\": kill.position.x, \"y\": kill.position.y},\n        \"is_teamfight\": kill.is_teamfight_kill,\n    }\n</code></pre> <pre><code># src/mcp/tools/fight_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.fight_service import FightService\n\ndef register_fight_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register fight-related MCP tools.\"\"\"\n\n    fight_service = FightService()\n\n    @mcp.tool()\n    async def list_fights(match_id: int) -&gt; dict:\n        \"\"\"\n        List all fights in a match.\n\n        Args:\n            match_id: The match ID\n\n        Returns:\n            List of fights with participants, outcome, and kill references\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fights = fight_service.list_fights(data)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(fights),\n            \"fights\": [_format_fight_summary(f) for f in fights],\n        }\n\n    @mcp.tool()\n    async def get_fight(match_id: int, fight_id: str) -&gt; dict:\n        \"\"\"\n        Get details of a specific fight.\n\n        Args:\n            match_id: The match ID\n            fight_id: The fight ID (from list_fights)\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fight = fight_service.get_fight(data, fight_id)\n\n        if not fight:\n            return {\"error\": f\"Fight {fight_id} not found\"}\n\n        kills = fight_service.get_fight_kills(data, fight_id)\n\n        return {\n            \"match_id\": match_id,\n            \"fight\": _format_fight_detail(fight),\n            \"kills\": [_format_kill(k) for k in kills],\n        }\n\n    @mcp.tool()\n    async def get_teamfights(match_id: int, min_kills: int = 3) -&gt; dict:\n        \"\"\"\n        Get major teamfights (3+ kills by default).\n\n        Args:\n            match_id: The match ID\n            min_kills: Minimum kills to qualify as teamfight\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        fights = fight_service.get_teamfights(data, min_kills)\n\n        return {\n            \"match_id\": match_id,\n            \"min_kills\": min_kills,\n            \"count\": len(fights),\n            \"teamfights\": [_format_fight_summary(f) for f in fights],\n        }\n</code></pre> <pre><code># src/mcp/tools/lane_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.lane_service import LaneService\n\ndef register_lane_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register laning phase MCP tools.\"\"\"\n\n    lane_service = LaneService()\n\n    @mcp.tool()\n    async def get_lane_equilibrium(\n        match_id: int,\n        lane: str,\n        minute: int,\n    ) -&gt; dict:\n        \"\"\"\n        Get lane equilibrium at a specific minute.\n\n        Args:\n            match_id: The match ID\n            lane: Lane name (\"top\", \"mid\", \"bot\")\n            minute: Game minute\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        state = lane_service.get_lane_state(data, minute * 60.0, lane)\n\n        if not state:\n            return {\"error\": f\"No lane data at minute {minute}\"}\n\n        return {\n            \"match_id\": match_id,\n            \"lane\": lane,\n            \"minute\": minute,\n            \"state\": _format_lane_state(state),\n        }\n\n    @mcp.tool()\n    async def get_creep_aggro_events(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get creep aggro manipulation events.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        events = lane_service.get_creep_aggro_events(data, hero)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(events),\n            \"events\": [_format_aggro_event(e) for e in events],\n        }\n</code></pre> <pre><code># src/mcp/tools/jungle_tools.py\n\nfrom fastmcp import FastMCP\nfrom ...services.replay.replay_service import ReplayService\nfrom ...services.replay.jungle_service import JungleService\n\ndef register_jungle_tools(mcp: FastMCP, replay_service: ReplayService):\n    \"\"\"Register jungle MCP tools.\"\"\"\n\n    jungle_service = JungleService()\n\n    @mcp.tool()\n    async def get_camp_stacks(\n        match_id: int,\n        team: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get camp stacking events.\n\n        Args:\n            match_id: The match ID\n            team: Optional team filter (\"radiant\" or \"dire\")\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        stacks = jungle_service.get_camp_stacks(data, team)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(stacks),\n            \"stacks\": [_format_camp_stack(s) for s in stacks],\n        }\n\n    @mcp.tool()\n    async def get_camp_pulls(\n        match_id: int,\n        hero: str | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get camp pull events.\n\n        Args:\n            match_id: The match ID\n            hero: Optional hero name to filter\n        \"\"\"\n        data = await replay_service.get_parsed_data(match_id)\n        pulls = jungle_service.get_camp_pulls(data, hero)\n\n        return {\n            \"match_id\": match_id,\n            \"count\": len(pulls),\n            \"pulls\": [_format_camp_pull(p) for p in pulls],\n        }\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#mcp-server-setup","title":"MCP Server Setup","text":"<pre><code># src/mcp/server.py\n\nfrom fastmcp import FastMCP\nfrom ..services.replay.replay_service import ReplayService\nfrom ..services.cache.replay_cache import ReplayCache\nfrom .tools.combat_tools import register_combat_tools\nfrom .tools.fight_tools import register_fight_tools\nfrom .tools.lane_tools import register_lane_tools\nfrom .tools.jungle_tools import register_jungle_tools\nfrom .tools.match_tools import register_match_tools\nfrom .tools.objective_tools import register_objective_tools\nfrom .tools.timeline_tools import register_timeline_tools\nfrom .resources.heroes_resource import register_heroes_resources\nfrom .resources.map_resource import register_map_resources\n\ndef create_mcp_server() -&gt; FastMCP:\n    \"\"\"Create and configure the MCP server.\"\"\"\n\n    mcp = FastMCP(\"Dota 2 Match Analysis\")\n\n    # Initialize services (shared across tools)\n    cache = ReplayCache()\n    replay_service = ReplayService(cache)\n\n    # Register all tools\n    register_match_tools(mcp, replay_service)\n    register_combat_tools(mcp, replay_service)\n    register_fight_tools(mcp, replay_service)\n    register_lane_tools(mcp, replay_service)\n    register_jungle_tools(mcp, replay_service)\n    register_objective_tools(mcp, replay_service)\n    register_timeline_tools(mcp, replay_service)\n\n    # Register resources\n    register_heroes_resources(mcp)\n    register_map_resources(mcp)\n\n    return mcp\n\n# Entry point\nmcp = create_mcp_server()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#python-manta-v2-integration","title":"python-manta v2 Integration","text":"<p>The services layer uses python-manta v2's single-pass API:</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#batch-mode-primary","title":"Batch Mode (Primary)","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(replay_path)\n\n# Single parse, all data types\nresult = parser.parse(\n    header=True,\n    game_info=True,\n    combat_log={\n        \"types\": [0, 1, 2, 3, 4, 5, 6, 11, 13],\n        \"max\": 100000,\n    },\n    entities={\n        \"interval\": 900,  # 30-second snapshots\n        \"classes\": [\"Hero\", \"Building\", \"Creep\", \"NeutralCreep\", \"Ward\"],\n    },\n    game_events=True,\n    modifiers=True,\n)\n\n# All data available from single parse\nresult.header.map_name\nresult.game_info.match_id\nresult.combat_log.entries\nresult.entities.snapshots\nresult.game_events.events\nresult.modifiers.events\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#callback-mode-alternative","title":"Callback Mode (Alternative)","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(replay_path)\n\n# Register callbacks\n@parser.on_combat_log\ndef handle_combat(entry):\n    accumulator.add(entry)\n\n@parser.on_entity(class_filter=[\"Hero\", \"Creep\"])\ndef handle_entity(entity, tick):\n    tracker.update(entity, tick)\n\n# Single parse, callbacks fire\nparser.run()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#dense-seek-phase-3","title":"Dense Seek (Phase 3)","text":"<p>For detailed fight analysis:</p> <pre><code># Build index once\nparser = Parser(replay_path)\nparser.build_index()\n\n# Seek to specific range\nparser.seek(tick=45000)\ndense_result = parser.parse(\n    start_tick=45000,\n    end_tick=46000,\n    entities={\"interval\": 1},  # Every tick\n)\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#data-models","title":"Data Models","text":"<p>All models are Pydantic classes in <code>src/services/models/</code>.</p> <pre><code># src/services/models/replay_data.py\n\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional, Tuple\n\n@dataclass\nclass ParsedReplayData:\n    \"\"\"Complete extraction from a replay file.\"\"\"\n\n    # Metadata\n    match_id: int\n    parse_timestamp: float\n    parser_version: str\n\n    # From python-manta v2\n    header: HeaderInfo\n    game_info: GameInfo\n    combat_log: List[CombatLogEntry]\n    entity_snapshots: List[EntitySnapshot]\n    game_events: List[GameEvent]\n    modifiers: List[ModifierEvent]\n\n    # Indexed data\n    hero_positions: Dict[int, Dict[str, Position]]\n    tick_time_map: List[Tuple[int, float]]\n\n    # Derived data (from analyzers)\n    fights: List[Fight]\n    kills: List[Kill]\n    lane_states: List[LaneState]\n    creep_aggro_events: List[CreepAggroEvent]\n    camp_pulls: List[CampPull]\n    camp_stacks: List[CampStack]\n    objectives: List[ObjectiveEvent]\n    ward_events: List[WardEvent]\n\n    # Indexes for fast lookup\n    _fight_index: Dict[str, Fight] = None\n    _kill_index: Dict[str, Kill] = None\n\n    def get_fight_by_id(self, fight_id: str) -&gt; Optional[Fight]:\n        if self._fight_index is None:\n            self._fight_index = {f.fight_id: f for f in self.fights}\n        return self._fight_index.get(fight_id)\n\n    def get_kill_by_id(self, kill_id: str) -&gt; Optional[Kill]:\n        if self._kill_index is None:\n            self._kill_index = {k.kill_id: k for k in self.kills}\n        return self._kill_index.get(kill_id)\n\n    def get_kills_for_fight(self, fight_id: str) -&gt; List[Kill]:\n        return [k for k in self.kills if k.fight_id == fight_id]\n\n    def get_lane_state_at_time(self, game_time: float, lane: str) -&gt; Optional[LaneState]:\n        # Find nearest snapshot\n        for state in self.lane_states:\n            if state.lane == lane and abs(state.game_time - game_time) &lt; 30:\n                return state\n        return None\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#cache-strategy","title":"Cache Strategy","text":"<pre><code># src/services/cache/replay_cache.py\n\nfrom pathlib import Path\nfrom diskcache import Cache\nfrom ..models.replay_data import ParsedReplayData\n\nclass ReplayCache:\n    \"\"\"\n    Disk-based cache for parsed replay data.\n\n    NO MCP DEPENDENCIES.\n    \"\"\"\n\n    CACHE_DIR = Path.home() / \".cache/mcp_dota2/parsed_replays\"\n    PRIMARY_TTL = 604800  # 7 days\n    SIZE_LIMIT = 5 * 1024**3  # 5 GB\n\n    def __init__(self):\n        self._cache = Cache(\n            directory=str(self.CACHE_DIR),\n            size_limit=self.SIZE_LIMIT,\n        )\n\n    def get(self, match_id: int) -&gt; Optional[ParsedReplayData]:\n        \"\"\"Get cached data if available.\"\"\"\n        key = f\"replay_{match_id}\"\n        data = self._cache.get(key)\n        if data:\n            self._cache.touch(key, expire=self.PRIMARY_TTL)\n            return self._deserialize(data)\n        return None\n\n    def set(self, match_id: int, data: ParsedReplayData) -&gt; None:\n        \"\"\"Cache parsed data.\"\"\"\n        key = f\"replay_{match_id}\"\n        self._cache.set(key, self._serialize(data), expire=self.PRIMARY_TTL)\n\n    def clear_expired(self) -&gt; int:\n        \"\"\"Remove expired entries.\"\"\"\n        return self._cache.expire()\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#directory-structure","title":"Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 mcp/                              # MCP Layer (thin wrapper)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 server.py                     # FastMCP setup, tool registration\n\u2502   \u251c\u2500\u2500 tools/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 match_tools.py            # get_match_info, get_draft, etc.\n\u2502   \u2502   \u251c\u2500\u2500 combat_tools.py           # get_kills, get_hero_deaths, etc.\n\u2502   \u2502   \u251c\u2500\u2500 fight_tools.py            # list_fights, get_fight, etc.\n\u2502   \u2502   \u251c\u2500\u2500 lane_tools.py             # get_lane_equilibrium, get_aggro_events\n\u2502   \u2502   \u251c\u2500\u2500 jungle_tools.py           # get_camp_stacks, get_camp_pulls\n\u2502   \u2502   \u251c\u2500\u2500 objective_tools.py        # get_roshan_kills, get_tower_kills\n\u2502   \u2502   \u2514\u2500\u2500 timeline_tools.py         # get_timeline, get_stats_at_minute\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 heroes_resource.py        # Hero data resources\n\u2502       \u2514\u2500\u2500 map_resource.py           # Map data resources\n\u2502\n\u251c\u2500\u2500 services/                         # Services Layer (business logic)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 replay/                       # Replay parsing services\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 replay_service.py         # Main entry, orchestrates parsing\n\u2502   \u2502   \u251c\u2500\u2500 combat_service.py         # Combat queries\n\u2502   \u2502   \u251c\u2500\u2500 fight_service.py          # Fight queries\n\u2502   \u2502   \u251c\u2500\u2500 lane_service.py           # Lane queries\n\u2502   \u2502   \u251c\u2500\u2500 jungle_service.py         # Jungle queries\n\u2502   \u2502   \u251c\u2500\u2500 objective_service.py      # Objective queries\n\u2502   \u2502   \u251c\u2500\u2500 vision_service.py         # Ward/smoke queries\n\u2502   \u2502   \u2514\u2500\u2500 timeline_service.py       # Timeline queries\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 opendota/                     # OpenDota API services\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 match_service.py          # Match data from API\n\u2502   \u2502   \u251c\u2500\u2500 player_service.py         # Player data\n\u2502   \u2502   \u2514\u2500\u2500 hero_service.py           # Hero metadata\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 analyzers/                    # Post-parse analyzers\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 fight_detector.py         # Fight detection\n\u2502   \u2502   \u251c\u2500\u2500 lane_analyzer.py          # Lane equilibrium\n\u2502   \u2502   \u251c\u2500\u2500 jungle_analyzer.py        # Pulls, stacks\n\u2502   \u2502   \u251c\u2500\u2500 objective_analyzer.py     # Roshan, towers\n\u2502   \u2502   \u2514\u2500\u2500 vision_analyzer.py        # Wards, smokes\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 cache/                        # Caching\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 replay_cache.py           # Replay data cache\n\u2502   \u2502   \u2514\u2500\u2500 api_cache.py              # OpenDota API cache\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 models/                       # Data models (Pydantic)\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 replay_data.py            # ParsedReplayData\n\u2502       \u251c\u2500\u2500 combat.py                 # CombatLogEntry, DamageSource\n\u2502       \u251c\u2500\u2500 fights.py                 # Fight, Kill\n\u2502       \u251c\u2500\u2500 lanes.py                  # LaneState, CreepAggroEvent\n\u2502       \u251c\u2500\u2500 jungle.py                 # CampPull, CampStack\n\u2502       \u251c\u2500\u2500 objectives.py             # ObjectiveEvent\n\u2502       \u251c\u2500\u2500 vision.py                 # WardEvent, SmokeEvent\n\u2502       \u251c\u2500\u2500 entities.py               # EntitySnapshot, HeroState\n\u2502       \u2514\u2500\u2500 common.py                 # Position, TimeRange, etc.\n\u2502\n\u2514\u2500\u2500 __init__.py\n\n# Entry point\ndota_match_mcp_server.py              # Imports and runs src/mcp/server.py\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP Client calls: get_fight(match_id=123, fight_id=\"fight_45000\")     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MCP LAYER: src/mcp/tools/fight_tools.py                               \u2502\n\u2502                                                                         \u2502\n\u2502  @mcp.tool()                                                           \u2502\n\u2502  async def get_fight(match_id: int, fight_id: str):                    \u2502\n\u2502      data = await replay_service.get_parsed_data(match_id)  \u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502      fight = fight_service.get_fight(data, fight_id)              \u2502    \u2502\n\u2502      return _format_fight(fight)                                  \u2502    \u2502\n\u2502                                                                   \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2518\n                                                                    \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  SERVICES LAYER: src/services/replay/replay_service.py                 \u2502\n\u2502                                                                         \u2502\n\u2502  def get_parsed_data(match_id):                                        \u2502\n\u2502      # Check cache                                                     \u2502\n\u2502      cached = cache.get(match_id)  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502      if cached: return cached                           \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Parse with python-manta v2 (single pass)         \u2502              \u2502\n\u2502      result = Parser(path).parse(...)                   \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Run analyzers                                    \u2502              \u2502\n\u2502      fights, kills = FightDetector().analyze(...)       \u2502              \u2502\n\u2502      lane_states = LaneAnalyzer().analyze(...)          \u2502              \u2502\n\u2502                                                         \u2502              \u2502\n\u2502      # Cache and return                                 \u2502              \u2502\n\u2502      cache.set(match_id, data)                          \u2502              \u2502\n\u2502      return data                                        \u2502              \u2502\n\u2502                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                             \u2502\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                          \u2502                                     \u2502\n                    CACHE HIT                              CACHE MISS\n                          \u2502                                     \u2502\n                          \u25bc                                     \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Return cached    \u2502              \u2502  python-manta v2      \u2502\n              \u2502  ParsedReplayData \u2502              \u2502  Parser(path).parse() \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502  Single-pass parsing  \u2502\n                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#first-parse-complete-data-extraction","title":"First Parse: Complete Data Extraction","text":"<p>During first parse, extract EVERYTHING:</p>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#raw-data-from-python-manta-v2","title":"Raw Data (from python-manta v2)","text":"<ul> <li>[ ] Header info</li> <li>[ ] Game info (draft, teams, result)</li> <li>[ ] Combat log (all types: damage, heal, death, ability, item, purchase)</li> <li>[ ] Entity snapshots (heroes, buildings, creeps, neutrals, wards)</li> <li>[ ] Game events (all dota_* events)</li> <li>[ ] Modifiers (buffs/debuffs)</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#derived-data-from-analyzers","title":"Derived Data (from analyzers)","text":"<ul> <li>[ ] Fights (grouped, deduplicated)</li> <li>[ ] Kills (with fight references)</li> <li>[ ] Lane states (equilibrium at intervals)</li> <li>[ ] Creep aggro events</li> <li>[ ] Camp pulls</li> <li>[ ] Camp stacks</li> <li>[ ] Objective events (Roshan, towers, barracks)</li> <li>[ ] Ward events</li> <li>[ ] Smoke events</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#indexed-data-for-fast-lookup","title":"Indexed Data (for fast lookup)","text":"<ul> <li>[ ] Hero positions by tick</li> <li>[ ] Tick \u2194 game time mapping</li> <li>[ ] Fight index by ID</li> <li>[ ] Kill index by ID</li> </ul>"},{"location":"REPLAY_PARSING_ARCHITECTURE/#summary","title":"Summary","text":"Layer Location Responsibility Dependencies MCP <code>src/mcp/</code> Tool definitions, parameter validation, response formatting FastMCP, Services Services <code>src/services/</code> Business logic, parsing, caching, analysis python-manta, opendota-sdk Models <code>src/services/models/</code> Data structures (Pydantic) None <p>This separation allows: - Services can be used in CLI tools, web APIs, tests without MCP - MCP layer stays thin and focused on MCP concerns - Easy to add new interfaces (REST API, GraphQL) using same services</p>"},{"location":"changelog/","title":"Changelog","text":"\ud83e\udd16 AI Summary <p>Project changelog following Keep a Changelog format. Current features: MCP resources (heroes, map, match data), MCP tools (deaths, combat log, fights, items, objectives, timeline), map geometry data, combat log parsing with fight detection, hero fuzzy search.</p> <p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#pro-scene-features","title":"Pro Scene Features","text":"<ul> <li>Pro scene resources: <code>dota2://pro/players</code>, <code>dota2://pro/teams</code></li> <li>Pro scene tools: <code>search_pro_player</code>, <code>search_team</code>, <code>get_pro_player</code>, <code>get_pro_player_by_name</code>, <code>get_team</code>, <code>get_team_by_name</code>, <code>get_team_matches</code>, <code>get_leagues</code>, <code>get_pro_matches</code>, <code>get_league_matches</code></li> <li>Series grouping for pro matches (Bo1/Bo3/Bo5 detection, winner calculation)</li> <li>Fuzzy search for players and teams with alias support</li> </ul>"},{"location":"changelog/#match-analysis-tools","title":"Match Analysis Tools","text":"<ul> <li><code>get_match_heroes</code> - Get 10 heroes in match with KDA, items, stats</li> <li><code>get_match_players</code> - Get 10 players with names and hero assignments</li> <li><code>get_rune_pickups</code> - Track rune pickups by hero</li> <li><code>get_match_draft</code> - Complete draft order for Captains Mode</li> <li><code>get_match_info</code> - Match metadata (teams, players, winner, duration)</li> <li><code>download_replay</code> - Pre-cache replay files before analysis</li> </ul>"},{"location":"changelog/#core-features","title":"Core Features","text":"<ul> <li>MCP Resources: <code>dota2://heroes/all</code>, <code>dota2://map</code>, <code>dota2://pro/players</code>, <code>dota2://pro/teams</code></li> <li>MCP Tools: <code>get_match_timeline</code>, <code>get_stats_at_minute</code>, <code>get_hero_deaths</code>, <code>get_combat_log</code>, <code>get_fight_combat_log</code>, <code>get_item_purchases</code>, <code>get_courier_kills</code>, <code>get_objective_kills</code></li> <li>Map data with tower, barracks, neutral camp, rune, and landmark positions</li> <li>Combat log parsing with fight detection</li> <li>Timeline parsing from replay metadata</li> <li>Hero fuzzy search for name matching</li> <li>MkDocs documentation with Material theme</li> <li>AI Summary sections on all documentation pages</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Refactored parameterized resources to tools following MCP design principles:</li> <li>Removed <code>dota2://match/{id}/heroes</code> \u2192 use <code>get_match_heroes(match_id)</code> tool</li> <li>Removed <code>dota2://match/{id}/players</code> \u2192 use <code>get_match_players(match_id)</code> tool</li> <li>Removed <code>dota2://pro/player/{id}</code> \u2192 use <code>get_pro_player(account_id)</code> tool</li> <li>Removed <code>dota2://pro/team/{id}</code> \u2192 use <code>get_team(team_id)</code> tool</li> <li>Resources now only contain static reference data (all heroes, map, all pro players/teams)</li> <li>Tools are used for dynamic data that requires computation or parameters</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>N/A</li> </ul>"},{"location":"api/resources/","title":"Resources Reference","text":"AI Summary <p>Static reference data via URI. Core: <code>dota2://heroes/all</code> (124+ heroes with aliases, roles), <code>dota2://map</code> (towers, camps, runes, landmarks). Pro scene: <code>dota2://pro/players</code>, <code>dota2://pro/teams</code>. Resources are for static data the user attaches to context. For match-specific data, use tools like <code>get_match_heroes</code> and <code>get_match_players</code>.</p> <p>Resources are static reference data that users can attach to their context before a conversation. Access via URI.</p> <p>Resources vs Tools</p> <p>Resources provide static reference data (all heroes, map positions, all pro players). For match-specific data that requires computation, use the corresponding tools:</p> <ul> <li>Match heroes: <code>get_match_heroes(match_id)</code> tool</li> <li>Match players: <code>get_match_players(match_id)</code> tool</li> <li>Pro player details: <code>get_pro_player(account_id)</code> tool</li> <li>Team details: <code>get_team(team_id)</code> tool</li> </ul>"},{"location":"api/resources/#dota2heroesall","title":"dota2://heroes/all","text":"<p>All 124+ Dota 2 heroes.</p> <pre><code>{\n  \"npc_dota_hero_antimage\": {\n    \"hero_id\": 1,\n    \"canonical_name\": \"Anti-Mage\",\n    \"aliases\": [\"am\", \"antimage\", \"anti-mage\"],\n    \"attribute\": \"agility\",\n    \"attack_type\": \"melee\",\n    \"roles\": [\"Carry\", \"Escape\", \"Nuker\"]\n  },\n  \"npc_dota_hero_axe\": {\n    \"hero_id\": 2,\n    \"canonical_name\": \"Axe\",\n    \"attribute\": \"strength\"\n  }\n}\n</code></pre> <p>Use for: Hero name resolution, attribute lookups, role classification.</p>"},{"location":"api/resources/#dota2map","title":"dota2://map","text":"<p>Full map geometry - towers, camps, runes, landmarks.</p> <pre><code>{\n  \"towers\": [\n    {\"name\": \"radiant_t1_mid\", \"team\": \"radiant\", \"tier\": 1, \"lane\": \"mid\", \"x\": -1544, \"y\": -1408},\n    {\"name\": \"dire_t1_mid\", \"team\": \"dire\", \"tier\": 1, \"lane\": \"mid\", \"x\": 524, \"y\": 652}\n  ],\n  \"barracks\": [\n    {\"name\": \"radiant_melee_mid\", \"team\": \"radiant\", \"lane\": \"mid\", \"type\": \"melee\", \"x\": -4672, \"y\": -4016}\n  ],\n  \"neutral_camps\": [\n    {\"name\": \"radiant_small_camp_1\", \"tier\": \"small\", \"side\": \"radiant\", \"x\": -3200, \"y\": -400}\n  ],\n  \"runes\": [\n    {\"type\": \"power\", \"location\": \"top\", \"x\": -1792, \"y\": 1232},\n    {\"type\": \"bounty\", \"location\": \"radiant_jungle\", \"x\": -4096, \"y\": -1664}\n  ],\n  \"landmarks\": [\n    {\"name\": \"roshan_pit\", \"x\": -2432, \"y\": 2016},\n    {\"name\": \"radiant_ancient\", \"x\": -6144, \"y\": -6016}\n  ]\n}\n</code></pre> <p>Coordinate system: - Center of map \u2248 (0, 0) - Radiant base = bottom-left (negative X, negative Y) - Dire base = top-right (positive X, positive Y) - Range: roughly -8000 to +8000</p> <p>Use for: Understanding death positions, analyzing rotations, tower/rax context.</p>"},{"location":"api/resources/#pro-scene-resources","title":"Pro Scene Resources","text":"<p>Static data about professional Dota 2 players and teams.</p>"},{"location":"api/resources/#dota2proplayers","title":"dota2://pro/players","text":"<p>All professional players from OpenDota.</p> <pre><code>dota2://pro/players\n</code></pre> <pre><code>{\n  \"players\": [\n    {\n      \"account_id\": 311360822,\n      \"name\": \"Yatoro\",\n      \"personaname\": \"Yatoro\",\n      \"team_id\": 8599101,\n      \"team_name\": \"Team Spirit\",\n      \"team_tag\": \"Spirit\",\n      \"country_code\": \"UA\",\n      \"fantasy_role\": 1,\n      \"is_active\": true\n    }\n  ],\n  \"total_players\": 2500\n}\n</code></pre> <p>Use for: Looking up pro player info, finding players by team.</p>"},{"location":"api/resources/#dota2proteams","title":"dota2://pro/teams","text":"<p>All professional teams from OpenDota.</p> <pre><code>dota2://pro/teams\n</code></pre> <pre><code>{\n  \"teams\": [\n    {\n      \"team_id\": 8599101,\n      \"name\": \"Team Spirit\",\n      \"tag\": \"Spirit\",\n      \"rating\": 1500.0,\n      \"wins\": 450,\n      \"losses\": 200\n    }\n  ],\n  \"total_teams\": 500\n}\n</code></pre> <p>Use for: Looking up team info, comparing team ratings.</p> <p>For detailed player/team info</p> <p>Use the <code>get_pro_player(account_id)</code> and <code>get_team(team_id)</code> tools for detailed information including aliases and rosters.</p>"},{"location":"api/tools/","title":"Tools Reference","text":"\ud83e\udd16 AI Summary <p>Match Analysis Tools (require <code>match_id</code>): <code>download_replay</code> (call first), <code>get_hero_deaths</code>, <code>get_combat_log</code>, <code>get_fight_combat_log</code>, <code>get_item_purchases</code>, <code>get_objective_kills</code>, <code>get_match_timeline</code>, <code>get_stats_at_minute</code>, <code>get_courier_kills</code>, <code>get_rune_pickups</code>, <code>get_match_draft</code>, <code>get_match_info</code>.</p> <p>Pro Scene Tools: <code>search_pro_player(query)</code>, <code>search_team(query)</code>, <code>get_pro_player(account_id)</code>, <code>get_pro_player_by_name(name)</code>, <code>get_team(team_id)</code>, <code>get_team_by_name(name)</code>, <code>get_team_matches(team_id)</code>, <code>get_leagues(tier?)</code>, <code>get_pro_matches(limit?)</code>, <code>get_league_matches(league_id)</code>.</p> <p>Tools are functions the LLM can call. All tools take <code>match_id</code> as required parameter.</p>"},{"location":"api/tools/#download_replay","title":"download_replay","text":"<p>Pre-download and cache a replay file. Use this first before asking analysis questions about a new match. Replay files are large (50-400MB) and can take 1-5 minutes to download.</p> <pre><code>download_replay(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"replay_path\": \"/home/user/dota2/replays/8461956309.dem\",\n  \"file_size_mb\": 398.0,\n  \"already_cached\": false\n}\n</code></pre></p> <p>If already cached: <pre><code>{\n  \"success\": true,\n  \"match_id\": 8461956309,\n  \"replay_path\": \"/home/user/dota2/replays/8461956309.dem\",\n  \"file_size_mb\": 398.0,\n  \"already_cached\": true\n}\n</code></pre></p>"},{"location":"api/tools/#get_hero_deaths","title":"get_hero_deaths","text":"<p>All hero deaths in the match.</p> <pre><code>get_hero_deaths(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"total_deaths\": 45,\n  \"deaths\": [\n    {\n      \"game_time\": 288,\n      \"game_time_str\": \"4:48\",\n      \"victim\": \"earthshaker\",\n      \"killer\": \"disruptor\",\n      \"killer_is_hero\": true,\n      \"ability\": \"disruptor_thunder_strike\",\n      \"position\": {\"x\": 4200, \"y\": 1800, \"region\": \"dire_safelane\", \"location\": \"Dire safelane near tower\"}\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_combat_log","title":"get_combat_log","text":"<p>Raw combat events with optional filters.</p> <pre><code>get_combat_log(\n    match_id=8461956309,\n    start_time=280,      # optional: filter by time range\n    end_time=300,\n    hero_filter=\"earthshaker\"  # optional: only events involving this hero\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"events\": [\n    {\n      \"type\": \"DAMAGE\",\n      \"game_time\": 285,\n      \"game_time_str\": \"4:45\",\n      \"attacker\": \"disruptor\",\n      \"attacker_is_hero\": true,\n      \"target\": \"earthshaker\",\n      \"target_is_hero\": true,\n      \"ability\": \"disruptor_thunder_strike\",\n      \"value\": 160\n    }\n  ]\n}\n</code></pre></p> <p>Event types: <code>DAMAGE</code>, <code>MODIFIER_ADD</code>, <code>MODIFIER_REMOVE</code>, <code>ABILITY</code>, <code>ITEM</code>, <code>DEATH</code>, <code>HEAL</code></p>"},{"location":"api/tools/#get_fight_combat_log","title":"get_fight_combat_log","text":"<p>Auto-detects fight boundaries around a reference time. Use this to analyze what happened leading up to a death.</p> <pre><code>get_fight_combat_log(\n    match_id=8461956309,\n    reference_time=288,    # e.g., death time\n    hero=\"earthshaker\"     # optional: anchor detection to this hero\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"fight_start\": 280,\n  \"fight_end\": 295,\n  \"fight_start_str\": \"4:40\",\n  \"fight_end_str\": \"4:55\",\n  \"duration\": 15,\n  \"participants\": [\"earthshaker\", \"disruptor\", \"naga_siren\", \"medusa\"],\n  \"total_events\": 47,\n  \"events\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/#get_item_purchases","title":"get_item_purchases","text":"<p>When items were bought.</p> <pre><code>get_item_purchases(\n    match_id=8461956309,\n    hero_filter=\"antimage\"  # optional\n)\n</code></pre> <p>Returns: <pre><code>{\n  \"purchases\": [\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"hero\": \"antimage\", \"item\": \"item_tango\"},\n    {\"game_time\": 540, \"game_time_str\": \"9:00\", \"hero\": \"antimage\", \"item\": \"item_bfury\"}\n  ]\n}\n</code></pre></p> <p>Negative times = purchased before horn (0:00).</p>"},{"location":"api/tools/#get_objective_kills","title":"get_objective_kills","text":"<p>Roshan, tormentor, towers, barracks.</p> <pre><code>get_objective_kills(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"roshan_kills\": [\n    {\"game_time\": 1392, \"game_time_str\": \"23:12\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 1}\n  ],\n  \"tormentor_kills\": [\n    {\"game_time\": 1215, \"game_time_str\": \"20:15\", \"killer\": \"medusa\", \"team\": \"dire\", \"side\": \"dire\"}\n  ],\n  \"tower_kills\": [\n    {\"game_time\": 669, \"game_time_str\": \"11:09\", \"tower\": \"dire_t1_mid\", \"team\": \"dire\", \"tier\": 1, \"lane\": \"mid\", \"killer\": \"nevermore\"}\n  ],\n  \"barracks_kills\": [\n    {\"game_time\": 2373, \"game_time_str\": \"39:33\", \"barracks\": \"radiant_melee_mid\", \"team\": \"radiant\", \"lane\": \"mid\", \"type\": \"melee\", \"killer\": \"medusa\"}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_match_timeline","title":"get_match_timeline","text":"<p>Net worth, XP, KDA over time for all players.</p> <pre><code>get_match_timeline(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"players\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"net_worth\": [500, 800, 1200, ...],  // every 30 seconds\n      \"hero_damage\": [0, 0, 150, ...],\n      \"kda_timeline\": [\n        {\"game_time\": 0, \"kills\": 0, \"deaths\": 0, \"assists\": 0, \"level\": 1},\n        {\"game_time\": 300, \"kills\": 0, \"deaths\": 0, \"assists\": 0, \"level\": 5}\n      ]\n    }\n  ],\n  \"team_graphs\": {\n    \"radiant_xp\": [0, 1200, 2500, ...],\n    \"dire_xp\": [0, 1100, 2400, ...],\n    \"radiant_gold\": [0, 600, 1300, ...],\n    \"dire_gold\": [0, 650, 1400, ...]\n  }\n}\n</code></pre></p>"},{"location":"api/tools/#get_stats_at_minute","title":"get_stats_at_minute","text":"<p>Snapshot of all players at a specific minute.</p> <pre><code>get_stats_at_minute(match_id=8461956309, minute=10)\n</code></pre> <p>Returns: <pre><code>{\n  \"minute\": 10,\n  \"players\": [\n    {\n      \"hero\": \"antimage\",\n      \"team\": \"dire\",\n      \"net_worth\": 5420,\n      \"last_hits\": 78,\n      \"denies\": 8,\n      \"kills\": 0,\n      \"deaths\": 0,\n      \"assists\": 0,\n      \"level\": 10,\n      \"hero_damage\": 450\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_courier_kills","title":"get_courier_kills","text":"<p>Courier snipes.</p> <pre><code>get_courier_kills(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"kills\": [\n    {\n      \"game_time\": 420,\n      \"game_time_str\": \"7:00\",\n      \"killer\": \"bounty_hunter\",\n      \"killer_is_hero\": true,\n      \"owner\": \"antimage\",\n      \"team\": \"dire\",\n      \"position\": {\"x\": 2100, \"y\": -1500, \"region\": \"river\", \"location\": \"River near Radiant outpost\"}\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_rune_pickups","title":"get_rune_pickups","text":"<p>All rune pickups in the match.</p> <pre><code>get_rune_pickups(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"pickups\": [\n    {\n      \"game_time\": 0,\n      \"game_time_str\": \"0:00\",\n      \"hero\": \"pangolier\",\n      \"rune_type\": \"bounty\"\n    }\n  ],\n  \"total_pickups\": 42\n}\n</code></pre></p>"},{"location":"api/tools/#get_match_draft","title":"get_match_draft","text":"<p>Complete draft with bans and picks in order (for Captains Mode matches).</p> <pre><code>get_match_draft(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"match_id\": 8461956309,\n  \"game_mode\": 2,\n  \"game_mode_name\": \"Captains Mode\",\n  \"actions\": [\n    {\"order\": 1, \"is_pick\": false, \"team\": \"radiant\", \"hero_id\": 23, \"hero_name\": \"kunkka\", \"localized_name\": \"Kunkka\"},\n    {\"order\": 8, \"is_pick\": true, \"team\": \"dire\", \"hero_id\": 89, \"hero_name\": \"naga_siren\", \"localized_name\": \"Naga Siren\"}\n  ],\n  \"radiant_picks\": [...],\n  \"radiant_bans\": [...],\n  \"dire_picks\": [...],\n  \"dire_bans\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/#get_match_info","title":"get_match_info","text":"<p>Match metadata including teams, players, winner, duration.</p> <pre><code>get_match_info(match_id=8461956309)\n</code></pre> <p>Returns: <pre><code>{\n  \"match_id\": 8461956309,\n  \"is_pro_match\": true,\n  \"league_id\": 18324,\n  \"game_mode\": 2,\n  \"game_mode_name\": \"Captains Mode\",\n  \"winner\": \"dire\",\n  \"duration_seconds\": 4672,\n  \"duration_str\": \"77:52\",\n  \"radiant_team\": {\"team_id\": 8291895, \"team_tag\": \"XG\", \"team_name\": \"XG\"},\n  \"dire_team\": {\"team_id\": 8894818, \"team_tag\": \"FLCN\", \"team_name\": \"FLCN\"},\n  \"players\": [\n    {\"player_name\": \"Ame\", \"hero_name\": \"juggernaut\", \"hero_localized\": \"Juggernaut\", \"team\": \"radiant\", \"steam_id\": 123456}\n  ],\n  \"radiant_players\": [...],\n  \"dire_players\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/#pro-scene-tools","title":"Pro Scene Tools","text":"<p>These tools query professional Dota 2 data from OpenDota.</p>"},{"location":"api/tools/#search_pro_player","title":"search_pro_player","text":"<p>Fuzzy search for pro players by name or alias.</p> <pre><code>search_pro_player(query=\"yatoro\", max_results=5)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"query\": \"yatoro\",\n  \"total_results\": 1,\n  \"results\": [\n    {\"id\": 311360822, \"name\": \"Yatoro\", \"matched_alias\": \"Yatoro\", \"similarity\": 1.0}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#search_team","title":"search_team","text":"<p>Fuzzy search for teams by name or tag.</p> <pre><code>search_team(query=\"spirit\", max_results=5)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"query\": \"spirit\",\n  \"total_results\": 2,\n  \"results\": [\n    {\"id\": 8599101, \"name\": \"Team Spirit\", \"matched_alias\": \"spirit\", \"similarity\": 0.95}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_pro_player","title":"get_pro_player","text":"<p>Get pro player details by account ID.</p> <pre><code>get_pro_player(account_id=311360822)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"player\": {\n    \"account_id\": 311360822,\n    \"name\": \"Yatoro\",\n    \"personaname\": \"Yatoro\",\n    \"team_id\": 8599101,\n    \"team_name\": \"Team Spirit\",\n    \"country_code\": \"UA\",\n    \"fantasy_role\": 1,\n    \"is_active\": true,\n    \"aliases\": [\"yatoro\", \"raddan\"]\n  }\n}\n</code></pre></p>"},{"location":"api/tools/#get_pro_player_by_name","title":"get_pro_player_by_name","text":"<p>Get pro player details by name (uses fuzzy search).</p> <pre><code>get_pro_player_by_name(name=\"Yatoro\")\n</code></pre>"},{"location":"api/tools/#get_team","title":"get_team","text":"<p>Get team details by team ID.</p> <pre><code>get_team(team_id=8599101)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"team\": {\n    \"team_id\": 8599101,\n    \"name\": \"Team Spirit\",\n    \"tag\": \"Spirit\",\n    \"rating\": 1500.0,\n    \"wins\": 450,\n    \"losses\": 200,\n    \"aliases\": [\"ts\", \"spirit\"]\n  },\n  \"roster\": [\n    {\"account_id\": 311360822, \"player_name\": \"Yatoro\", \"games_played\": 300, \"wins\": 200, \"is_current\": true}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_team_by_name","title":"get_team_by_name","text":"<p>Get team details by name (uses fuzzy search).</p> <pre><code>get_team_by_name(name=\"Team Spirit\")\n</code></pre>"},{"location":"api/tools/#get_team_matches","title":"get_team_matches","text":"<p>Get recent matches for a team with series grouping.</p> <pre><code>get_team_matches(team_id=8599101, limit=20)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"team_id\": 8599101,\n  \"team_name\": \"Team Spirit\",\n  \"total_matches\": 20,\n  \"series\": [\n    {\n      \"series_id\": 123,\n      \"series_type\": \"bo3\",\n      \"games_in_series\": 2,\n      \"wins_needed\": 2,\n      \"radiant_team_id\": 8599101,\n      \"dire_team_id\": 7391077,\n      \"winner_team_id\": 8599101,\n      \"league_name\": \"ESL One\"\n    }\n  ],\n  \"matches\": [...]\n}\n</code></pre></p>"},{"location":"api/tools/#get_leagues","title":"get_leagues","text":"<p>Get all leagues/tournaments, optionally filtered by tier.</p> <pre><code>get_leagues(tier=\"premium\")  # \"premium\", \"professional\", \"amateur\", or None for all\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_leagues\": 15,\n  \"leagues\": [\n    {\"league_id\": 15728, \"name\": \"The International 2023\", \"tier\": \"premium\"}\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_pro_matches","title":"get_pro_matches","text":"<p>Get recent professional matches with series grouping.</p> <pre><code>get_pro_matches(limit=100)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"total_matches\": 100,\n  \"series\": [...],\n  \"matches\": [\n    {\n      \"match_id\": 8461956309,\n      \"radiant_team_id\": 8291895,\n      \"radiant_team_name\": \"XG\",\n      \"dire_team_id\": 8894818,\n      \"dire_team_name\": \"FLCN\",\n      \"radiant_win\": false,\n      \"duration\": 4672,\n      \"league_name\": \"Elite League\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/tools/#get_league_matches","title":"get_league_matches","text":"<p>Get matches from a specific league with series grouping.</p> <pre><code>get_league_matches(league_id=15728, limit=50)\n</code></pre> <p>Returns: <pre><code>{\n  \"success\": true,\n  \"league_id\": 15728,\n  \"league_name\": \"The International 2023\",\n  \"total_matches\": 50,\n  \"series\": [...],\n  \"matches\": [...]\n}\n</code></pre></p>"},{"location":"examples/use-cases/","title":"Real Use Cases","text":"\ud83e\udd16 AI Summary <p>Example LLM conversations: Lost teamfight - <code>get_hero_deaths</code> \u2192 <code>get_fight_combat_log</code> \u2192 analyze initiation, counters, positioning. Carry farm tracking - <code>get_item_purchases</code> \u2192 <code>get_stats_at_minute</code> \u2192 compare CS, deaths, item timings. Gank analysis - deaths with position \u2192 fight log \u2192 identify root, damage chain, positioning mistake. Roshan control - <code>get_objective_kills</code> \u2192 timeline of objectives. Laning comparison - <code>get_stats_at_minute(10)</code> \u2192 compare LH, denies, net worth, level.</p> <p>These are example conversations showing how an LLM uses the MCP tools to analyze matches.</p>"},{"location":"examples/use-cases/#analyzing-a-lost-teamfight","title":"Analyzing a Lost Teamfight","text":"<p>User: \"In match 8461956309, we lost a big fight around 25 minutes. What went wrong?\"</p> <p>LLM thinks: I need to find deaths around minute 25 and analyze the fight.</p> <p>LLM calls: <code>get_hero_deaths(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"deaths\": [\n    {\"game_time\": 1487, \"game_time_str\": \"24:47\", \"victim\": \"pangolier\", \"killer\": \"medusa\", \"ability\": \"medusa_split_shot\"},\n    {\"game_time\": 1492, \"game_time_str\": \"24:52\", \"victim\": \"earthshaker\", \"killer\": \"disruptor\", \"ability\": \"disruptor_static_storm\"},\n    {\"game_time\": 1495, \"game_time_str\": \"24:55\", \"victim\": \"nevermore\", \"killer\": \"naga_siren\", \"ability\": \"naga_siren_rip_tide\"},\n    {\"game_time\": 1498, \"game_time_str\": \"24:58\", \"victim\": \"dawnbreaker\", \"killer\": \"medusa\", \"ability\": \"medusa_mystic_snake\"}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_fight_combat_log(match_id=8461956309, reference_time=1492, hero=\"earthshaker\")</code></p> <p>Tool returns: <pre><code>{\n  \"fight_start\": 1480,\n  \"fight_end\": 1502,\n  \"duration\": 22,\n  \"participants\": [\"pangolier\", \"earthshaker\", \"nevermore\", \"dawnbreaker\", \"medusa\", \"disruptor\", \"naga_siren\", \"luna\", \"necrophos\"],\n  \"events\": [\n    {\"type\": \"ABILITY\", \"game_time\": 1481, \"attacker\": \"earthshaker\", \"ability\": \"earthshaker_echo_slam\", \"value\": 0},\n    {\"type\": \"DAMAGE\", \"game_time\": 1481, \"attacker\": \"earthshaker\", \"target\": \"medusa\", \"ability\": \"earthshaker_echo_slam\", \"value\": 287},\n    {\"type\": \"MODIFIER_ADD\", \"game_time\": 1482, \"attacker\": \"disruptor\", \"target\": \"earthshaker\", \"ability\": \"disruptor_static_storm\"},\n    {\"type\": \"DAMAGE\", \"game_time\": 1485, \"attacker\": \"medusa\", \"target\": \"pangolier\", \"ability\": \"medusa_split_shot\", \"value\": 412},\n    ...\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>The fight at 24:47 was a disaster for Radiant. Here's what happened:</p> <ol> <li> <p>Earthshaker initiated with Echo Slam at 24:41, hitting all 5 Dire heroes but dealing low damage (287 on Medusa) - likely because enemies were spread out</p> </li> <li> <p>Disruptor immediately countered with Static Storm on Earthshaker, silencing him and preventing follow-up</p> </li> <li> <p>Medusa was the problem - she had Split Shot farming Pangolier while tanking the initiation, then cleaned up with 3 kills</p> </li> <li> <p>4 Radiant deaths in 11 seconds - Pangolier, Earthshaker, Nevermore, Dawnbreaker</p> </li> </ol> <p>The issue: Earthshaker jumped in without BKB against a Disruptor. The moment he was silenced, Radiant had no follow-up damage and Medusa shredded everyone.</p>"},{"location":"examples/use-cases/#tracking-carry-farm","title":"Tracking Carry Farm","text":"<p>User: \"How did their Anti-Mage get Battle Fury so fast in match 8461956309?\"</p> <p>LLM calls: <code>get_item_purchases(match_id=8461956309, hero_filter=\"antimage\")</code></p> <p>Tool returns: <pre><code>{\n  \"purchases\": [\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"item\": \"item_tango\"},\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"item\": \"item_quelling_blade\"},\n    {\"game_time\": -89, \"game_time_str\": \"-1:29\", \"item\": \"item_slippers\"},\n    {\"game_time\": 180, \"game_time_str\": \"3:00\", \"item\": \"item_ring_of_health\"},\n    {\"game_time\": 420, \"game_time_str\": \"7:00\", \"item\": \"item_boots\"},\n    {\"game_time\": 540, \"game_time_str\": \"9:00\", \"item\": \"item_bfury\"},\n    {\"game_time\": 780, \"game_time_str\": \"13:00\", \"item\": \"item_manta\"}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_stats_at_minute(match_id=8461956309, minute=9)</code></p> <p>Tool returns: <pre><code>{\n  \"players\": [\n    {\"hero\": \"antimage\", \"last_hits\": 78, \"net_worth\": 5420, \"kills\": 0, \"deaths\": 0},\n    {\"hero\": \"nevermore\", \"last_hits\": 62, \"net_worth\": 4100, \"kills\": 1, \"deaths\": 1}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Anti-Mage got a 9-minute Battle Fury, which is quite fast. Here's how:</p> <ul> <li>78 last hits by minute 9 - excellent lane farming</li> <li>0 deaths - completely free lane, no pressure</li> <li>Ring of Health at 3:00 - sustain let him stay in lane indefinitely</li> </ul> <p>Compare to Nevermore mid who had 62 CS but died once - that death probably cost 300-400 gold and 30 seconds of farm.</p> <p>The real question is why Radiant's offlane didn't pressure AM. A 9-minute BFury usually means the safelane was uncontested.</p>"},{"location":"examples/use-cases/#understanding-a-gank","title":"Understanding a Gank","text":"<p>User: \"I was playing Earthshaker and got killed at first blood. What could I have done differently?\"</p> <p>LLM calls: <code>get_hero_deaths(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"deaths\": [\n    {\"game_time\": 288, \"game_time_str\": \"4:48\", \"victim\": \"earthshaker\", \"killer\": \"disruptor\", \"ability\": \"disruptor_thunder_strike\", \"position\": {\"x\": 4200, \"y\": 1800, \"region\": \"dire_safelane\"}}\n  ]\n}\n</code></pre></p> <p>LLM calls: <code>get_fight_combat_log(match_id=8461956309, reference_time=288, hero=\"earthshaker\")</code></p> <p>Tool returns: <pre><code>{\n  \"fight_start\": 280,\n  \"fight_end\": 290,\n  \"participants\": [\"earthshaker\", \"disruptor\", \"naga_siren\", \"medusa\"],\n  \"events\": [\n    {\"type\": \"MODIFIER_ADD\", \"game_time\": 281, \"attacker\": \"naga_siren\", \"target\": \"earthshaker\", \"ability\": \"naga_siren_ensnare\"},\n    {\"type\": \"DAMAGE\", \"game_time\": 282, \"attacker\": \"disruptor\", \"target\": \"earthshaker\", \"ability\": \"disruptor_thunder_strike\", \"value\": 160},\n    {\"type\": \"DAMAGE\", \"game_time\": 284, \"attacker\": \"medusa\", \"target\": \"earthshaker\", \"ability\": \"medusa_mystic_snake\", \"value\": 140},\n    {\"type\": \"DAMAGE\", \"game_time\": 286, \"attacker\": \"naga_siren\", \"target\": \"earthshaker\", \"value\": 58},\n    {\"type\": \"DEATH\", \"game_time\": 288, \"target\": \"earthshaker\", \"attacker\": \"disruptor\"}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Here's what happened at first blood (4:48):</p> <ol> <li>Naga Siren caught you with Ensnare at 4:41 - 3-second root</li> <li>Disruptor followed with Thunder Strike - 160 damage over time</li> <li>Medusa hit you with Mystic Snake - another 140 damage</li> <li>You died in 8 seconds without being able to act</li> </ol> <p>Position: You were at x:4200, y:1800 - that's deep in Dire safelane near the tower.</p> <p>What went wrong: You were too far forward against a Naga (root) + Disruptor (slow + damage) dual lane. Once Naga lands Ensnare, you have no escape without Fissure (and even then it's not a disjoint).</p> <p>What to do differently: - Stay near trees for juke paths - Don't contest pulls against this lane - Naga root is too punishing - Play for XP, not kills - ES needs level 6 to fight this lane</p>"},{"location":"examples/use-cases/#objective-control-analysis","title":"Objective Control Analysis","text":"<p>User: \"When did Roshan die and who took the Aegis?\"</p> <p>LLM calls: <code>get_objective_kills(match_id=8461956309)</code></p> <p>Tool returns: <pre><code>{\n  \"roshan_kills\": [\n    {\"game_time\": 1392, \"game_time_str\": \"23:12\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 1},\n    {\"game_time\": 2040, \"game_time_str\": \"34:00\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 2},\n    {\"game_time\": 2580, \"game_time_str\": \"43:00\", \"killer\": \"luna\", \"team\": \"dire\", \"kill_number\": 3},\n    {\"game_time\": 3120, \"game_time_str\": \"52:00\", \"killer\": \"medusa\", \"team\": \"dire\", \"kill_number\": 4}\n  ],\n  \"tower_kills\": [\n    {\"game_time\": 669, \"game_time_str\": \"11:09\", \"tower\": \"dire_t1_mid\", \"killer\": \"nevermore\"},\n    {\"game_time\": 1440, \"game_time_str\": \"24:00\", \"tower\": \"radiant_t1_bot\", \"killer\": \"medusa\"}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Roshan Timeline:</p> Rosh # Time Killer Team 1 23:12 Medusa Dire 2 34:00 Medusa Dire 3 43:00 Luna Dire 4 52:00 Medusa Dire <p>Dire took all 4 Roshans. Medusa got 3 of them personally - she was likely the Aegis carrier for most of the game.</p> <p>This is a big factor in why the game went late - Medusa with Aegis is extremely hard to kill, and Dire maintained complete Roshan control throughout.</p>"},{"location":"examples/use-cases/#comparing-laning-phase","title":"Comparing Laning Phase","text":"<p>User: \"Compare the midlaners at 10 minutes\"</p> <p>LLM calls: <code>get_stats_at_minute(match_id=8461956309, minute=10)</code></p> <p>Tool returns: <pre><code>{\n  \"players\": [\n    {\"hero\": \"nevermore\", \"team\": \"radiant\", \"last_hits\": 68, \"denies\": 12, \"net_worth\": 4800, \"kills\": 2, \"deaths\": 0, \"level\": 11},\n    {\"hero\": \"pangolier\", \"team\": \"dire\", \"last_hits\": 45, \"denies\": 3, \"net_worth\": 3200, \"kills\": 0, \"deaths\": 1, \"level\": 9}\n  ]\n}\n</code></pre></p> <p>LLM responds:</p> <p>Mid Lane at 10:00 - Nevermore vs Pangolier:</p> Stat Nevermore (Radiant) Pangolier (Dire) Last Hits 68 45 Denies 12 3 Net Worth 4,800 3,200 K/D/A 2/0/? 0/1/? Level 11 9 <p>Nevermore dominated the lane: - +23 CS advantage - +9 denies - +1,600 net worth - +2 levels</p> <p>Shadow Fiend's early damage from Necromastery stacks makes him strong in the 1v1. Pangolier likely struggled to last hit under tower after SF established raze control.</p>"},{"location":"getting-started/docker/","title":"Docker Deployment","text":"<p>The Dota 2 Match MCP Server can be run in Docker for faster startup times and consistent deployment.</p>"},{"location":"getting-started/docker/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/docker/#build-the-image","title":"Build the Image","text":"<pre><code>docker build -t dota2-mcp-server .\n</code></pre>"},{"location":"getting-started/docker/#run-with-sse-transport-recommended-for-docker","title":"Run with SSE Transport (Recommended for Docker)","text":"<pre><code>docker run -p 8081:8081 dota2-mcp-server --transport sse\n</code></pre> <p>The server will be available at <code>http://localhost:8081/sse</code>.</p>"},{"location":"getting-started/docker/#run-with-docker-compose","title":"Run with Docker Compose","text":"<pre><code>docker compose up\n</code></pre>"},{"location":"getting-started/docker/#transport-modes","title":"Transport Modes","text":""},{"location":"getting-started/docker/#sse-server-sent-events-recommended-for-docker","title":"SSE (Server-Sent Events) - Recommended for Docker","text":"<p>SSE transport runs an HTTP server, which is ideal for Docker deployments:</p> <pre><code>docker run -p 8081:8081 dota2-mcp-server --transport sse --port 8081\n</code></pre> <p>Configure your MCP client to connect to <code>http://localhost:8081/sse</code>.</p>"},{"location":"getting-started/docker/#stdio-standard-io","title":"STDIO (Standard I/O)","text":"<p>STDIO transport is the default for local development but requires interactive mode in Docker:</p> <pre><code>docker run -i dota2-mcp-server\n</code></pre>"},{"location":"getting-started/docker/#persistent-cache","title":"Persistent Cache","text":"<p>Replay files are large (50-400MB) and take time to download and parse. Mount a volume to persist the cache:</p> <pre><code>docker run -p 8081:8081 \\\n  -v dota2-replay-cache:/app/.cache/mcp_dota2 \\\n  dota2-mcp-server --transport sse\n</code></pre>"},{"location":"getting-started/docker/#environment-variables","title":"Environment Variables","text":"Variable Default Description <code>PORT</code> <code>8081</code> Port for SSE transport"},{"location":"getting-started/docker/#claude-desktop-configuration","title":"Claude Desktop Configuration","text":"<p>For Claude Desktop with Docker SSE transport:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"url\": \"http://localhost:8081/sse\"\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/docker/#startup-optimization","title":"Startup Optimization","text":"<p>The Docker image uses several optimizations for fast startup:</p> <ol> <li>Pre-compiled bytecode (<code>UV_COMPILE_BYTECODE=1</code>) - Python bytecode is compiled at build time</li> <li>Slim base image - Uses <code>python:3.12-slim-bookworm</code> for minimal size</li> <li>Layer caching - Dependencies are installed in a separate layer for faster rebuilds</li> <li>No runtime dependency resolution - Uses locked dependencies from <code>uv.lock</code></li> </ol>"},{"location":"getting-started/docker/#building-for-production","title":"Building for Production","text":"<p>For production deployments, consider:</p> <ol> <li> <p>Use a specific tag instead of <code>latest</code>:    <pre><code>docker build -t dota2-mcp-server:1.0.0 .\n</code></pre></p> </li> <li> <p>Set resource limits:    <pre><code>docker run -p 8081:8081 \\\n  --memory=2g \\\n  --cpus=2 \\\n  dota2-mcp-server --transport sse\n</code></pre></p> </li> <li> <p>Health checks are included in <code>docker-compose.yml</code></p> </li> </ol>"},{"location":"getting-started/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/docker/#slow-startup","title":"Slow Startup","text":"<p>If startup is slow, ensure: - The Docker image has been built (not building on first run) - The cache volume is mounted (avoids re-downloading replays) - Sufficient memory is allocated (at least 1GB recommended)</p>"},{"location":"getting-started/docker/#connection-refused","title":"Connection Refused","text":"<p>If you get \"connection refused\" when connecting to SSE: - Ensure the container is running: <code>docker ps</code> - Check the port mapping: <code>docker run -p 8081:8081 ...</code> - Verify the transport mode: <code>--transport sse</code></p>"},{"location":"getting-started/installation/","title":"Installation","text":"\ud83e\udd16 AI Summary <p>Requires Python 3.12 and <code>uv</code>. Install: <code>git clone</code> repo, <code>uv sync</code>. Verify: <code>uv run python dota_match_mcp_server.py</code>. Then connect to your LLM client (Claude Desktop, Claude Code, etc.).</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12</li> <li>uv package manager</li> </ul>"},{"location":"getting-started/installation/#install","title":"Install","text":"<pre><code>git clone https://github.com/DeepBlueCoding/mcp_replay_dota2.git\ncd mcp_replay_dota2\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<pre><code>uv run python dota_match_mcp_server.py\n</code></pre> <p>You should see: <pre><code>Dota 2 Match MCP Server starting...\nResources: dota2://heroes/all, dota2://map, ...\nTools: get_hero_deaths, get_combat_log, ...\n</code></pre></p>"},{"location":"getting-started/installation/#next-step","title":"Next Step","text":"<p>Connect to your LLM</p>"},{"location":"integrations/","title":"Connecting to LLMs","text":"\ud83e\udd16 AI Summary <p>Integration options by difficulty: Easy - Claude Desktop (config JSON), Claude Code CLI (.mcp.json), FastMCP Client (Python). Medium - LangChain, LangGraph, CrewAI, AutoGen, MCP SDK. Hard - Anthropic API, OpenAI API (manual tool loop). For quick chat \u2192 Claude Desktop. For Python apps \u2192 FastMCP/LangChain. For multi-step agents \u2192 LangGraph. For multi-agent \u2192 CrewAI.</p> <p>This MCP server can connect to any LLM that supports the Model Context Protocol or tool calling.</p>"},{"location":"integrations/#native-mcp-support","title":"Native MCP Support","text":"<p>These clients have built-in MCP support:</p> Client Setup Difficulty Best For Claude Desktop Easy Interactive chat with tools Claude Code CLI Easy Development workflows"},{"location":"integrations/#agentic-frameworks","title":"Agentic Frameworks","text":"<p>Use MCP tools with popular agent frameworks:</p> Framework Setup Difficulty Best For LangChain Medium Complex agent pipelines LangGraph Medium Stateful multi-step agents CrewAI Medium Multi-agent collaboration AutoGen Medium Conversational agents"},{"location":"integrations/#direct-api-integration","title":"Direct API Integration","text":"<p>For custom implementations:</p> Method Setup Difficulty Best For FastMCP Client Easy Python scripts MCP SDK Medium Custom clients Anthropic API Hard Full control OpenAI API Hard OpenAI models"},{"location":"integrations/#which-should-i-use","title":"Which Should I Use?","text":"<p>Just want to chat with match analysis? \u2192 Claude Desktop</p> <p>Building a Python application? \u2192 FastMCP Client or LangChain</p> <p>Need complex multi-step analysis? \u2192 LangGraph</p> <p>Want multiple specialized agents? \u2192 CrewAI</p>"},{"location":"integrations/anthropic-api/","title":"Anthropic API","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install anthropic mcp</code>. Define tools with <code>input_schema</code>. Create <code>MCPToolExecutor</code> class to call MCP server. Implement agentic loop: call Claude with tools \u2192 check <code>stop_reason</code> \u2192 if <code>tool_use</code>, execute via MCP, return results \u2192 repeat until <code>end_turn</code>. Supports streaming with <code>messages.stream()</code>.</p> <p>Integrate MCP tools directly with Claude API for full control.</p>"},{"location":"integrations/anthropic-api/#overview","title":"Overview","text":"<p>This approach gives you complete control over the tool calling loop. You define tools for Claude, handle tool calls yourself by calling the MCP server, and return results to Claude.</p>"},{"location":"integrations/anthropic-api/#install","title":"Install","text":"<pre><code>pip install anthropic mcp\n</code></pre>"},{"location":"integrations/anthropic-api/#setup","title":"Setup","text":"<pre><code>import anthropic\nimport asyncio\nimport json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclient = anthropic.Anthropic()\n\n# Tool definitions for Claude\nTOOLS = [\n    {\n        \"name\": \"get_hero_deaths\",\n        \"description\": \"Get all hero deaths in a Dota 2 match. Returns killer, victim, ability, and timing for each death.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\n                    \"type\": \"integer\",\n                    \"description\": \"The Dota 2 match ID\"\n                }\n            },\n            \"required\": [\"match_id\"]\n        }\n    },\n    {\n        \"name\": \"get_fight_combat_log\",\n        \"description\": \"Get combat log for a fight around a specific time. Auto-detects fight boundaries.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"},\n                \"reference_time\": {\"type\": \"number\", \"description\": \"Game time in seconds\"},\n                \"hero\": {\"type\": \"string\", \"description\": \"Optional hero to anchor detection\"}\n            },\n            \"required\": [\"match_id\", \"reference_time\"]\n        }\n    },\n    {\n        \"name\": \"get_objective_kills\",\n        \"description\": \"Get Roshan, tormentor, tower, and barracks kills.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"}\n            },\n            \"required\": [\"match_id\"]\n        }\n    },\n    {\n        \"name\": \"get_item_purchases\",\n        \"description\": \"Get item purchase timings for heroes.\",\n        \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"match_id\": {\"type\": \"integer\"},\n                \"hero_filter\": {\"type\": \"string\", \"description\": \"Optional hero name filter\"}\n            },\n            \"required\": [\"match_id\"]\n        }\n    }\n]\n</code></pre>"},{"location":"integrations/anthropic-api/#mcp-tool-executor","title":"MCP Tool Executor","text":"<pre><code>class MCPToolExecutor:\n    def __init__(self, server_path: str):\n        self.server_path = server_path\n\n    async def execute(self, tool_name: str, tool_input: dict) -&gt; str:\n        server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=self.server_path\n        )\n\n        async with stdio_client(server_params) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                result = await session.call_tool(tool_name, arguments=tool_input)\n                return result.content[0].text\n\nexecutor = MCPToolExecutor(\"/path/to/mcp_replay_dota2\")\n</code></pre>"},{"location":"integrations/anthropic-api/#agentic-loop","title":"Agentic Loop","text":"<pre><code>async def analyze_match(user_message: str):\n    messages = [{\"role\": \"user\", \"content\": user_message}]\n\n    while True:\n        # Call Claude\n        response = client.messages.create(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            tools=TOOLS,\n            messages=messages\n        )\n\n        # Check if done\n        if response.stop_reason == \"end_turn\":\n            # Extract final text response\n            for block in response.content:\n                if block.type == \"text\":\n                    return block.text\n            return \"\"\n\n        # Handle tool use\n        if response.stop_reason == \"tool_use\":\n            # Add assistant message\n            messages.append({\"role\": \"assistant\", \"content\": response.content})\n\n            # Process each tool call\n            tool_results = []\n            for block in response.content:\n                if block.type == \"tool_use\":\n                    print(f\"Calling {block.name}({block.input})\")\n\n                    # Execute via MCP\n                    result = await executor.execute(block.name, block.input)\n\n                    tool_results.append({\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": block.id,\n                        \"content\": result\n                    })\n\n            # Add tool results\n            messages.append({\"role\": \"user\", \"content\": tool_results})\n\n# Run\nresult = asyncio.run(analyze_match(\n    \"Analyze match 8461956309. Focus on the first blood and subsequent laning phase.\"\n))\nprint(result)\n</code></pre>"},{"location":"integrations/anthropic-api/#streaming-response","title":"Streaming Response","text":"<pre><code>async def analyze_match_streaming(user_message: str):\n    messages = [{\"role\": \"user\", \"content\": user_message}]\n\n    while True:\n        with client.messages.stream(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            tools=TOOLS,\n            messages=messages\n        ) as stream:\n            response = stream.get_final_message()\n\n        if response.stop_reason == \"end_turn\":\n            for block in response.content:\n                if block.type == \"text\":\n                    print(block.text)\n            break\n\n        if response.stop_reason == \"tool_use\":\n            messages.append({\"role\": \"assistant\", \"content\": response.content})\n\n            tool_results = []\n            for block in response.content:\n                if block.type == \"tool_use\":\n                    result = await executor.execute(block.name, block.input)\n                    tool_results.append({\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": block.id,\n                        \"content\": result\n                    })\n\n            messages.append({\"role\": \"user\", \"content\": tool_results})\n\nasyncio.run(analyze_match_streaming(\"Why did Radiant lose match 8461956309?\"))\n</code></pre>"},{"location":"integrations/anthropic-api/#with-system-prompt","title":"With System Prompt","text":"<pre><code>SYSTEM_PROMPT = \"\"\"You are an expert Dota 2 analyst. When analyzing matches:\n\n1. Start by getting hero deaths to understand the flow of the game\n2. For important deaths, get the fight combat log to understand what happened\n3. Check objectives to understand macro gameplay\n4. Always explain findings in terms casual players can understand\n\nFocus on actionable insights - what could the losing team have done differently?\"\"\"\n\nresponse = client.messages.create(\n    model=\"claude-sonnet-4-20250514\",\n    max_tokens=4096,\n    system=SYSTEM_PROMPT,\n    tools=TOOLS,\n    messages=[{\"role\": \"user\", \"content\": \"Analyze match 8461956309\"}]\n)\n</code></pre>"},{"location":"integrations/autogen/","title":"AutoGen","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install pyautogen langchain-mcp-adapters</code>. Create <code>AssistantAgent</code> with function definitions, <code>UserProxyAgent</code> with <code>function_map</code> to execute MCP tools. Use <code>a_initiate_chat()</code> for conversation. For multi-agent: create specialists (FightExpert, MacroExpert) and use <code>GroupChat</code> + <code>GroupChatManager</code>.</p> <p>Build conversational agents that analyze matches through dialogue.</p>"},{"location":"integrations/autogen/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install pyautogen langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/autogen/#setup","title":"Setup","text":"<pre><code>import asyncio\nfrom autogen import AssistantAgent, UserProxyAgent, config_list_from_json\nfrom langchain_mcp_adapters import MCPToolkit\n\n# Connect to MCP server\ntoolkit = MCPToolkit(\n    command=\"uv\",\n    args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n    cwd=\"/path/to/mcp_replay_dota2\"\n)\n\n# LLM config\nconfig_list = [{\"model\": \"gpt-4o\", \"api_key\": \"your-api-key\"}]\nllm_config = {\"config_list\": config_list}\n</code></pre>"},{"location":"integrations/autogen/#define-tool-functions","title":"Define Tool Functions","text":"<pre><code>async def get_hero_deaths(match_id: int) -&gt; dict:\n    \"\"\"Get all hero deaths in a Dota 2 match.\"\"\"\n    return await toolkit.acall_tool(\"get_hero_deaths\", {\"match_id\": match_id})\n\nasync def get_fight_combat_log(match_id: int, reference_time: float, hero: str = None) -&gt; dict:\n    \"\"\"Get combat log for a fight around a specific time.\"\"\"\n    return await toolkit.acall_tool(\"get_fight_combat_log\", {\n        \"match_id\": match_id,\n        \"reference_time\": reference_time,\n        \"hero\": hero\n    })\n\nasync def get_objective_kills(match_id: int) -&gt; dict:\n    \"\"\"Get Roshan, tower, and barracks kills.\"\"\"\n    return await toolkit.acall_tool(\"get_objective_kills\", {\"match_id\": match_id})\n</code></pre>"},{"location":"integrations/autogen/#create-agents","title":"Create Agents","text":"<pre><code># Analyst agent with tool access\nanalyst = AssistantAgent(\n    name=\"DotaAnalyst\",\n    system_message=\"\"\"You are an expert Dota 2 analyst. Use the available tools to analyze matches.\n    Always explain your findings in terms casual players can understand.\n    Focus on actionable insights - what could the losing team have done differently?\"\"\",\n    llm_config={\n        **llm_config,\n        \"functions\": [\n            {\n                \"name\": \"get_hero_deaths\",\n                \"description\": \"Get all hero deaths in a match\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\"match_id\": {\"type\": \"integer\"}},\n                    \"required\": [\"match_id\"]\n                }\n            },\n            {\n                \"name\": \"get_fight_combat_log\",\n                \"description\": \"Get combat log for a fight\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"match_id\": {\"type\": \"integer\"},\n                        \"reference_time\": {\"type\": \"number\"},\n                        \"hero\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"match_id\", \"reference_time\"]\n                }\n            },\n            {\n                \"name\": \"get_objective_kills\",\n                \"description\": \"Get Roshan and tower kills\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\"match_id\": {\"type\": \"integer\"}},\n                    \"required\": [\"match_id\"]\n                }\n            }\n        ]\n    }\n)\n\n# User proxy that can execute functions\nuser_proxy = UserProxyAgent(\n    name=\"User\",\n    human_input_mode=\"NEVER\",\n    max_consecutive_auto_reply=10,\n    code_execution_config=False,\n    function_map={\n        \"get_hero_deaths\": get_hero_deaths,\n        \"get_fight_combat_log\": get_fight_combat_log,\n        \"get_objective_kills\": get_objective_kills\n    }\n)\n</code></pre>"},{"location":"integrations/autogen/#run-analysis","title":"Run Analysis","text":"<pre><code>async def main():\n    async with toolkit:\n        await user_proxy.a_initiate_chat(\n            analyst,\n            message=\"Analyze match 8461956309. I was playing Earthshaker and we lost. What did I do wrong?\"\n        )\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/autogen/#multi-agent-discussion","title":"Multi-Agent Discussion","text":"<p>Create multiple specialists that discuss the match:</p> <pre><code>fight_expert = AssistantAgent(\n    name=\"FightExpert\",\n    system_message=\"You specialize in teamfight analysis. Focus on ability usage and positioning.\",\n    llm_config=llm_config\n)\n\nmacro_expert = AssistantAgent(\n    name=\"MacroExpert\",\n    system_message=\"You specialize in macro gameplay - objectives, map control, and timing.\",\n    llm_config=llm_config\n)\n\n# Group chat for discussion\nfrom autogen import GroupChat, GroupChatManager\n\ngroupchat = GroupChat(\n    agents=[user_proxy, analyst, fight_expert, macro_expert],\n    messages=[],\n    max_round=12\n)\n\nmanager = GroupChatManager(groupchat=groupchat, llm_config=llm_config)\n\nasync def main():\n    async with toolkit:\n        await user_proxy.a_initiate_chat(\n            manager,\n            message=\"Analyze match 8461956309 as a team. Each expert should contribute their specialty.\"\n        )\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/claude-code/","title":"Claude Code CLI","text":"\ud83e\udd16 AI Summary <p>Add to <code>.mcp.json</code> (project) or <code>~/.claude/settings.json</code> (global): <code>{\"mcpServers\": {\"dota2\": {\"command\": \"uv\", \"args\": [\"run\", \"python\", \"/path/to/dota_match_mcp_server.py\"]}}}</code>. Verify with <code>/tools</code>. Ask: \"Analyze match 8461956309\". Can also generate scripts using real match data.</p> <p>Use the Dota 2 MCP server within Claude Code for development workflows.</p>"},{"location":"integrations/claude-code/#project-level-setup","title":"Project-Level Setup","text":"<p>Add to your project's <code>.mcp.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"python\", \"/absolute/path/to/mcp_replay_dota2/dota_match_mcp_server.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/claude-code/#global-setup","title":"Global Setup","text":"<p>Add to <code>~/.claude/settings.json</code> to make it available in all projects:</p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"python\", \"/absolute/path/to/mcp_replay_dota2/dota_match_mcp_server.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/claude-code/#verify","title":"Verify","text":"<p>Run Claude Code and check available tools:</p> <pre><code>claude\n&gt; /tools\n</code></pre> <p>You should see the Dota 2 tools listed.</p>"},{"location":"integrations/claude-code/#usage","title":"Usage","text":"<p>In any Claude Code session:</p> <pre><code>&gt; Analyze match 8461956309 and tell me about the first blood\n</code></pre> <p>Claude will use the MCP tools automatically.</p>"},{"location":"integrations/claude-code/#use-case-replay-analysis-scripts","title":"Use Case: Replay Analysis Scripts","text":"<p>You can ask Claude Code to write scripts that use match data:</p> <pre><code>&gt; Write a Python script that analyzes carry farm efficiency using match 8461956309 data\n</code></pre> <p>Claude will call the tools to get real data and generate code that processes it.</p>"},{"location":"integrations/claude-desktop/","title":"Claude Desktop","text":"\ud83e\udd16 AI Summary <p>Add to <code>claude_desktop_config.json</code>: <code>{\"mcpServers\": {\"dota2\": {\"command\": \"uv\", \"args\": [\"run\", \"python\", \"dota_match_mcp_server.py\"], \"cwd\": \"/path/to/repo\"}}}</code>. Restart Claude Desktop. Look for hammer icon (\ud83d\udd28) to verify. Ask naturally: \"Analyze match 8461956309\".</p> <p>The simplest way to use this MCP server - just configure and chat.</p>"},{"location":"integrations/claude-desktop/#setup","title":"Setup","text":"<p>Add to your Claude Desktop config file:</p> <p>Linux: <code>~/.config/claude/claude_desktop_config.json</code> macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code> Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"dota2\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"python\", \"dota_match_mcp_server.py\"],\n      \"cwd\": \"/path/to/mcp_replay_dota2\"\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/claude-desktop/#restart-claude-desktop","title":"Restart Claude Desktop","text":"<p>After saving the config, restart Claude Desktop completely (quit and reopen).</p>"},{"location":"integrations/claude-desktop/#verify-connection","title":"Verify Connection","text":"<p>You should see a hammer icon (\ud83d\udd28) in the chat input area. Click it to see available tools:</p> <ul> <li><code>get_hero_deaths</code></li> <li><code>get_combat_log</code></li> <li><code>get_fight_combat_log</code></li> <li><code>get_item_purchases</code></li> <li><code>get_objective_kills</code></li> <li><code>get_match_timeline</code></li> <li><code>get_stats_at_minute</code></li> <li><code>get_courier_kills</code></li> </ul>"},{"location":"integrations/claude-desktop/#usage","title":"Usage","text":"<p>Just ask naturally:</p> <p>\"Analyze match 8461956309. Why did Radiant lose the fight at 25 minutes?\"</p> <p>Claude will automatically: 1. Call <code>get_hero_deaths</code> to find deaths around that time 2. Call <code>get_fight_combat_log</code> to get fight details 3. Synthesize an analysis</p>"},{"location":"integrations/claude-desktop/#troubleshooting","title":"Troubleshooting","text":"<p>No hammer icon? - Check the config file path is correct - Ensure <code>uv</code> is in your PATH - Check Claude Desktop logs for errors</p> <p>Tools not working? - Verify the <code>cwd</code> path is correct - Try running <code>uv run python dota_match_mcp_server.py</code> manually to check for errors</p>"},{"location":"integrations/crewai/","title":"CrewAI","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install crewai crewai-tools langchain-mcp-adapters</code>. Wrap MCP tools with <code>@tool</code> decorator. Create specialized Agents: FightAnalyst, EconomyAnalyst, ObjectiveAnalyst, LeadAnalyst. Define Tasks with <code>context</code> for dependencies. Run with <code>Crew.kickoff()</code>. Agents collaborate and synthesize analysis.</p> <p>Build multi-agent systems where specialized agents collaborate on match analysis.</p>"},{"location":"integrations/crewai/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install crewai crewai-tools langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/crewai/#setup-mcp-tools-for-crewai","title":"Setup MCP Tools for CrewAI","text":"<pre><code>import asyncio\nfrom crewai import Agent, Task, Crew\nfrom crewai_tools import tool\nfrom langchain_mcp_adapters import MCPToolkit\n\n# Connect to MCP server\ntoolkit = MCPToolkit(\n    command=\"uv\",\n    args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n    cwd=\"/path/to/mcp_replay_dota2\"\n)\n\n# Wrap MCP tools as CrewAI tools\n@tool(\"Get Hero Deaths\")\ndef get_hero_deaths(match_id: int) -&gt; dict:\n    \"\"\"Get all hero deaths in a Dota 2 match.\"\"\"\n    return toolkit.call_tool(\"get_hero_deaths\", {\"match_id\": match_id})\n\n@tool(\"Get Fight Combat Log\")\ndef get_fight_combat_log(match_id: int, reference_time: float, hero: str = None) -&gt; dict:\n    \"\"\"Get combat log for a fight around a specific time.\"\"\"\n    return toolkit.call_tool(\"get_fight_combat_log\", {\n        \"match_id\": match_id,\n        \"reference_time\": reference_time,\n        \"hero\": hero\n    })\n\n@tool(\"Get Item Purchases\")\ndef get_item_purchases(match_id: int, hero_filter: str = None) -&gt; dict:\n    \"\"\"Get item purchase timings for heroes.\"\"\"\n    return toolkit.call_tool(\"get_item_purchases\", {\n        \"match_id\": match_id,\n        \"hero_filter\": hero_filter\n    })\n\n@tool(\"Get Objectives\")\ndef get_objective_kills(match_id: int) -&gt; dict:\n    \"\"\"Get Roshan, tower, and barracks kills.\"\"\"\n    return toolkit.call_tool(\"get_objective_kills\", {\"match_id\": match_id})\n</code></pre>"},{"location":"integrations/crewai/#define-specialized-agents","title":"Define Specialized Agents","text":"<pre><code># Agent that analyzes teamfights\nfight_analyst = Agent(\n    role=\"Teamfight Analyst\",\n    goal=\"Analyze teamfights and identify what went wrong or right\",\n    backstory=\"Expert at breaking down Dota 2 teamfights, understanding ability usage and positioning\",\n    tools=[get_hero_deaths, get_fight_combat_log],\n    verbose=True\n)\n\n# Agent that analyzes economy\neconomy_analyst = Agent(\n    role=\"Economy Analyst\",\n    goal=\"Track gold, items, and farm efficiency\",\n    backstory=\"Specialist in Dota 2 economy, item timings, and net worth analysis\",\n    tools=[get_item_purchases],\n    verbose=True\n)\n\n# Agent that tracks objectives\nobjective_analyst = Agent(\n    role=\"Objective Analyst\",\n    goal=\"Track Roshan, towers, and map control\",\n    backstory=\"Expert at macro gameplay, objective timings, and strategic decisions\",\n    tools=[get_objective_kills],\n    verbose=True\n)\n\n# Lead analyst that synthesizes everything\nlead_analyst = Agent(\n    role=\"Lead Analyst\",\n    goal=\"Synthesize analysis from all specialists into actionable insights\",\n    backstory=\"Senior Dota 2 coach who combines tactical and strategic analysis\",\n    verbose=True\n)\n</code></pre>"},{"location":"integrations/crewai/#create-analysis-tasks","title":"Create Analysis Tasks","text":"<pre><code>match_id = 8461956309\n\nfight_task = Task(\n    description=f\"Analyze all major teamfights in match {match_id}. Find the 3 most impactful fights and explain what happened.\",\n    expected_output=\"Detailed breakdown of 3 key teamfights with ability usage and positioning analysis\",\n    agent=fight_analyst\n)\n\neconomy_task = Task(\n    description=f\"Analyze carry item timings in match {match_id}. Compare farming efficiency.\",\n    expected_output=\"Item timing analysis for carries with efficiency comparison\",\n    agent=economy_analyst\n)\n\nobjective_task = Task(\n    description=f\"Track all objective kills in match {match_id}. Analyze Roshan control and tower trading.\",\n    expected_output=\"Timeline of objectives with strategic analysis\",\n    agent=objective_analyst\n)\n\nsynthesis_task = Task(\n    description=\"Combine all analyses into a match report. Identify the key reasons for the outcome.\",\n    expected_output=\"Complete match analysis with 3-5 key takeaways\",\n    agent=lead_analyst,\n    context=[fight_task, economy_task, objective_task]\n)\n</code></pre>"},{"location":"integrations/crewai/#run-the-crew","title":"Run the Crew","text":"<pre><code>crew = Crew(\n    agents=[fight_analyst, economy_analyst, objective_analyst, lead_analyst],\n    tasks=[fight_task, economy_task, objective_task, synthesis_task],\n    verbose=True\n)\n\nasync def main():\n    async with toolkit:\n        result = crew.kickoff()\n        print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/crewai/#example-output","title":"Example Output","text":"<pre><code>[Fight Analyst] Analyzing deaths in match 8461956309...\n[Fight Analyst] Found 45 deaths. Identifying major fights...\n[Fight Analyst] Key fight at 24:47 - 4 deaths in 11 seconds...\n\n[Economy Analyst] Checking item timings...\n[Economy Analyst] Anti-Mage Battle Fury at 9:00 (excellent)\n[Economy Analyst] Medusa Manta at 18:00 (good)\n\n[Objective Analyst] Tracking objectives...\n[Objective Analyst] Dire took all 4 Roshans\n[Objective Analyst] 14 towers destroyed...\n\n[Lead Analyst] Synthesizing analysis...\n\nMATCH ANALYSIS - 8461956309\n===========================\nRadiant lost due to:\n1. Lost Roshan control (0/4)\n2. Teamfight at 24:47 cost them high ground\n3. Medusa snowballed with uncontested farm\n...\n</code></pre>"},{"location":"integrations/fastmcp/","title":"FastMCP Client","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install fastmcp</code>. Use <code>Client(\"uv run python dota_match_mcp_server.py\")</code> as async context manager. Call tools: <code>await client.call_tool(\"get_hero_deaths\", match_id=123)</code>. Get resources: <code>await client.get_resource(\"dota2://heroes/all\")</code>. Handles errors and supports batch processing.</p> <p>The simplest Python integration - use the same library the server is built with.</p>"},{"location":"integrations/fastmcp/#install","title":"Install","text":"<pre><code>pip install fastmcp\n</code></pre>"},{"location":"integrations/fastmcp/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom fastmcp import Client\n\nasync def main():\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Call tools directly\n        deaths = await client.call_tool(\"get_hero_deaths\", match_id=8461956309)\n        print(f\"Total deaths: {deaths['total_deaths']}\")\n\n        for death in deaths['deaths'][:5]:\n            print(f\"  {death['game_time_str']}: {death['killer']} killed {death['victim']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/fastmcp/#working-with-resources","title":"Working with Resources","text":"<pre><code>async def main():\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Get static hero reference data\n        heroes = await client.get_resource(\"dota2://heroes/all\")\n        print(f\"Total heroes: {len(heroes)}\")\n\n        # Get match-specific data using tools\n        match_heroes = await client.call_tool(\"get_match_heroes\", match_id=8461956309)\n        for hero in match_heroes['radiant'] + match_heroes['dire']:\n            print(f\"{hero['localized_name']} - {hero['team']} - K/D/A: {hero['kills']}/{hero['deaths']}/{hero['assists']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/fastmcp/#complete-analysis-script","title":"Complete Analysis Script","text":"<pre><code>import asyncio\nfrom fastmcp import Client\n\nasync def analyze_match(match_id: int):\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        # Get all data\n        deaths = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n        objectives = await client.call_tool(\"get_objective_kills\", match_id=match_id)\n\n        print(f\"\\n=== Match {match_id} Analysis ===\\n\")\n\n        # Deaths summary\n        print(f\"Total Deaths: {deaths['total_deaths']}\")\n\n        # First blood\n        if deaths['deaths']:\n            fb = deaths['deaths'][0]\n            print(f\"First Blood: {fb['game_time_str']} - {fb['killer']} killed {fb['victim']}\")\n\n        # Roshan control\n        rosh = objectives['roshan_kills']\n        print(f\"\\nRoshan Kills: {len(rosh)}\")\n        for r in rosh:\n            print(f\"  Rosh #{r['kill_number']} at {r['game_time_str']} by {r['team']}\")\n\n        # Tower score\n        towers = objectives['tower_kills']\n        radiant_towers = len([t for t in towers if t['team'] == 'radiant'])\n        dire_towers = len([t for t in towers if t['team'] == 'dire'])\n        print(f\"\\nTowers Lost - Radiant: {radiant_towers}, Dire: {dire_towers}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_match(8461956309))\n</code></pre>"},{"location":"integrations/fastmcp/#error-handling","title":"Error Handling","text":"<pre><code>async def safe_analysis(match_id: int):\n    try:\n        async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n            result = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n\n            if not result.get('success', True):\n                print(f\"Error: {result.get('error', 'Unknown error')}\")\n                return None\n\n            return result\n\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return None\n</code></pre>"},{"location":"integrations/fastmcp/#batch-processing","title":"Batch Processing","text":"<pre><code>async def analyze_multiple_matches(match_ids: list[int]):\n    async with Client(\"uv run python dota_match_mcp_server.py\") as client:\n        results = {}\n\n        for match_id in match_ids:\n            print(f\"Analyzing {match_id}...\")\n            deaths = await client.call_tool(\"get_hero_deaths\", match_id=match_id)\n            objectives = await client.call_tool(\"get_objective_kills\", match_id=match_id)\n\n            results[match_id] = {\n                \"deaths\": deaths['total_deaths'],\n                \"roshans\": len(objectives['roshan_kills']),\n                \"towers\": len(objectives['tower_kills'])\n            }\n\n        return results\n\n# Analyze recent matches\nmatches = [8461956309, 8461956310, 8461956311]\nresults = asyncio.run(analyze_multiple_matches(matches))\n</code></pre>"},{"location":"integrations/langchain/","title":"LangChain","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install langchain langchain-openai langchain-mcp-adapters</code>. Use <code>MCPToolkit</code> to connect, <code>toolkit.get_tools()</code> returns LangChain tools. Bind to any LLM: <code>llm.bind_tools(tools)</code>. Works with agents via <code>create_tool_calling_agent()</code>. Supports Claude via <code>langchain-anthropic</code>.</p> <p>Use MCP tools as LangChain tools with any supported LLM.</p>"},{"location":"integrations/langchain/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install langchain langchain-openai langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/langchain/#basic-setup","title":"Basic Setup","text":"<pre><code>import asyncio\nfrom langchain_openai import ChatOpenAI\nfrom langchain_mcp_adapters import MCPToolkit\n\nasync def main():\n    # Connect to MCP server\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with toolkit:\n        # Get tools as LangChain tools\n        tools = toolkit.get_tools()\n        print(f\"Available tools: {[t.name for t in tools]}\")\n\n        # Use with any LangChain LLM\n        llm = ChatOpenAI(model=\"gpt-4o\")\n        llm_with_tools = llm.bind_tools(tools)\n\n        response = await llm_with_tools.ainvoke(\n            \"What happened at first blood in match 8461956309?\"\n        )\n        print(response)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langchain/#with-langchain-agents","title":"With LangChain Agents","text":"<pre><code>from langchain.agents import AgentExecutor, create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate\n\nasync def main():\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with toolkit:\n        tools = toolkit.get_tools()\n        llm = ChatOpenAI(model=\"gpt-4o\")\n\n        prompt = ChatPromptTemplate.from_messages([\n            (\"system\", \"You are a Dota 2 analyst. Use the available tools to analyze matches.\"),\n            (\"human\", \"{input}\"),\n            (\"placeholder\", \"{agent_scratchpad}\")\n        ])\n\n        agent = create_tool_calling_agent(llm, tools, prompt)\n        executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n\n        result = await executor.ainvoke({\n            \"input\": \"Analyze the teamfight at 25 minutes in match 8461956309\"\n        })\n        print(result[\"output\"])\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langchain/#with-claude-via-langchain","title":"With Claude via LangChain","text":"<pre><code>from langchain_anthropic import ChatAnthropic\n\nllm = ChatAnthropic(model=\"claude-sonnet-4-20250514\")\nllm_with_tools = llm.bind_tools(tools)\n</code></pre>"},{"location":"integrations/langchain/#tool-descriptions","title":"Tool Descriptions","text":"<p>The MCP adapter preserves tool descriptions, so the LLM knows when to use each tool:</p> Tool LangChain Description <code>get_hero_deaths</code> Get all hero deaths in a Dota 2 match <code>get_fight_combat_log</code> Get combat log for a fight around a specific time <code>get_item_purchases</code> Get item purchase timings for heroes"},{"location":"integrations/langgraph/","title":"LangGraph","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install langgraph langchain-openai langchain-mcp-adapters</code>. Use <code>create_react_agent(llm, tools)</code> for simple ReAct agent. Build custom <code>StateGraph</code> for specialized flows: get_deaths \u2192 identify_fights \u2192 get_objectives \u2192 synthesize. Supports streaming via <code>astream_events()</code>.</p> <p>Build stateful, multi-step Dota 2 analysis agents with LangGraph.</p>"},{"location":"integrations/langgraph/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install langgraph langchain-openai langchain-mcp-adapters\n</code></pre>"},{"location":"integrations/langgraph/#react-agent","title":"ReAct Agent","text":"<p>The simplest LangGraph agent - reasons and acts in a loop:</p> <pre><code>import asyncio\nfrom langchain_openai import ChatOpenAI\nfrom langchain_mcp_adapters import MCPToolkit\nfrom langgraph.prebuilt import create_react_agent\n\nasync def main():\n    toolkit = MCPToolkit(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with toolkit:\n        tools = toolkit.get_tools()\n        llm = ChatOpenAI(model=\"gpt-4o\")\n\n        # Create ReAct agent\n        agent = create_react_agent(llm, tools)\n\n        # Run analysis\n        response = await agent.ainvoke({\n            \"messages\": [{\n                \"role\": \"user\",\n                \"content\": \"Analyze match 8461956309. First get all deaths, then analyze the biggest teamfight.\"\n            }]\n        })\n\n        print(response[\"messages\"][-1].content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/langgraph/#custom-graph-for-match-analysis","title":"Custom Graph for Match Analysis","text":"<p>Build a specialized graph that follows a specific analysis flow:</p> <pre><code>from langgraph.graph import StateGraph, END\nfrom typing import TypedDict, Annotated\nimport operator\n\nclass AnalysisState(TypedDict):\n    match_id: int\n    deaths: list\n    fights: list\n    objectives: list\n    analysis: str\n    messages: Annotated[list, operator.add]\n\ndef get_deaths(state: AnalysisState):\n    # Call get_hero_deaths tool\n    deaths = tools[\"get_hero_deaths\"].invoke({\"match_id\": state[\"match_id\"]})\n    return {\"deaths\": deaths[\"deaths\"]}\n\ndef identify_fights(state: AnalysisState):\n    # Find clusters of deaths = teamfights\n    fights = []\n    for death in state[\"deaths\"]:\n        fight = tools[\"get_fight_combat_log\"].invoke({\n            \"match_id\": state[\"match_id\"],\n            \"reference_time\": death[\"game_time\"],\n            \"hero\": death[\"victim\"]\n        })\n        if fight[\"duration\"] &gt; 10 and len(fight[\"participants\"]) &gt; 4:\n            fights.append(fight)\n    return {\"fights\": fights}\n\ndef get_objectives(state: AnalysisState):\n    objectives = tools[\"get_objective_kills\"].invoke({\"match_id\": state[\"match_id\"]})\n    return {\"objectives\": objectives}\n\ndef synthesize(state: AnalysisState):\n    # Use LLM to synthesize analysis\n    prompt = f\"\"\"Analyze this match:\n    - {len(state['deaths'])} total deaths\n    - {len(state['fights'])} major teamfights\n    - Roshan kills: {len(state['objectives']['roshan_kills'])}\n    - Towers: {len(state['objectives']['tower_kills'])}\n\n    Key fights: {state['fights'][:3]}\n    \"\"\"\n    response = llm.invoke(prompt)\n    return {\"analysis\": response.content}\n\n# Build graph\ngraph = StateGraph(AnalysisState)\ngraph.add_node(\"get_deaths\", get_deaths)\ngraph.add_node(\"identify_fights\", identify_fights)\ngraph.add_node(\"get_objectives\", get_objectives)\ngraph.add_node(\"synthesize\", synthesize)\n\ngraph.set_entry_point(\"get_deaths\")\ngraph.add_edge(\"get_deaths\", \"identify_fights\")\ngraph.add_edge(\"get_deaths\", \"get_objectives\")  # parallel\ngraph.add_edge(\"identify_fights\", \"synthesize\")\ngraph.add_edge(\"get_objectives\", \"synthesize\")\ngraph.add_edge(\"synthesize\", END)\n\napp = graph.compile()\n</code></pre>"},{"location":"integrations/langgraph/#streaming-results","title":"Streaming Results","text":"<p>LangGraph supports streaming for long analyses:</p> <pre><code>async for event in agent.astream_events(\n    {\"messages\": [{\"role\": \"user\", \"content\": \"Full analysis of match 8461956309\"}]},\n    version=\"v2\"\n):\n    if event[\"event\"] == \"on_chat_model_stream\":\n        print(event[\"data\"][\"chunk\"].content, end=\"\", flush=True)\n</code></pre>"},{"location":"integrations/mcp-sdk/","title":"MCP SDK","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install mcp</code>. Use <code>StdioServerParameters</code> + <code>stdio_client()</code> + <code>ClientSession</code>. Initialize with <code>await session.initialize()</code>. List tools/resources with <code>session.list_tools()</code>. Call tools: <code>session.call_tool(name, arguments={})</code>. Read resources: <code>session.read_resource(uri)</code>. Build custom client class for cleaner API.</p> <p>Use the official MCP Python SDK for low-level control.</p>"},{"location":"integrations/mcp-sdk/#install","title":"Install","text":"<pre><code>pip install mcp\n</code></pre>"},{"location":"integrations/mcp-sdk/#basic-client","title":"Basic Client","text":"<pre><code>import asyncio\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nasync def main():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            # Initialize connection\n            await session.initialize()\n\n            # List available tools\n            tools = await session.list_tools()\n            print(\"Available tools:\")\n            for tool in tools.tools:\n                print(f\"  - {tool.name}: {tool.description}\")\n\n            # List available resources\n            resources = await session.list_resources()\n            print(\"\\nAvailable resources:\")\n            for resource in resources.resources:\n                print(f\"  - {resource.uri}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/mcp-sdk/#calling-tools","title":"Calling Tools","text":"<pre><code>async def call_tool_example():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Call get_hero_deaths\n            result = await session.call_tool(\n                \"get_hero_deaths\",\n                arguments={\"match_id\": 8461956309}\n            )\n\n            # Result is a list of content blocks\n            for content in result.content:\n                if content.type == \"text\":\n                    import json\n                    data = json.loads(content.text)\n                    print(f\"Total deaths: {data['total_deaths']}\")\n\nasyncio.run(call_tool_example())\n</code></pre>"},{"location":"integrations/mcp-sdk/#reading-resources","title":"Reading Resources","text":"<pre><code>async def read_resource_example():\n    server_params = StdioServerParameters(\n        command=\"uv\",\n        args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n        cwd=\"/path/to/mcp_replay_dota2\"\n    )\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Read hero resource\n            result = await session.read_resource(\"dota2://heroes/all\")\n\n            for content in result.contents:\n                if content.mimeType == \"application/json\":\n                    import json\n                    heroes = json.loads(content.text)\n                    print(f\"Total heroes: {len(heroes)}\")\n\nasyncio.run(read_resource_example())\n</code></pre>"},{"location":"integrations/mcp-sdk/#building-a-custom-client-class","title":"Building a Custom Client Class","text":"<pre><code>import json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclass Dota2MCPClient:\n    def __init__(self, server_path: str):\n        self.server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=server_path\n        )\n        self._session = None\n        self._read = None\n        self._write = None\n\n    async def __aenter__(self):\n        transport = stdio_client(self.server_params)\n        self._read, self._write = await transport.__aenter__()\n        self._session = ClientSession(self._read, self._write)\n        await self._session.__aenter__()\n        await self._session.initialize()\n        return self\n\n    async def __aexit__(self, *args):\n        if self._session:\n            await self._session.__aexit__(*args)\n\n    async def get_hero_deaths(self, match_id: int) -&gt; dict:\n        result = await self._session.call_tool(\n            \"get_hero_deaths\",\n            arguments={\"match_id\": match_id}\n        )\n        return json.loads(result.content[0].text)\n\n    async def get_objectives(self, match_id: int) -&gt; dict:\n        result = await self._session.call_tool(\n            \"get_objective_kills\",\n            arguments={\"match_id\": match_id}\n        )\n        return json.loads(result.content[0].text)\n\n    async def get_fight(self, match_id: int, time: float, hero: str = None) -&gt; dict:\n        args = {\"match_id\": match_id, \"reference_time\": time}\n        if hero:\n            args[\"hero\"] = hero\n        result = await self._session.call_tool(\"get_fight_combat_log\", arguments=args)\n        return json.loads(result.content[0].text)\n\n# Usage\nasync def main():\n    async with Dota2MCPClient(\"/path/to/mcp_replay_dota2\") as client:\n        deaths = await client.get_hero_deaths(8461956309)\n        print(f\"Deaths: {deaths['total_deaths']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"integrations/openai-api/","title":"OpenAI API","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install openai mcp</code>. Define tools with <code>type: \"function\"</code> schema. Create <code>MCPToolExecutor</code> to call MCP server. Agentic loop: call <code>chat.completions.create()</code> with tools \u2192 check <code>message.tool_calls</code> \u2192 execute via MCP \u2192 add tool results \u2192 repeat until no tool_calls. Supports streaming and parallel tool calls.</p> <p>Use MCP tools with OpenAI models (GPT-4, GPT-4o, etc.).</p>"},{"location":"integrations/openai-api/#install","title":"Install","text":"<pre><code>pip install openai mcp\n</code></pre>"},{"location":"integrations/openai-api/#setup","title":"Setup","text":"<pre><code>from openai import OpenAI\nimport asyncio\nimport json\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nclient = OpenAI()\n\n# Tool definitions for OpenAI\nTOOLS = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_hero_deaths\",\n            \"description\": \"Get all hero deaths in a Dota 2 match\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\", \"description\": \"The Dota 2 match ID\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_fight_combat_log\",\n            \"description\": \"Get combat log for a fight around a specific time\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"},\n                    \"reference_time\": {\"type\": \"number\"},\n                    \"hero\": {\"type\": \"string\"}\n                },\n                \"required\": [\"match_id\", \"reference_time\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_objective_kills\",\n            \"description\": \"Get Roshan, tower, and barracks kills\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    },\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_item_purchases\",\n            \"description\": \"Get item purchase timings\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"match_id\": {\"type\": \"integer\"},\n                    \"hero_filter\": {\"type\": \"string\"}\n                },\n                \"required\": [\"match_id\"]\n            }\n        }\n    }\n]\n</code></pre>"},{"location":"integrations/openai-api/#mcp-tool-executor","title":"MCP Tool Executor","text":"<pre><code>class MCPToolExecutor:\n    def __init__(self, server_path: str):\n        self.server_path = server_path\n\n    async def execute(self, tool_name: str, tool_args: dict) -&gt; str:\n        server_params = StdioServerParameters(\n            command=\"uv\",\n            args=[\"run\", \"python\", \"dota_match_mcp_server.py\"],\n            cwd=self.server_path\n        )\n\n        async with stdio_client(server_params) as (read, write):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                result = await session.call_tool(tool_name, arguments=tool_args)\n                return result.content[0].text\n\nexecutor = MCPToolExecutor(\"/path/to/mcp_replay_dota2\")\n</code></pre>"},{"location":"integrations/openai-api/#agentic-loop","title":"Agentic Loop","text":"<pre><code>async def analyze_match(user_message: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are an expert Dota 2 analyst. Use the available tools to analyze matches and provide insights.\"},\n        {\"role\": \"user\", \"content\": user_message}\n    ]\n\n    while True:\n        response = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n            tools=TOOLS,\n            tool_choice=\"auto\"\n        )\n\n        message = response.choices[0].message\n\n        # Check if done\n        if message.tool_calls is None:\n            return message.content\n\n        # Add assistant message\n        messages.append(message)\n\n        # Process tool calls\n        for tool_call in message.tool_calls:\n            print(f\"Calling {tool_call.function.name}...\")\n\n            # Parse arguments\n            args = json.loads(tool_call.function.arguments)\n\n            # Execute via MCP\n            result = await executor.execute(tool_call.function.name, args)\n\n            # Add tool result\n            messages.append({\n                \"role\": \"tool\",\n                \"tool_call_id\": tool_call.id,\n                \"content\": result\n            })\n\n# Run\nresult = asyncio.run(analyze_match(\"Analyze match 8461956309. What happened at first blood?\"))\nprint(result)\n</code></pre>"},{"location":"integrations/openai-api/#streaming","title":"Streaming","text":"<pre><code>async def analyze_match_streaming(user_message: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are an expert Dota 2 analyst.\"},\n        {\"role\": \"user\", \"content\": user_message}\n    ]\n\n    while True:\n        stream = client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=messages,\n            tools=TOOLS,\n            stream=True\n        )\n\n        tool_calls = []\n        content = \"\"\n\n        for chunk in stream:\n            delta = chunk.choices[0].delta\n\n            if delta.content:\n                print(delta.content, end=\"\", flush=True)\n                content += delta.content\n\n            if delta.tool_calls:\n                for tc in delta.tool_calls:\n                    if tc.index &gt;= len(tool_calls):\n                        tool_calls.append({\"id\": \"\", \"name\": \"\", \"arguments\": \"\"})\n                    if tc.id:\n                        tool_calls[tc.index][\"id\"] = tc.id\n                    if tc.function.name:\n                        tool_calls[tc.index][\"name\"] = tc.function.name\n                    if tc.function.arguments:\n                        tool_calls[tc.index][\"arguments\"] += tc.function.arguments\n\n        if not tool_calls:\n            print()\n            return content\n\n        # Process tool calls\n        messages.append({\n            \"role\": \"assistant\",\n            \"content\": content,\n            \"tool_calls\": [\n                {\n                    \"id\": tc[\"id\"],\n                    \"type\": \"function\",\n                    \"function\": {\"name\": tc[\"name\"], \"arguments\": tc[\"arguments\"]}\n                }\n                for tc in tool_calls\n            ]\n        })\n\n        for tc in tool_calls:\n            args = json.loads(tc[\"arguments\"])\n            result = await executor.execute(tc[\"name\"], args)\n            messages.append({\n                \"role\": \"tool\",\n                \"tool_call_id\": tc[\"id\"],\n                \"content\": result\n            })\n\nasyncio.run(analyze_match_streaming(\"Full analysis of match 8461956309\"))\n</code></pre>"},{"location":"integrations/openai-api/#with-parallel-tool-calls","title":"With Parallel Tool Calls","text":"<p>GPT-4o can request multiple tools in parallel:</p> <pre><code># The agentic loop above handles this automatically\n# GPT-4o will return multiple tool_calls when it wants parallel execution\n\n# Example response structure:\n# message.tool_calls = [\n#     ToolCall(id=\"1\", function=Function(name=\"get_hero_deaths\", arguments=\"{\\\"match_id\\\": 8461956309}\")),\n#     ToolCall(id=\"2\", function=Function(name=\"get_objective_kills\", arguments=\"{\\\"match_id\\\": 8461956309}\"))\n# ]\n</code></pre>"}]}